<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="By Mr. Faisal Memon" />
  <title>iOS Crash Dump Analysis, Second Edition</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style/gitHubStyle.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<header id="title-block-header">
<h1 class="title">iOS Crash Dump Analysis, Second Edition</h1>
<p class="author">By Mr. Faisal Memon</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#disclaimer">Disclaimer</a></li>
<li><a href="#preface">Preface</a>
<ul>
<li><a href="#first-edition">First Edition</a></li>
<li><a href="#second-edition">Second Edition</a></li>
</ul></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#quick-start">Quick Start</a>
<ul>
<li><a href="#troubleshooting">Troubleshooting</a>
<ul>
<li><a href="#missing-resource-issue">Missing resource issue</a></li>
<li><a href="#binary-compatibility-issue">Binary compatibility issue</a></li>
<li><a href="#simulator-only-issue">Simulator only issue</a></li>
<li><a href="#site-specific-issues">Site specific issues</a></li>
<li><a href="#customer-device-deployment-issues">Customer device deployment issues</a></li>
<li><a href="#locale-specific-issues">Locale specific issues</a></li>
</ul></li>
<li><a href="#the-crash-mindset">The Crash Mindset</a>
<ul>
<li><a href="#locale-based-crash">Locale based Crash</a></li>
<li><a href="#geographic-location-crash">Geographic Location Crash</a></li>
<li><a href="#bus-noise-crash">Bus Noise Crash</a></li>
</ul></li>
</ul></li>
<li><a href="#basic-concepts">Basic Concepts</a>
<ul>
<li><a href="#what-is-a-crash">What is a crash?</a></li>
<li><a href="#operating-environment-policies">Operating Environment Policies</a>
<ul>
<li><a href="#nil-handling-example">Nil Handling Example</a></li>
<li><a href="#mac-address-example">MAC Address Example</a></li>
<li><a href="#camera-example">Camera Example</a></li>
<li><a href="#lessons-learnt">Lessons Learnt</a></li>
</ul></li>
<li><a href="#application-policies">Application policies</a>
<ul>
<li><a href="#when-should-we-crash">When should we crash?</a></li>
<li><a href="#when-should-we-not-crash">When should we not crash?</a></li>
</ul></li>
<li><a href="#engineering-guidance">Engineering Guidance</a>
<ul>
<li><a href="#unit-testing-the-mac-address">Unit Testing the MAC Address</a></li>
<li><a href="#ui-testing-camera-access">UI Testing Camera access</a></li>
</ul></li>
</ul></li>
<li><a href="#tooling">Tooling</a>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#reverse-engineering">Reverse Engineering</a></li>
<li><a href="#class-dump-tool">Class Dump Tool</a></li>
<li><a href="#crash-reporting-services">Crash Reporting Services</a>
<ul>
<li><a href="#plcrashreporter-based-reporting"><code>plcrashreporter</code> based reporting</a></li>
<li><a href="#metrickit-based-reporting"><code>MetricKit</code> based reporting</a></li>
<li><a href="#app-store-connect-based-reporting">App Store Connect based reporting</a></li>
</ul></li>
</ul></li>
<li><a href="#xcode-built-in-help">Xcode Built-In Help</a>
<ul>
<li><a href="#xcode-diagnostic-settings">Xcode Diagnostic Settings</a>
<ul>
<li><a href="#execution-methodology">Execution Methodology</a></li>
<li><a href="#analysis-methodology">Analysis Methodology</a></li>
<li><a href="#process-methodology">Process Methodology</a></li>
</ul></li>
<li><a href="#the-middle-road">The Middle Road</a></li>
</ul></li>
<li><a href="#hybrid-environments">Hybrid Environments</a>
<ul>
<li><a href="#program-structure">Program structure</a></li>
<li><a href="#paradigms">Paradigms</a></li>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#solutions">Solutions</a>
<ul>
<li><a href="#stl-solution">STL Solution</a></li>
<li><a href="#facade-solution">Facade Solution</a></li>
</ul></li>
<li><a href="#lessons-learnt-1">Lessons Learnt</a></li>
</ul></li>
<li><a href="#symbolification">Symbolification</a>
<ul>
<li><a href="#build-process">Build Process</a></li>
<li><a href="#build-settings">Build Settings</a></li>
<li><a href="#observing-a-local-crash">Observing a local crash</a></li>
<li><a href="#dsym-structure">DSYM structure</a></li>
<li><a href="#manual-symbolification">Manual Symbolification</a></li>
<li><a href="#reverse-engineering-approach">Reverse Engineering Approach</a></li>
</ul></li>
<li><a href="#system-diagnostics">System Diagnostics</a>
<ul>
<li><a href="#extracting-system-diagnostic-information">Extracting System Diagnostic Information</a></li>
<li><a href="#resource-profile-logs">Resource Profile logs</a>
<ul>
<li><a href="#cpu-resource-logs">CPU Resource logs</a></li>
<li><a href="#disk-utilization-logs">Disk Utilization Logs</a></li>
<li><a href="#jetsam-reports">Jetsam reports</a></li>
</ul></li>
</ul></li>
<li><a href="#the-crash-report">The Crash Report</a>
<ul>
<li><a href="#guided-tour-of-an-ios-crash-report">Guided tour of an iOS Crash Report</a>
<ul>
<li><a href="#ios-crash-report-header-section">iOS Crash Report Header Section</a></li>
<li><a href="#ios-crash-report-date-and-version-section">iOS Crash Report Date and Version Section</a></li>
<li><a href="#ios-crash-report-exception-section">iOS Crash Report Exception Section</a></li>
<li><a href="#ios-crash-report-filtered-syslog-section">iOS Crash Report Filtered Syslog Section</a></li>
<li><a href="#ios-crash-report-exception-backtrace-section">iOS Crash Report Exception Backtrace section</a></li>
<li><a href="#ios-crash-report-thread-section">iOS Crash Report Thread Section</a></li>
<li><a href="#ios-crash-report-thread-state-section">iOS Crash Report Thread State Section</a></li>
<li><a href="#ios-crash-report-binary-images-section">iOS Crash Report Binary Images section</a></li>
</ul></li>
<li><a href="#guided-tour-of-a-macos-crash-report">Guided tour of a macOS Crash Report</a>
<ul>
<li><a href="#macos-crash-report-header-section">macOS Crash Report Header Section</a></li>
<li><a href="#macos-crash-report-date-and-version-section">macOS Crash Report Date and Version Section</a></li>
<li><a href="#macos-duration-section">macOS Duration Section</a></li>
<li><a href="#macos-crash-report-system-integrity-section">macOS Crash Report System Integrity Section</a></li>
<li><a href="#macos-crash-report-exception-section">macOS Crash Report Exception Section</a></li>
<li><a href="#macos-crash-report-thread-section">macOS Crash Report Thread Section</a></li>
<li><a href="#macos-crash-report-thread-state-section">macOS Crash Report Thread State Section</a></li>
<li><a href="#macos-crash-report-binary-images-section">macOS Crash Report Binary Images section</a></li>
<li><a href="#macos-crash-report-modification-summary">macOS Crash Report Modification Summary</a></li>
<li><a href="#macos-crash-report-virtual-memory-section">macOS Crash Report Virtual Memory Section</a></li>
<li><a href="#macos-crash-report-system-profile-section">macOS Crash Report System Profile section</a></li>
</ul></li>
</ul></li>
<li><a href="#apple-silicon">Apple Silicon</a>
<ul>
<li><a href="#what-is-an-apple-silicon-mac">What is an Apple Silicon Mac?</a></li>
<li><a href="#what-is-rosetta">What is Rosetta?</a>
<ul>
<li><a href="#rosetta-binaries">Rosetta binaries</a></li>
<li><a href="#rosetta-limitations">Rosetta limitations</a></li>
<li><a href="#forcing-rosetta-execution">Forcing Rosetta execution</a></li>
</ul></li>
<li><a href="#code-translation-example">Code Translation Example</a>
<ul>
<li><a href="#icdab_rosetta_thread-lipo-information"><code>icdab_rosetta_thread</code> Lipo Information</a></li>
</ul></li>
<li><a href="#translated-crashes">Translated Crashes</a>
<ul>
<li><a href="#code-type">Code Type</a></li>
<li><a href="#thread-dumps">Thread Dumps</a></li>
<li><a href="#crashed-thread-state-registers">Crashed Thread State Registers</a></li>
<li><a href="#translated-code-information">Translated Code information</a></li>
<li><a href="#external-modification-summary">External Modification Summary</a></li>
<li><a href="#virtual-memory-regions">Virtual Memory Regions</a></li>
</ul></li>
<li><a href="#rosetta-crashes">Rosetta Crashes</a>
<ul>
<li><a href="#icdab_avx-vector-instruction-crash"><code>icdab_avx</code> vector instruction crash</a></li>
</ul></li>
<li><a href="#ios-on-mac">iOS on Mac</a>
<ul>
<li><a href="#icdab_wrap-ios-app-crash-on-macos"><code>icdab_wrap</code> iOS app crash on macOS</a></li>
<li><a href="#supporting-the-mac-from-ios">Supporting the Mac from iOS</a></li>
</ul></li>
</ul></li>
<li><a href="#pointer-authentication">Pointer Authentication</a>
<ul>
<li><a href="#configuring-pointer-authentication">Configuring Pointer Authentication</a></li>
<li><a href="#manipulating-pointers">Manipulating Pointers</a></li>
<li><a href="#icdab_ptr-pac-crash"><code>icdab_ptr</code> PAC crash</a></li>
<li><a href="#pointer-authentication-debugging-tips">Pointer Authentication Debugging Tips</a></li>
</ul></li>
<li><a href="#analytic-troubleshooting">Analytic Troubleshooting</a>
<ul>
<li><a href="#prioritizing-our-problem">Prioritizing our problem</a>
<ul>
<li><a href="#prioritizing-based-upon-impact">Prioritizing based upon impact</a></li>
<li><a href="#prioritizing-based-upon-deadlines">Prioritizing based upon deadlines</a></li>
<li><a href="#prioritizing-based-upon-trend">Prioritizing based upon trend</a></li>
</ul></li>
<li><a href="#stating-the-problem">Stating the problem</a></li>
<li><a href="#specifying-the-problem">Specifying the problem</a>
<ul>
<li><a href="#questions-to-ask">Questions to ask</a></li>
</ul></li>
<li><a href="#example-problem-specifications">Example problem specifications</a>
<ul>
<li><a href="#cameraapp-what-is-is-not-example">CameraApp What Is / Is Not Example</a></li>
<li><a href="#imac-where-is-is-not-example">iMac Where Is / Is Not Example</a></li>
<li><a href="#database-app-when-is-is-not-example">Database app When Is / Is Not Example</a></li>
<li><a href="#game-app-extent-is-is-not-example">Game app Extent Is / Is Not Example</a></li>
</ul></li>
<li><a href="#the-2018-macbook-pro-t2-problem">The 2018 MacBook Pro T2 Problem</a>
<ul>
<li><a href="#analysis-of-failures">Analysis of failures</a></li>
</ul></li>
</ul></li>
<li><a href="#a-siri-crash">A Siri Crash</a>
<ul>
<li><a href="#why-are-we-looking-at-a-siri-crash">Why are we looking at a Siri Crash?</a></li>
<li><a href="#the-crash-report-1">The Crash report</a></li>
<li><a href="#the-crash-details">The Crash details</a></li>
<li><a href="#applying-our-tool-box">Applying our Tool Box</a></li>
<li><a href="#software-engineering-insights">Software Engineering Insights</a></li>
<li><a href="#lessons-learnt-2">Lessons Learnt</a></li>
</ul></li>
<li><a href="#runtime-environment-crashes">Runtime Environment Crashes</a>
<ul>
<li><a href="#unwrapping-a-nil-optional">Unwrapping a Nil Optional</a>
<ul>
<li><a href="#ios-uikit-outlets">iOS UIKit Outlets</a></li>
<li><a href="#ownership-rules">Ownership rules</a></li>
<li><a href="#crash-report-for-unwrapped-nil-optionals">Crash Report for unwrapped nil optionals</a></li>
</ul></li>
<li><a href="#releasing-a-semaphore-that-is-in-use">Releasing a semaphore that is in use</a>
<ul>
<li><a href="#crash-example-releasing-a-semaphore">Crash example releasing a semaphore</a></li>
<li><a href="#faulty-semaphore-code">Faulty semaphore code</a></li>
<li><a href="#using-application-specific-crash-report-information">Using application specific Crash Report information</a></li>
<li><a href="#semaphore-crash-lessons-learnt">Semaphore Crash Lessons Learnt</a></li>
</ul></li>
</ul></li>
<li><a href="#bad-memory-crashes">Bad Memory Crashes</a>
<ul>
<li><a href="#general-principles">General principles</a></li>
<li><a href="#segment-violation-segv-crashes">Segment Violation (SEGV) crashes</a>
<ul>
<li><a href="#fud-crash">fud crash</a></li>
<li><a href="#leakagent-crash">LeakAgent crash</a></li>
<li><a href="#pointer-authentication-crash">Pointer Authentication crash</a></li>
</ul></li>
<li><a href="#bus-error-sigbus-crashes">Bus error (SIGBUS) crashes</a>
<ul>
<li><a href="#xbmc-crash">xbmc crash</a></li>
<li><a href="#jablotron-crash">Jablotron crash</a></li>
</ul></li>
</ul></li>
<li><a href="#application-abort-crashes">Application Abort Crashes</a>
<ul>
<li><a href="#general-principles-1">General principles</a></li>
<li><a href="#kindle-create-crash">Kindle Create Crash</a></li>
<li><a href="#type-confusion">Type confusion</a>
<ul>
<li><a href="#extracting-nsdata-from-a-configuration-file">Extracting NSData from a configuration file</a></li>
<li><a href="#deserialization-crash-report">Deserialization Crash Report</a></li>
</ul></li>
<li><a href="#not-a-number-errors">‘Not A Number’ Errors</a></li>
</ul></li>
<li><a href="#resource-crashes">Resource Crashes</a>
<ul>
<li><a href="#cpu-usage-crash">CPU Usage Crash</a></li>
<li><a href="#wake-up-crash">Wake Up Crash</a></li>
<li><a href="#wake-up-crash-exception">Wake Up crash exception</a></li>
<li><a href="#temperature-crash">Temperature Crash</a></li>
</ul></li>
<li><a href="#application-termination-crashes">Application Termination Crashes</a>
<ul>
<li><a href="#deadlock-crash">Deadlock Crash</a></li>
<li><a href="#insecure-drawing-crash">Insecure Drawing Crash</a></li>
</ul></li>
<li><a href="#failed-crashes">Failed Crashes</a>
<ul>
<li><a href="#signal-handling-failures">Signal handling failures</a></li>
<li><a href="#symbolification-failure">Symbolification Failure</a></li>
</ul></li>
<li><a href="#memory-diagnostics">Memory Diagnostics</a>
<ul>
<li><a href="#basics-of-memory-allocation">Basics of memory allocation</a></li>
<li><a href="#address-sanitizer">Address Sanitizer</a></li>
<li><a href="#memory-overshoot-example">Memory overshoot example</a></li>
<li><a href="#use-after-free-example">Use after free example</a></li>
<li><a href="#memory-management-tools">Memory Management tools</a>
<ul>
<li><a href="#guard-malloc-tool">Guard Malloc Tool</a></li>
<li><a href="#malloc-scribble">Malloc Scribble</a></li>
<li><a href="#zombie-objects">Zombie Objects</a></li>
<li><a href="#malloc-stack">Malloc Stack</a></li>
<li><a href="#dynamic-linker-api-usage">Dynamic Linker API Usage</a></li>
<li><a href="#dynamic-library-loads">Dynamic Library Loads</a></li>
</ul></li>
</ul></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="disclaimer">Disclaimer</h1>
<p>Copyright Faisal Memon 2018-2020. All Rights Reserved.</p>
<p>This publication is provided “as is” without warranty of any kind, either express or implied, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, or non-infringement.</p>
<p>This publication could include technical inaccuracies or typographical errors. Changes are periodically added to the information herein. These changes will be incorporated in new editions of the publication.</p>
<p>Apple makes no explicit or implied endorsement of this work. Materials in this book have been determined from public information sources and binaries, or materials provided by the Apple Software Development Kits.</p>
<p>Positions held by the author, as an employee or contractor, at past or future companies and institutions makes no explicit or implied endorsement of this work by those entities.</p>
<p>Every effort has been made to identify trademark terms in this text. If there is an error or omission, please contact the author. We have thus far recognized the following trademarks:</p>
<h1 id="preface">Preface</h1>
<h2 id="first-edition">First Edition</h2>
<p>This book grew from an inspiration gained back in the late 1990s.</p>
<p>It’s hard to overstate the euphoria of the moment. The Internet was the next Industrial Revolution. Investors saw it as the best place to put their money. Hardware, software and services were all experiencing a Cambrian explosion of diversity and innovation.</p>
<p>I found myself at the center of things. I was newly recruited to Sun Microsystems. At that time, if you had a great idea for a website and wanted to start serving your customers, Sun Microsystems computers were an essential purchase. These were servers that you would either house yourself or place with a co-location provider.</p>
<p>Computer technology was already well developed by then, but existing solutions were now being put to use in new scenarios, and at Internet-scale. What was a perfectly good implementation of Unix, SunOS, from the rarefied halls of Stanford University was now running on E-Bay and had to be up and running without a glitch.</p>
<p>We had an electronic board showing the status of our critical customers. Saudi Aramco was permanently lit in red to such an extent that we wondered if that was a fault on the board itself.</p>
<p>My first day was somewhat ignominious. I wasn’t even given my own cubicle. My desk looked like a school table. My keyboard had several faulty and inoperative keys. I sat in one corner of a vast cube-farm and actually forgot which corner it was at on the first day. After lunch, I returned to my desk after an extensive walk around the other corners.</p>
<p>One thing struck me was that there was a book sitting on the desk of about a quarter of the 500 odd engineers. It proudly said on the front cover, “Panic!” <span class="citation" data-cites="panicbook">(<em>Panic! Unix System Crash Dump Analysis</em> 1995)</span>. It was a book on SunOS crash dump analysis.</p>
<p>After acquiring a proper cubicle and getting to know my colleagues, I noticed that the engineers with the “Panic!” book just seemed to have that extra edge in handling low-level issues reported by Customers. Collectively it lifted the problem solving IQ of the Answer Center where I worked.</p>
<p>At Sun, there was a deep culture of learning. We were given such extensive training, and support, it was often the case we’d be doing seven courses per year - each a week long.</p>
<p>All was good until one course came up. It was called Analytical Troubleshooting (ATS). This caused great controversy within the Answer Center. It was a formal methodology for solving problems. It could not tell you the answers, but it would ensure you were forced to ask the right questions. It turned out that on our hardest problems, we were missing asking the right questions.</p>
<p>This was a major step improvement in productivity. Nevertheless, some engineers, quite out of character, were loudly critical. It turned out that these techniques were just things experienced engineers had learnt as part of their craft and they didn’t want the magic to be laid bare for anyone to pick up cheaply.</p>
<p>One day Chris Drake was in town and popped into our office. He was the x86 architecture specialist that collaborated with Kimberley Brown to produce the “Panic!” book. They arranged a workshop to educate us on SunOS crashes on x86 architecture. It was something of a novelty at the time, prior to the remarkable rise of Linux and the GNU/Linux system.</p>
<p>I remember one time, as an undergraduate student, during an Operating Systems lecture, I looked across the room. I noticed it was full of Sun Microsystems equipment; I stared into the Sun logo and dreamed of one day working there. It came true. So in my workshop on x86 panics, I had another idea. One day I would write a book. It would be something quite focussed on a single technical problem. It would be something that would convey the experiences I had obtained in my career. It turns out that came true, as well, in the book you are reading now!</p>
<h2 id="second-edition">Second Edition</h2>
<p>It has been a mere two years, but the pace of development of Apple Technologies is as fast as ever.</p>
<p>My professional journey has been most interesting during this period, as I was hired as a contractor (known as a vendor-on-site contractor) for Apple. Like many engineers before me, I was firmly of the opinion that getting through the hiring process was some kind of fluke, or mistake. Holding the Apple badge in my hand, it felt like it was a magical key; so clean, perfectly formed, and succinct, as any Apple product. As a matter of fact, I never worked on the secret stuff at Apple, but other people did. There was a running joke, however. “Have you found the secret room?” one engineer would ask the new hires. I puzzled about it during the first couple of weeks, and then found it hiding in plain sight! A cavern. At Apple, it was more a matter of being a master of the public APIs in your focus area, and working with other engineers to solve problems in those areas (my area was Accessibility). An intense, but interesting, two years.</p>
<p>This second edition of the book was prompted by a long-speculated addition to the Apple product line-up, Apple Silicon Macs.</p>
<p>I’ve updated the text, and modernized the examples, to reflect the latest OS versions and SDKs. As of the time of writing, these are iOS 14.2, macOS 11.0 Big Sur, and Xcode 12.2.</p>
<p>It seems to me the direction of travel of Apple Products is towards Apple Silicon chips, which utilize the ARM ABI, and the advanced features that come with recent versions of this architecture. To this end, I have introduced chapters on translation mode crashes on Apple Silicon, and Pointer Authentication crashes.</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I’d like to acknowledge the help and support of my colleagues for writing this book.</p>
<p>I am indebted to the support of my Chinese-language translator, XiaWenqiang, for helping bring the Chinese edition of the book into fruition.</p>
<p>Putting together this work was only possible because it was built upon generously provided open source tools, in particular <code>pandoc</code> which made writing the text of the book a pleasure.</p>
<p>Lastly, I’d like to thank my supportive family whilst I was locked in my study, and largely absent. Thank you Junghyun, and Christopher.</p>
<h1 id="introduction">Introduction</h1>
<p>This book fills a gap that has emerged between Application Developers and the platform they are developing for when a crash occurs. The mindset of the Application developer is largely understanding high-level concepts and abstractions. When a crash occurs, you can often feel rudely transported into a command line UNIX world of low level constructs, pointers and raw data.</p>
<p>We focus exclusively on the Apple ecosystem.</p>
<p>We cover iOS, macOS, tvOS, watchOS and BridgeOS platforms, ARM Assembly, and C (CoreFoundation), Objective-C, Objective-C++ and Swift programming languages. This is because the older languages are more prone to crash bugs. Real world applications tend to end up being a hybrid between the safer Swift language and older technologies.</p>
<p>We cover the newer developments of the Apple ecosystem. In particular, new issues arising from the use of Apple Silicon Macs.</p>
<p>We assume you have at least an introductory knowledge of iOS programming and software engineering, and have access to a Mac with Xcode.</p>
<p>The approach we take is to combine three different perspectives on the problem to give a rounded and robust view of the situation and how to resolve it.</p>
<p>Our first perspective is to deliver a HOW-TO guide for using the excellent tooling available from Apple.</p>
<p>Our second perspective is to provide a discussion of software engineering concepts tailored to preventing and resolving crashes.</p>
<p>Our third perspective is to offer a formal problem-solving approach but applied to crash analysis.</p>
<p>Programming literature comprehensively has documented software engineering concepts, and Apple has documented their crash dump tooling via Guides and WWDC videos.</p>
<p>Formal problem solving is less discussed in software engineering circles, perhaps because it’s considered a table stakes skill for an engineer. It is however a discipline of its own and when directly studied can only enhance the “natural” abilities that seem to mark out the “technically-minded” folks from the rest of the population.</p>
<p>Our goal is not the shy away from repeating knowledge we’ve probably seen or read elsewhere but instead we take the viewpoint of explaining the whole narrative in a cohesive manner. What makes crash dump analysis hard is that significant background knowledge is often assumed in order to make room to concentrate on the particulars of a specific tool or Crash Report. That causes a barrier to entry, which this book aims to overcome.</p>
<p>To complement the book, there is a website of resources which is intended to be used alongside the printed material so example projects can be setup and run by yourself and experimented with. All references in this book are collected into the Bibliography Chapter at the end of the book. There you will find URLs to resources, for example.</p>
<p>The GitHub website supporting the book is at <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<h1 id="quick-start">Quick Start</h1>
<p>When an application crash appears after a recent code change, it can be straightforward to reason about the crash and look at the relevant code changes. Often, crashes just appear due to a change in operating environment. Those can be the most annoying. For example, the app runs fine in the Office but crashes at the customer Site. We don’t have time to get into why, but need a quick fix or workaround. Another common problem scenario arises when a new project is being explored. This is where we have no prior experience with the code base but immediately face crash problems after compilation and running the app.</p>
<p>In this chapter, we explore possible reasons for crashing due to a change in operating environment. Many problems can be dealt with without getting into logical analysis of the specifics of the problem at hand. In reality sometimes we just need to make progress, whilst making a note to go back and address the root cause.</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="missing-resource-issue">Missing resource issue</h3>
<p>Sometimes our app crashes on startup due to a missing resource issue.</p>
<p>We should try compiling and running other Xcode targets within the same project. Sometimes a specific target is the one that sets up the needed environment as part of the build. If so, we can make a note to address that later.</p>
<h3 id="binary-compatibility-issue">Binary compatibility issue</h3>
<p>Sometimes our app crashes on startup due to a binary compatibility issue.</p>
<p>If we’ve recently updated Xcode, or pulled code updates on top of a compiled project, we can perform an Option-Command-Shift-K clean which cleans the build area of intermediates, and then re-build as normal.</p>
<h3 id="simulator-only-issue">Simulator only issue</h3>
<p>Sometimes our app crashes only on simulator.</p>
<p>Here we should try Simulator Hardware-&gt;Reset all content and settings. We can try iPad simulator instead of iPhone simulator or vice-versa. Sample projects are often used to explain a particular technology without regard to productization or generality.</p>
<h3 id="site-specific-issues">Site specific issues</h3>
<p>Sometimes our app only crashes when at customer site.</p>
<p>We can check Wi-Fi settings or try hot-spotting our iPad to an iPhone. Sometimes network issues such as connectivity, or latency are overlooked when developing our app in the office/home environment. We should make a note to fix networking assumptions if that is the problem.</p>
<h3 id="customer-device-deployment-issues">Customer device deployment issues</h3>
<p>Sometimes our app only crashes when deployed onto a customer device.</p>
<p>If we cable up our laptop to the customer’s device, we’re probably doing a Debug release deployment. This means push notification tokens will be the development tokens not the production tokens. It also may mean that resource access grants (to Camera for example) are no longer valid as they may have been approved via a TestFlight or App Store version of the app previously (production version).</p>
<p>We should try switching deployment configuration via <code>Command-&lt;</code>, selecting <code>Run</code> in the left panel, <code>Info</code> tab in the right panel, <code>Build Configuration</code> setting <code>Release</code> (not <code>Debug</code>). We should also manually check any resource access grants in the iPad/iPhone settings.</p>
<h3 id="locale-specific-issues">Locale specific issues</h3>
<p>Sometimes deploying with the customer’s locale causes a crash.</p>
<p>Resource files might be absent in the wrong locale. Furthermore, locale handling is rife with undocumented special cases. We should try changing the locale temporarily to a known working one. Make a note to return to the issue when back in the office.</p>
<h2 id="the-crash-mindset">The Crash Mindset</h2>
<p>One take away lesson from the above examples is that we need to think of our code in a wider context. We should think of the operating environment of our app. This comprises:</p>
<ul>
<li>the compiled code</li>
<li>binary incompatibilities between code modules (different language versions, compilers and toolchains)</li>
<li>resource files bundled or downloaded into the app</li>
<li>the build configuration (e.g. Release or Debug)</li>
<li>the network environment, availability/latency/speed</li>
<li>permissions granted to the app</li>
<li>permissions denied to the app (in a Mobile Device Management secured environment)</li>
<li>platform variants</li>
<li>orientation</li>
<li>foreground and background operating modes</li>
<li>hardware performance (old slow hardware versus faster newer devices)</li>
<li>hardware components (GPU, Memory, CPU, accessories, etc.)</li>
<li>geographic location related issues</li>
<li>locale issues</li>
<li>presence of diagnostics settings</li>
<li>presence of a debugger or profiler</li>
<li>the OS version of the target device</li>
</ul>
<p>As a first step in getting into the correct mindset to tackle app crashes, its worthwhile working through each of the above operating environment differences and trying to note down if such a difference ever resulted in a crash that we know about or suspect could happen. This teaches us that crashes are much more about <strong>environment</strong> than about <strong>source code</strong>. Another secondary insight is: the more able we are to produce a list of hypotheses, given a specific environment difference, the more easily and quickly we will be able to find the root cause of crashes. It may seem mysterious to other people, and almost magical, that we were able to come up with a suggestion of where the problem could be.</p>
<p>Here are some curious examples of crashes from the Information Technology folklore to whet our appetite, and get us thinking:</p>
<h3 id="locale-based-crash">Locale based Crash</h3>
<p>The Russian locale caused a crash during date processing.</p>
<p>This was because 1984-04-01 was being used as a sentinel date marker. However, in Russia, there is no such date/time because there is no midnight at that point in time. Daylight time started in Russia on that date with a +1 hour.</p>
<p>This was seen during development of the WecudosPro iPad app when it was tested in Russia</p>
<h3 id="geographic-location-crash">Geographic Location Crash</h3>
<p>A computer was crashing each day at a different time.</p>
<p>The actual problem was the computer was near a window next to an estuary where ships passed by. At high tide, a military ship would sail past and its RADAR would disrupt the electronics and cause a crash.</p>
<p>This folklore story was told to Sun Microsystems Answer Center engineers in the UK during Kepner-Tregoe formal problem solving training.</p>
<h3 id="bus-noise-crash">Bus Noise Crash</h3>
<p>When a computer was under both heavy network load, and disk load, the system would crash.</p>
<p>The crash was due to corruption on disk. There were zeroes every 64 bytes. It was the cache line size of the computer. The memory board was not wired up correctly causing noise at 64 byte boundaries picked up by the disk ribbon cable sitting next to it.</p>
<p>This was seen in an early prototype of a Sun Volume Systems Group computer.</p>
<h1 id="basic-concepts">Basic Concepts</h1>
<h2 id="what-is-a-crash">What is a crash?</h2>
<p>Inside our computers is an Operating Environment. This comprises one or more running Operating Systems, and Application Software. Operating Systems and Application Software are distinguished by the fact that OS software runs with higher CPU privileges (kernel mode) than Application Software (user mode).</p>
<p>The basic conceptual model of our application software sitting on an Operating System which itself sits on hardware is normally sufficient. However, modern computer systems have multiple co-operating subsystems. For example, a MacBook Pro with TouchBar will have the main operating system, macOS, but also Bridge OS providing the TouchBar interface, disk encryption and “Hey Siri!” support. The multimedia and networking chips in our computers are advanced components and can have their own real-time Operating Systems running on them. Our Mac software will be just one of many applications running on macOS.</p>
<p>An application crash is something the Operating Environment does to our application in response to what we have done (or failed to do) in the Operating Environment that violates some <em>policy</em> of the platform we are running on.</p>
<p>When the Operating System detects a problem in the Operating System, it can crash itself. This is called a kernel panic.</p>
<h2 id="operating-environment-policies">Operating Environment Policies</h2>
<p>The policies of the operating environment are there to ensure security, data safety, performance, and privacy of the environment to the user.</p>
<h3 id="nil-handling-example">Nil Handling Example</h3>
<p>Newcomers to the Apple ecosystem are often surprised to learn that Objective-C allows us to message a nil object. It silently ignores the failed dispatch. For example, the following method runs ok.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>- (<span class="dt">void</span>)nilDispatchDoesNothing</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>{</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    NSString *error = NULL;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    assert([error length] == <span class="dv">0</span>);</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>The Objective-C runtime authors made a judgement call, and decided it was better for an application to ignore such problems.</p>
<p>However if we dereference a C pointer we get a crash.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">void</span> nullDereferenceCrash() {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="dt">char</span> *nullPointer = NULL;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    assert(strlen(nullPointer) == <span class="dv">0</span>);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>The authors of the operating system have setup the system so access to this and other low memory addresses causes the hardware to trap on this illegal access and abort our program.</p>
<p>This area of memory is set aside by the operating system because it indicates a programming error of not setting up an object or data structure properly.</p>
<p>When things go wrong, we don’t always get a crash. Only if it is Operating Environment policy then we get a crash.</p>
<h3 id="mac-address-example">MAC Address Example</h3>
<p>Consider the example of getting the MAC address of our iPhone. The Media Access Control (MAC) address is a unique code allocated to network cards to allow machines to talk to each other without duplication at the Data Link layer of the communication stack.</p>
<p>Prior to iOS 7, the MAC address was not considered a sensitive API. So requesting the MAC address using the <code>sysctl</code> API gave the real address. To see this in action, see the <code>icdab_sample</code> app <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span>.</p>
<p>Unfortunately, the API was abused as a way of tracking the user - a privacy violation. Therefore, Apple introduced a policy from iOS 7 where they would return a fixed MAC address always.</p>
<p>Apple could have chosen to crash our app when any call to <code>sysctl</code> was made. However, <code>sysctl</code> is a general-purpose low-level call which can be used for other valid purposes. Therefore the policy set by iOS was to return a fixed MAC address <code>02:00:00:00:00:00</code> whenever that was requested.</p>
<h3 id="camera-example">Camera Example</h3>
<p>Now lets consider the case of taking a photo using the camera.</p>
<p>Introduced in iOS 10, when we want to access the Camera, a privacy sensitive feature, we need to define human readable text that is presented inside the system permission dialogue before access to the Camera is granted.</p>
<p>If we don’t define the text in our <code>Info.plist</code> for <code>NSCameraUsageDescription</code> we still see the following code evaluating true and then attempting to present the image picker.</p>
<pre class="swift"><code>func handlePickerButtonPressed() {
    if UIImagePickerController.isCameraDeviceAvailable(.front) {
        let imagePicker = UIImagePickerController()
        imagePicker.delegate = self
        imagePicker.sourceType = .camera
        imagePicker.allowsEditing = true
        self.present(imagePicker, animated: true, completion:
 nil)
    }
}</code></pre>
<p>However when we run the code, via Xcode 12.2, we see a crash with a descriptive console message:</p>
<pre><code>2020-10-03 17:59:10.458176+0100 icdab_camera[6908:6483411]
 [access] This app has crashed because it attempted to access
 privacy-sensitive data without a usage description.  The app&#39;s
 Info.plist must contain an NSCameraUsageDescription key with a
 string value explaining to the user how the app uses this data.
Message from debugger: Terminated due to signal 9</code></pre>
<h3 id="lessons-learnt">Lessons Learnt</h3>
<p>Note the contrast here. In both cases there was a privacy sensitive API. However, in the camera case, Apple chose a policy of crashing our app instead of giving a warning, allowing a boilerplate standard explanation dialog, or returning a <code>false</code> value to indicate the source type was not available.</p>
<p>This seems like a harsh design choice. The API in question originates from iOS 4.0. When Xcode 10.0 was introduced (this delivers the iOS 12 SDK) the behavior of the API changed. It returns <code>false</code> if the camera is not available due to a missing privacy string in the application <code>Info.plist</code> However by Xcode 11.x (this delivers iOS 13.x SDK) logic had changed back to the original logic of returning <code>true</code>.</p>
<p>This underlies the point about there being two entities involved, the program and the operating environment (which includes its policies). Having correct source code does not guarantee crash free running. When we see a crash we need to think about the operating environment as much as the code itself.</p>
<h2 id="application-policies">Application policies</h2>
<p>The application we are writing can also request a crash. This is typically done via <code>assert</code> calls in our code. These calls ask the Operating Environment to terminate our app if any <code>assert</code> has failed. The Operating Environment then aborts our app. In the Crash Report we get a:</p>
<p><code>Exception Type:  EXC_CRASH (SIGABRT)</code></p>
<p>to indicate it was the application that requested the crash in the first place.</p>
<h3 id="when-should-we-crash">When should we crash?</h3>
<p>We can apply similar standards as the Operating Environment for our crash policy.</p>
<p>If our code detects a data integrity issue, we could crash to prevent further data corruption.</p>
<h3 id="when-should-we-not-crash">When should we not crash?</h3>
<p>If the problems have resulted directly from some IO problem (file or network access for example) or some human input problem (such as a bad date value) then we should not crash.</p>
<p>It’s our job as the application developer to shield the lower level parts of the system from unpredictability present in the real world. Such problems are better dealt with by logging, error handling, user alerts, and IO retries.</p>
<h2 id="engineering-guidance">Engineering Guidance</h2>
<p>How should we guard against the privacy problems described above?</p>
<p>The thing to keep in mind is that any code that touches upon the policies the Operating Environment has guards for is a good candidate for automated testing.</p>
<p>In the <code>icdab_sample</code> project we have created Unit tests and UI tests.</p>
<p>Test cases always feel over-the-top when applied to trivial programs. But consider a large program that has an extensive <code>Info.plist</code> file. A new variant of the app is designed, so another <code>Info.plist</code> is created. Then keeping the privilege settings in sync between the different build targets becomes an issue. The UI test code shown here, which merely launches the camera, can catch such problems easily so has practical business value.</p>
<p>Similarly, if our app has a lot of low-level code and then is ported from iOS to tvOS, for example, how much of that OS-sensitive code is still applicable?</p>
<p>Unit testing a top level function comprehensively for different design concerns can pay off the effort invested in it before delving deeper and unit testing the underlying helper function calls in our code base. It’s a strategic play allowing us to get some confidence in our application and early feedback on problem areas when porting to other platforms within the Apple Ecosystem (and beyond).</p>
<h3 id="unit-testing-the-mac-address">Unit Testing the MAC Address</h3>
<p>The code to get the MAC address is not trivial. Therefore it merits some level of testing.</p>
<p>Here is a snippet from the Unit tests:</p>
<pre class="swift"><code>    func getFirstOctectAsInt(_ macAddress: String) -&gt; Int {
        let firstOctect = macAddress.split(separator: &quot;:&quot;).first!
        let firstOctectAsNumber = Int(String(firstOctect))!
        return firstOctectAsNumber
    }

    func testMacAddressNotNil() {
        let macAddress = MacAddress().getMacAddress()
        XCTAssertNotNil(macAddress)
    }

    func testMacAddressIsNotRandom() {
        let macAddressFirst = MacAddress().getMacAddress()
        let macAddressSecond = MacAddress().getMacAddress()
        XCTAssert(macAddressFirst == macAddressSecond)
    }

    func testMacAddressIsUnicast() {
        let macAddress = MacAddress().getMacAddress()!
        let firstOctect = getFirstOctectAsInt(macAddress)
        XCTAssert(0 == (firstOctect &amp; 1))
    }

    func testMacAddressIsGloballyUnique() {
        let macAddress = MacAddress().getMacAddress()!
        let firstOctect = getFirstOctectAsInt(macAddress)
        XCTAssert(0 == (firstOctect &amp; 2))
    }</code></pre>
<p>In fact, the last test fails because the OS returns a local address.</p>
<h3 id="ui-testing-camera-access">UI Testing Camera access</h3>
<p>For testing camera access, we have written a simple UI test case which just presses the <strong>Choose Picture</strong> button.</p>
<pre class="swift"><code>func testTakePhoto() throws {
    let app = XCUIApplication()
    app.launch()
    app.buttons[&quot;Choose Picture&quot;].tap()
}</code></pre>
<p>This UI test code caused an immediate crash.</p>
<h1 id="tooling">Tooling</h1>
<h2 id="overview">Overview</h2>
<p>We have a rich set of tools available to assist crash dump analysis. When used properly they can save a huge amount of time. One way to think about crash dump tools is to consider where along the software development and release cycle we are on.</p>
<p>At development time, we have static analysis tools in Xcode, and runtime metrics when running our app via Xcode. When running on device, we have crash reports that explain problems. We have Xcode diagnostics which can be switched on to instrument our app in an area of interest. There are third party tools which we can use to look inside (Reverse Engineer) our app binary to help us understand what is happening. Furthermore, macOS also provides a lot of similar functionality from the command line. Note much of the code in our apps is either in first party frameworks, or third party libraries, for which we generally do not have the source code.</p>
<p>At beta time, we have the Xcode Organizer which can report on how our app is performing in the field. Xcode retrieves performance and crash information for those beta customers that have opted-in to such data collection. App Store Connect can also provide this information. Third party crash reporting tools and services can be employed to give further context to the problems. Introduced in iOS 14, diagnostics are provided through the <code>MetricKit</code> framework, and this provides a first party API to obtain crash information, and other diagnostics, from our app to send on to third party crash reporting services.</p>
<p>At release time, we have similar facilities to what is available at beta time, but we generally have bigger scale - more users, and more crash report instances. This is usually where the more rare bugs, and unexpected user workflows, show up because we are one step further removed from our customer base. This is where the phased release option within App Store Connect comes in handy. It will gradually roll out the update of our app to the installed base that have enabled automatic updates.</p>
<p>Xcode provides much help out of the box. However, using and comprehending the information Xcode tools provide is daunting. In later chapters, we go through examples showing the use of such tools.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>Reverse engineering is where an already built binary (such as an application, library, or helper process daemon), is studied to determine how it works. For a specific Object, we might want to find out:</p>
<ul>
<li>what are the lifecycles of the objects it is provided?</li>
<li>what checks does it do on objects?</li>
<li>what files or resources does it depend on?</li>
<li>why did it return a failure code?</li>
</ul>
<p>We generally do not want to know everything, only something specific to help build a hypothesis. Once we have a hypothesis, we will test it in relation to the crash dump we are dealing with.</p>
<p>How far should we go with reverse engineering, and how much money and time to invest in it is a good question. We offer the following recommendation:</p>
<ul>
<li>If we are just starting our application developer journey, or we have limited funds, then just stick with the standard Xcode tooling, macOS command line, and the open source class-dump tool.</li>
<li>If we are a professional application developer, we should strongly consider buying a commercial reverse engineering tool. The one that draws most attention is Hopper; it provides a lot of functionality offered by IDA Pro (a high end tool). It is well priced and can pay for itself in gained productivity even if only used a handful of times. We show how Hopper can be used in this book.</li>
<li>If we are a professional penetration tester, reverse engineer, or security researcher, then we will be probably wanting to invest in the top of the line software tool, IDA Pro. This tool costs thousands, but is often purchased as a company wide expense.</li>
</ul>
<h2 id="class-dump-tool">Class Dump Tool</h2>
<p>One of the great things about the Objective-C runtime is that it carries lots of rich program structure information in its built binaries. These allow the dynamic aspects of the language to work. In fact, its flexibility of dynamic dispatch is a source for many crashes.</p>
<p>We recommend installing the <code>class-dump</code> tool right away because we shall reference its usage in later chapters. See <span class="citation" data-cites="class-dump-tool">Nygard (2018)</span></p>
<p>The class dump tool allows us to look at what Objective C classes, methods and properties are present in a given program.</p>
<h2 id="crash-reporting-services">Crash Reporting Services</h2>
<p>The Apple Crash Reporter tool and supporting infrastructure in App Store Connect is excellent but has some room for improvement.</p>
<h3 id="plcrashreporter-based-reporting"><code>plcrashreporter</code> based reporting</h3>
<p>A formidable piece of Open Source software, <code>plcrashreporter</code>, has been written by Landon Fuller, of Plausible Labs. <span class="citation" data-cites="plcrashreporter">(“Plausible Labs Crash Reporter” 2018)</span></p>
<p>The idea is to make our app handle all the possible signals and exceptions that can occur that would otherwise be unimplemented by the app and thus lead to the underlying Operating System to handle the crash.</p>
<p>With this solution, the crash data can be recorded, and then later communicated to a server of our own choice.</p>
<p>There are two benefits. Firstly, the crash handler can be fixed to handle edge cases not already handled by the Apple <code>ReportCrash</code> tool. Secondly, a more comprehensive server side solution can be employed.</p>
<p>For those wanting to explore, and understand, the Operating System, and low-level application code, <code>plcrashreporter</code> provides an excellent opportunity to study a well-engineered piece of system software.</p>
<p>When a company has many apps, many app variants, and has apps based on competitor platforms such as Android, a more powerful multi-platform solution is needed. Handling crash reports soon becomes a management problem. Which crash is the most serious? How many customers are affected? What are the metrics for quality and stability saying?</p>
<p>A number of commercial solutions are available, largely based upon the above Open Source project.</p>
<p>The Mobile Software Development field has grown into a big industry over the last few years. Many specialist companies serve App Developers as their customers. The field is very active in terms of mergers and acquisitions. Therefore, we cannot name the competitors in the Crash Reporting space in this book, as the list would be constantly changing.</p>
<p>A good place to start is the <code>rollout.io</code> blog posting that reviewed different players in the market. <span class="citation" data-cites="3rdpartycrashtools">(“IOS Crash Reporting Tools” 2017)</span></p>
<h3 id="metrickit-based-reporting"><code>MetricKit</code> based reporting</h3>
<p>Since iOS 14 there has been a substantial improvement in first party support for diagnostics reporting.</p>
<p>The <code>MetricKit</code> framework allows apps in their beta or release phase to report diagnostic information to our app. We think of this as a well-defined conduit, whose data would typically be passed onto a web service to further analyze the crash, or diagnostic condition. This will place third party crash reporting services on an official API footing rather than using a <code>plcrashreporter</code>-based solution.</p>
<h3 id="app-store-connect-based-reporting">App Store Connect based reporting</h3>
<p>The App Store Connect website overall has been made available as a web service with a public API. Since 2020, the API now allows diagnostic information to be retrieved. This improves the developer workflow by allowing continuous integration systems to more deeply embed the true end-to-end lifecycle of app development. As a hypothetical example, a CI system could detect a high crash rate and push out an emergency update based on an earlier release. This would reduce the pressure on the engineering staff to conduct an analysis of why a bad release was made, allowing time to prepare the appropriate fix for the problem.</p>
<h1 id="xcode-built-in-help">Xcode Built-In Help</h1>
<p>Xcode provides significant help to developers in understanding and preventing crashes.</p>
<p>We think of Xcode in layers of sophistication, where at the lowest layer of sophistication Xcode directly tells us the common error it has seen with suggested corrections, up to the highest level were Xcode is telling the raw information, but we need Operating Systems knowledge to interpret the information ourselves.</p>
<p>We shall revisit Xcode configuration, setup and tooling many times. Nevertheless, let us first start off with the simple but high value assistance Xcode provides.</p>
<h2 id="xcode-diagnostic-settings">Xcode Diagnostic Settings</h2>
<p>By opening the project <code>icdab_sample</code> <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> and looking at the Scheme definition and then highlighting the Diagnostics tab we see the following options:</p>
<p><img src="screenshots/diagnostic_settings.png" /></p>
<h3 id="execution-methodology">Execution Methodology</h3>
<p>If we have a crash that is reproducible from our own developer environment and source code, then a methodology for finding the cause of the crash is to switch on the appropriate diagnostic setting, and then re-run our application.</p>
<p>As we become familiar with each diagnostic, we will know which option to switch on. We shall work through different scenarios so we understand when to use each. But when we are just starting out its worth just going through each one-by-one to get a feel for what is available. The basic approach is:</p>
<ol type="1">
<li>Write a Unit Test Case or UI Test Case that hits the problem.</li>
<li>Enable just one of the Diagnostic options from above starting with our best guess.</li>
<li>Run our tests.</li>
<li>Take note of any warning or console message from Xcode.</li>
<li>Repeat again but choosing a different diagnostic option if the problem is not understood.</li>
</ol>
<h3 id="analysis-methodology">Analysis Methodology</h3>
<p>Another complementary approach for analyzing and proactively avoiding crashes is to run the Code Analyzer. This is invoked using Command-Shift-B</p>
<p>In the sample app <code>icdab_sample</code> the Analyzer reports:</p>
<pre><code>.../source/icdab_sample/icdab_sample/macAddress.m:22:12:
 warning: Null pointer argument in call to string length function
    assert(strlen(nullPointer) == 0);</code></pre>
<p>and conveniently marks up our source code</p>
<p><img src="screenshots/analyser_null.png" /></p>
<p>This can be switched on for whenever the project is built, either in shallow or deep mode according to how we feel the tradeoff should be done between slower more thorough analysis versus quicker build times with less analysis. It is in the Build Settings tab for the Xcode project file.</p>
<p><img src="screenshots/static_analyser_build.png" /></p>
<p>For a large project that has never had an Analysis report done, the output can be overwhelming. There will be some noise in the report but it generally does a good job. There will be duplication in the report because certain classes of error will repeat throughout the code.</p>
<p>If we are developing code using the Agile software methodology, then it is possible to frame the report as potential backlog items that can be worked upon during the time allocated for refactoring and maintenance.</p>
<p>In a large software project refactoring and maintenance should be around 20% of the work in a Sprint. Different viewpoints arise in this area. The author recommends doing such work alongside the normal development activities so long as no high-risk changes are amongst the work being done. For risky changes, leave that until after a major update of the app has been done. There is usually a lull where planning and strategy is developed following a release, which allows a convenient software engineering window to tackle such matters.</p>
<h4 id="ios-quickedit-app-case-study">iOS QuickEdit App Case Study</h4>
<p>Where the analyzer identifies potential crashes, from an economic point of view, it is a good investment to fix the problem. For example in the case of the QuickEdit iOS App, about 1 million lines of Objective-C, with 70 000 daily active users, the analyzer was run and found 13 clear crashing issues. We created one engineering story (“Fix top analyzer errors”). All 13 issues were fixed in the same day with testing taking two more days. Crashes are a top complaint from customers. Bugs found in the field typically are 20 times the effort and cost compared to those found in development. With a large population of users, potentially experiencing a severe crash bug, the cost of those 13 bugs could be 20 * 3 days = 60 days wasted effort.</p>
<p>QuickEdit due to its age only used manual reference counting in Objective-C. Despite this, it had a reliability of 99.5% based on app analytics. Only about 5% of engineering effort was needed to maintain this stability over time once the initial issues had been addressed.</p>
<h3 id="process-methodology">Process Methodology</h3>
<p>One way to drive out crashes from our app, particularly when we are in a large organization, is to factor it in our software development process.</p>
<p>When a developer proposes a code change in a pull request, get the developer to ensure no new analyzer warnings are introduced. We might consider the analyzer report as a robotically generated code review available to us for free. That is particularly helpful if we are working alone on a project with no peer to review our code.</p>
<p>When code is committed to a feature branch, have the automated tests run on it, with different diagnostics settings set. This can shake out problems automatically.</p>
<p>Before each release, schedule time to run some specific user cases under the memory profiler to look at memory usage or other key metrics. Record the highlights such as the peak memory usage as well as the profile file. Then when the following release is made we have a yardstick to see how things have changed both quantitatively and qualitatively.</p>
<h2 id="the-middle-road">The Middle Road</h2>
<p>Most software developers know what they “should” be doing; clean code, proper tests, code reviews, etc.</p>
<p>We recommend taking a measured approach. There is a time for hacking together a sample app to understand a concept. There is a time to write a prototype that just needs to prove a business use case. There is a time to write heavily trusted code used by many people.</p>
<p>We take the view that maximizing economic impact is the goal that matters the most because most developers are involved in professional software development. Alternatively, if we are working on non-commercial projects or hobby projects, the economic impact is really our personal free time which we will want to use most effectively.</p>
<p>We recommend:</p>
<ul>
<li>For Sample apps and concept exploration, just code the app.</li>
<li>For Prototype Development, just use the Execution Methodology when we hit problems.</li>
<li>For Individual Product Development, from the beginning, run the Analyzer automatically and informally incorporate it into our workflow when we see something important. From the beginning write tests but selectively where we would get a big impact.</li>
<li>For Team-based Product Development, add in the Process Methodology. Start becoming comprehensive with Testing.</li>
</ul>
<h1 id="hybrid-environments">Hybrid Environments</h1>
<p>We have seen that Xcode offers many automatic facilities for crash dump analysis and crash avoidance. However, these cannot get us all the answers we need. A complementary design oriented viewpoint is needed.</p>
<p>In this chapter, we shall look at a sample app <code>icdab_planets</code> that uses hybrid of programming languages and paradigms. It shows an example of why design insights must also be considered.</p>
<h2 id="program-structure">Program structure</h2>
<p>The <code>icdab_planets</code> sample app uses a mixture of C++, and Objective-C++. It relies on both STL data structures and traditional Objective-C data structures. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>The model layer of the app is written in C++. The controller layer of the app is written in Objective-C++.</p>
<p>The purpose of the app is to tell us how many Pluto sized planets would fit inside Jupiter.</p>
<h2 id="paradigms">Paradigms</h2>
<p>Recall earlier we demonstrated that:</p>
<ul>
<li>Objective-C allows messaging to nil objects</li>
<li>C crashes upon NULL dereference</li>
</ul>
<p>Here we show how the C++ Standard Template Library has a back-fill strategy.</p>
<p>In the STL map abstraction (a Hash Table) when we query for an entry that does not exist, the STL will insert a new entry in the table for the key being queried, and then return that entry instead of returning an error or returning a nil.</p>
<h2 id="the-problem">The Problem</h2>
<p>In our sample app, which crashes upon launch, we have an assert that gets triggered.</p>
<pre><code>double pluto_volume = pluto.get_volume();
assert(pluto_volume != 0.0);

double plutos_to_fill_jupiter
        =  jupiter.get_volume() / pluto_volume;</code></pre>
<p>Enabling code Analysis will not find any issue or warning.</p>
<p>The assert is in place to avoid a division by zero. The fact that it is triggered is good because we know where to start debugging the problem.</p>
<p>Pluto’s volume is 0.0 because the code</p>
<pre><code>planet pluto = planet::get_planet_with_name(&quot;Pluto&quot;);</code></pre>
<p>returns a planet with zero diameter.</p>
<p>From the file <code>planet_data.hpp</code> we see the API that we rely upon is:</p>
<pre><code>static planet get_planet_with_name(string name);</code></pre>
<p>Therefore, whatever name we pass in, we should always get a <code>planet</code> in response; never a NULL.</p>
<p>The problem is that this API has not been thought deeply about. It has just been put together as a thin wrapper around the underlying abstractions that do the work.</p>
<p>We have</p>
<pre><code>planet planet::get_planet_with_name(string name) {
    if (!database.loaded_data) {
        database.load_data();
    }
    return database.planets[name];
}</code></pre>
<p>At first glance, it might be that the database failed to load data properly. In fact, the database is missing the entry for Pluto due to it no longer being considered a planet:</p>
<pre><code>void planet_database::load_data() {
    planet planet_Mercury =
     planet(&quot;Mercury&quot;, 4878.0, 57.9 * millionKm);
    planets[&quot;Mercury&quot;] = planet_Mercury;

    planet planet_Venus =
     planet(&quot;Venus&quot;, 12104, 108.2 * millionKm);
    planets[&quot;Venus&quot;] = planet_Venus;

    planet planet_Earth =
     planet(&quot;Earth&quot;, 12756, 149.6 * millionKm);
    planets[&quot;Earth&quot;] = planet_Earth;

    planet planet_Mars =
     planet(&quot;Mars&quot;, 6792, 227.9 * millionKm);
    planets[&quot;Mars&quot;] = planet_Mars;

    planet planet_Jupiter =
     planet(&quot;Jupiter&quot;, 142984, 778 * millionKm);
    planets[&quot;Jupiter&quot;] = planet_Jupiter;

    planet planet_Saturn =
     planet(&quot;Saturn&quot;, 120536, 1427 * millionKm);
    planets[&quot;Saturn&quot;] = planet_Saturn;

    planet planet_Uranus =
     planet(&quot;Uranus&quot;, 51118, 2870 * millionKm);
    planets[&quot;Uranus&quot;] = planet_Uranus;

    planet planet_Neptune =
     planet(&quot;Neptune&quot;, 49532, 4497 * millionKm);
    planets[&quot;Neptune&quot;] = planet_Neptune;

//  No longer considered a planet but instead a dwarf planet
//  planet planet_Pluto =
//   planet(&quot;Pluto&quot;, 2370, 7375 * millionKm);
//  planets[&quot;Pluto&quot;] = planet_Pluto;

    loaded_data = true;
}</code></pre>
<p>The problem indirectly is because <code>database.planets[name]</code> discovered that there was no entry for Pluto so created one via the no-arg constructor as this is the behavior for STL map data structures.</p>
<pre><code>planet::planet() {
    this-&gt;name = &quot;&quot;;
    this-&gt;diameter = 0.0;
    this-&gt;distance_from_sun = 0.0;
}</code></pre>
<p>We see the constructor makes the diameter zero in this case.</p>
<h2 id="solutions">Solutions</h2>
<p>We see that the problem is not applying the paradigms of each framework and language properly and when we have a mixture of paradigms, those different assumptions get masked by each layer of abstraction.</p>
<p>In STL, we expect a <code>find</code> operation to be done, instead of the indexing operator. This allows the abstraction to flag the absence of the item being found.</p>
<p>In Objective-C we expect the lookup API to be a function which returns an index given the lookup name. In addition, the index would be <code>NSNotFound</code> when the operation failed.</p>
<p>In this code example, each layer of abstraction assumes the other side will re-map the edge case into an appropriate form.</p>
<h3 id="stl-solution">STL Solution</h3>
<p>We have a variant of the code which does things “properly” from an STL point of view. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> It is <code>icdab_planets_stl/icdab_planets</code>. On the consumer side, we have a helper method:</p>
<pre><code>- (BOOL)loadPlanetData {
    auto pluto_by_find = planet::find_planet_named(&quot;Pluto&quot;);
    auto jupiter_by_find = planet::find_planet_named(&quot;Jupiter&quot;);

    if (planet::isEnd(jupiter_by_find) ||
     planet::isEnd(pluto_by_find)) {
        return NO;
    }
    pluto = pluto_by_find-&gt;second;
    jupiter = jupiter_by_find-&gt;second;
    return YES;
}</code></pre>
<p>This is hard to parse if we are mainly an Objective-C programmer. If the project is mainly a C++ project, with a thin platform-specific layer, then perhaps that is acceptable. If the code base just leverages C++ code from elsewhere, then a better solution is to confine the paradigms to their own files and apply the facade design pattern to give a version of the API following Objective-C paradigms on the platform-specific code side.</p>
<p>Then Objective-C++ can be dispensed with in the ViewController code; it can be made an Objective-C file instead.</p>
<h3 id="facade-solution">Facade Solution</h3>
<p>Here is a facade implementation <code>icdab_planets_facade/icdab_planets</code> that overcomes the mixing of paradigms problem.</p>
<p>The facade is:</p>
<pre><code>@implementation PlanetModel

- (id)init {
    self = [super init];

    NSString *testSupportAddPluto =
     [[[NSProcessInfo processInfo] environment]
      objectForKey:@&quot;AddPluto&quot;];

    if ([testSupportAddPluto isEqualToString:@&quot;YES&quot;]) {
        planet::add_planet(
          planet(&quot;Pluto&quot;, 2370, 7375 * millionKm));
    }

    if (self) {
        _planetDict = [[NSMutableDictionary alloc] init];
        auto pluto_by_find =
         planet::find_planet_named(&quot;Pluto&quot;);
        auto jupiter_by_find =
         planet::find_planet_named(&quot;Jupiter&quot;);

        if (planet::isEnd(jupiter_by_find) ||
         planet::isEnd(pluto_by_find)) {
            return nil;
        }
        auto pluto = pluto_by_find-&gt;second;
        auto jupiter = jupiter_by_find-&gt;second;

        PlanetInfo *plutoPlanet = [[PlanetInfo alloc] init];
        plutoPlanet.diameter = pluto.get_diameter();
        plutoPlanet.distanceFromSun =
         pluto.get_distance_from_sun();
        plutoPlanet.volume = pluto.get_volume();
        assert (plutoPlanet.volume != 0.0);
        [_planetDict setObject:plutoPlanet forKey:@&quot;Pluto&quot;];

        PlanetInfo *jupiterPlanet = [[PlanetInfo alloc] init];
        jupiterPlanet.diameter = jupiter.get_diameter();
        jupiterPlanet.distanceFromSun =
         jupiter.get_distance_from_sun();
        jupiterPlanet.volume = jupiter.get_volume();
        assert (jupiterPlanet.volume != 0.0);
        [_planetDict setObject:jupiterPlanet forKey:@&quot;Jupiter&quot;];
    }

    return self;
}

@end</code></pre>
<p>The consumer then becomes a purely Objective-C class:</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.planetModel = [[PlanetModel alloc] init];

    if (self.planetModel == nil) {
        return;
    }

    double pluto_diameter =
     self.planetModel.planetDict[@&quot;Pluto&quot;].diameter;
    double jupiter_diameter =
     self.planetModel.planetDict[@&quot;Jupiter&quot;].diameter;
    double plutoVolume =
     self.planetModel.planetDict[@&quot;Pluto&quot;].volume;
    double jupiterVolume =
     self.planetModel.planetDict[@&quot;Jupiter&quot;].volume;
    double plutosInJupiter = jupiterVolume/plutoVolume;

    self.plutosInJupiterLabelOutlet.text =
    [NSString stringWithFormat:
    @&quot;Number of Plutos that fit inside Jupiter = %f&quot;,
     plutosInJupiter];

    self.jupiterLabelOutlet.text =
    [NSString stringWithFormat:
     @&quot;Diameter of Jupiter (km) = %f&quot;,
     jupiter_diameter];
    self.plutoLabelOutlet.text =
    [NSString stringWithFormat:
     @&quot;Diameter of Pluto (km) = %f&quot;,
     pluto_diameter];
}</code></pre>
<h2 id="lessons-learnt-1">Lessons Learnt</h2>
<p>The lesson here is that crashes can arise from special case handling. Since different languages and frameworks deal with special cases in their own idiomatic manner, it is safer to separate out our code and use a Facade if possible to keep each paradigm cleanly separated.</p>
<h1 id="symbolification">Symbolification</h1>
<p>This chapter explains crash dump symbolification. Symbolification is the process of mapping machine addresses into symbolic addresses meaningful to the programmer possessing the source code. Instead of seeing machine addresses, we want to see function names (plus any offset).</p>
<p>We use the <code>icdab_planets</code> sample app to demonstrate a crash. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>When dealing with real world crashes, a number of different entities are involved. These can be the end user device, the settings allowing the Crash Report to be sent back to Apple, the symbols held by Apple and our local development environment setup to mirror such a configuration.</p>
<p>In order to understand how things all fit together it is best to start from first principles and do the data conversion tasks ourselves so if we have to diagnose symbolification issues, we have some experience with the technologies at hand.</p>
<h2 id="build-process">Build Process</h2>
<p>Normally when we develop an app, we are deploying the Debug version of our app onto our device. When we are deploying our app for testers, app review, or app store release, we are deploying the Release version of our app.</p>
<p>By default for Release builds, debug information from the <code>.o</code> object files is placed into a separate directory structure. It is called <code>our_app_name.DSYM</code></p>
<p>The debugger can use debugging information when it sees a crash to help us understand where the program has gone wrong.</p>
<p>When a user sees our program crash, there is no debugger. Instead, a crash report is generated. This comprises the machine addresses where the problem was seen. Symbolification can convert these addresses into meaningful source code references.</p>
<p>In order for symbolification to occur, appropriate DSYM files must exist.</p>
<p>Xcode is by default setup so that only DSYM files are generated for Release builds, and not for Debug builds.</p>
<h2 id="build-settings">Build Settings</h2>
<p>From Xcode, in our build settings, searching for “Debug Information Format” we see the following settings:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Setting</th>
<th>Meaning</th>
<th>Usually set for target</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DWARF</td>
<td>Debugging information is in <code>.o</code> files only</td>
<td>Debug</td>
</tr>
<tr class="even">
<td>DWARF with dSYM File</td>
<td>As before but also collates the debug information into a DSYM file</td>
<td>Release</td>
</tr>
</tbody>
</table>
<p>In the default setup, if we run our debug binary on our device, launching it from the app icon itself then if it were to crash we would not have any symbols in the Crash Report. This confuses many people.</p>
<p>The problem is that the UUID of the binary and the DSYM need to match.</p>
<p>To avoid this problem, the sample app <code>icdab_planets</code> has been configured to have <code>DWARF with dSYM File</code> set for both debug and release targets. Then symbolification will work, because there will be a matching DSYM on our Mac.</p>
<h2 id="observing-a-local-crash">Observing a local crash</h2>
<p>The <code>icdab_planets</code> program is designed to crash upon launch due to an assertion.</p>
<p>If the <code>DWARF with dSYM File</code> setting had not been made, we would get a partially symbolicated crash.</p>
<p>The Crash Report, seen from <em>Window-&gt;Devices and Simulators-&gt;View Device Logs</em>, would look like this (truncated for ease of demonstration)</p>
<pre><code>Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000186388d88
 __pthread_kill + 8
1   libsystem_pthread.dylib         0x00000001862a11e8
 pthread_kill$VARIANT$mp + 136
2   libsystem_c.dylib               0x00000001861f4934 abort
 + 100
3   libsystem_c.dylib               0x00000001861f3d54 err +
 0
4   icdab_planets                   0x00000001045490f0
 0x104544000 + 20720
5   UIKitCore                       0x0000000189ff2750
 -[UIViewController
 _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 100
6   UIKitCore                       0x0000000189ff71e0
 -[UIViewController loadViewIfRequired] + 936</code></pre>
<p>However, with the setting in place, a crash would instead be reported as:</p>
<pre><code>Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000186388d88
 __pthread_kill + 8
1   libsystem_pthread.dylib         0x00000001862a11e8
 pthread_kill$VARIANT$mp + 136
2   libsystem_c.dylib               0x00000001861f4934 abort
 + 100
3   libsystem_c.dylib               0x00000001861f3d54 err +
 0
4   icdab_planets                   0x00000001048290f0
 -[PlanetViewController viewDidLoad] + 20720
 (PlanetViewController.mm:33)
5   UIKitCore                       0x0000000189ff2750
 -[UIViewController
 _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 100
6   UIKitCore                       0x0000000189ff71e0
 -[UIViewController loadViewIfRequired] + 936</code></pre>
<p>Lines 0, 1, 2, 5 are the same in both cases because our developer environment will have the symbols for the iOS release under test. In the second case, Xcode will look up the DSYM file to clarify line 4. It tells us this is line 33 in file PlanetViewController.mm. This is:</p>
<pre><code>assert(pluto_volume != 0.0);</code></pre>
<h2 id="dsym-structure">DSYM structure</h2>
<p>The DSYM file is strictly speaking a directory hierarchy:</p>
<pre><code>icdab_planets.app.dSYM
icdab_planets.app.dSYM/Contents
icdab_planets.app.dSYM/Contents/Resources
icdab_planets.app.dSYM/Contents/Resources/DWARF
icdab_planets.app.dSYM/Contents/Resources/DWARF/icdab_planets
icdab_planets.app.dSYM/Contents/Info.plist</code></pre>
<p>It is just the DWARF data normally put into the intermediate <code>.o</code> files but copied into a separate file.</p>
<p>From looking at our build log, we can see how the DSYM was generated. It is effectively just <code>dsymutil path_to_app_binary -o output_symbols_dir.dSYM</code></p>
<h2 id="manual-symbolification">Manual Symbolification</h2>
<p>In order to help us get comfortable with crash dump reports, we can demonstrate how the symbolification actually works. In the first crash dump, we want to understand:</p>
<pre><code>4   icdab_planets                       0x00000001045490f0
 0x104544000 + 20720</code></pre>
<p>The first number is the place where we were executing, the second number is the base address of the binary we were executing. The third number is the offset from the base address to reach the place of execution.</p>
<p>If we knew accurately the version of our code at the time of the crash, we can recompile our program, but with the DSYM setting switched on, and then get a DSYM file after the original crash. It should line up almost exactly.</p>
<p>The crash dump program tells us where the program was loaded, in memory, at the time of the problem. That tells us the master base offset from which all other address (TEXT) locations are relative to.</p>
<p>Running the lookup command <code>atos</code> symbolicates the line of interest:</p>
<pre><code># atos -arch arm64 -o
 icdab_planets.app.dSYM/Contents/Resources/DWARF/icdab_planets -l
 0x104544000 0x00000001045490f0
-[PlanetViewController viewDidLoad] (in icdab_planets)
 (PlanetViewController.mm:33)</code></pre>
<p>The Crash Reporter tool fundamentally just uses <code>atos</code> to symbolicate the Crash Report, as well as providing other system related information.</p>
<p>Symbolification is described further by an Apple Tech-note in case we want to get into it in more detail. <span class="citation" data-cites="tn2123">(“CrashReport Technote 2123” 2004)</span></p>
<h2 id="reverse-engineering-approach">Reverse Engineering Approach</h2>
<p>In the above example we have the source code, and symbols, for the crash dump so can do Symbolification.</p>
<p>Sometimes we may have included a third party binary framework in our project for which we do not have the source code. It is good practice for the vendor to supply symbol information for their framework to allow crash dump analysis. When symbol information is not available, it is still possible to make progress by applying some reverse engineering.</p>
<p>When working with third parties there is typically a much larger turnaround time for diagnostics and troubleshooting. We find that well written and specific bug reports can speed up things a lot. The following approach can help provide the kind of specific information needed.</p>
<p>We shall demonstrate our approach using the Hopper tool mentioned in the Tooling chapter.</p>
<p>Launching hopper, we choose <em>File-&gt;Read Executable to Disassemble</em>. The binary in our case is <code>examples/assert_crash_ios/icdab_planets</code></p>
<p>We need to “rebase” our disassembly so the addresses it shows mirror those of the program when it crashed. We choose <em>Modify-&gt;Change File Base Address</em>. As before, we supply <code>0x104544000</code>.</p>
<p>Now we can visit the code that crashed. The address <code>0x00000001045490f0</code> is actually the address the device would <em>return</em> to after performing the function call in the stack trace. Nevertheless, it puts us in the right part of the file. We choose <em>Navigate-&gt;Go To Address or Symbol</em> and supply <code>0x00000001045490f0</code></p>
<p>The overall view we see is</p>
<p><img src="screenshots/hopperAddressView.png" /></p>
<p>Zooming in on the code line, we have</p>
<p><img src="screenshots/hopperPlanetAbort.png" /></p>
<p>This indeed shows the return address for the assert method. Further up, we see the test for Pluto’s volume being non-zero. This is just a very basic Hopper example. We shall revisit Hopper later to demonstrate its most interesting feature - that of being able to generate pseudocode from assembly code. This lowers the mental load of comprehending crashes. Most developers rarely look at assembly code nowadays so this feature is worth the cost of the software itself!</p>
<p>Now at least for the current problem, we could formulate a bug report that said the code was crashing because Pluto’s volume was zero. That may be enough to unlock the problem from the framework vendor’s point of view.</p>
<p>In a more complex case, imagine we were using an image conversion library that was crashing.<br />
There can be many pixel formats for images. An <code>assert</code> might lead us to notice it was the particular format that was asserting. Therefore, we could just try a different pixel format.</p>
<p>Another example would be a security library. Security code often gives back generic error codes, not specific fault codes to allow for future code enhancement and avoid leaking internal details (a security risk). A crash dump in a security library might point out exactly the kind of security issue, and help us correct some data structure passed into the library much earlier on.</p>
<h1 id="system-diagnostics">System Diagnostics</h1>
<p>Crash Reports are just one part of a much bigger diagnostic reporting story.</p>
<p>Ordinarily as application developers, we don’t need to look much further. However, if our problems are potentially triggered by an unexplained series of events or a more complex system interaction with hardware or Apple provided system services, then not only do we need to look at our Crash Reports, we need to study the system diagnostics.</p>
<h2 id="extracting-system-diagnostic-information">Extracting System Diagnostic Information</h2>
<p>When understanding the environment that gave rise to our crash, we may need to install Mobile Device Management Profiles (to switch on certain debugging subsystems), or create virtual network interfaces (for network sniffing). Apple provides a great web page covering each scenario. <span class="citation" data-cites="apple-sysdiag">(“Diagnostic Profiles and Logs” 2018)</span></p>
<p>On iOS, the basic idea is that we install a profile, which alters our device to produce more logging, and then we reproduce the crash (or get the customer to do that). Then we press a special key sequence on the device (for example, both volume buttons and the side button). The system vibrates briefly to indicate it is running a program, <code>sysdiagnose</code>, which extracts many log files. This can take 10 minutes to process, and produces a large file (compressed <code>tar</code> file).</p>
<p>Then we share our local sysdiagnose file with our Mac. We go into menu <code>Settings &gt; Privacy &gt; Analytics and Improvements &gt; Analytics Data</code>. Scroll down looking for a file beginning with <code>sysdiagnose_YEAR.MONTH.DAY_*</code>.</p>
<figure>
<img src="screenshots/sysdiagnose_example.jpeg" alt="An example sysdiagnose log file" /><figcaption aria-hidden="true">An example sysdiagnose log file</figcaption>
</figure>
<p>When this file is selected we get a blank screen but that is not a problem. We click on the <em>Share</em> icon in the top toolbar, and select an appropriate sharing destination.</p>
<figure>
<img src="screenshots/sysdiagnose_share.jpeg" alt="Sharing the sysdiagnose log" /><figcaption aria-hidden="true">Sharing the sysdiagnose log</figcaption>
</figure>
<p>Inside this archive file are many system and subsystem logs, so we can see whenever crashes occur, the context that gave rise to them.</p>
<p>An equivalent approach is available on macOS as well.</p>
<h2 id="resource-profile-logs">Resource Profile logs</h2>
<p>Alongside the <code>sysdiagnose</code> logs we see that our device will have many other files. These give insights into the general health of the system.</p>
<h3 id="cpu-resource-logs">CPU Resource logs</h3>
<p><code>SUBSYSTEM.cpu_resource-YEAR.MONTH.DAY_*.ips.synced</code> covers <em>CPU Resource</em> profile logs.</p>
<p>Here is an example from <code>apfs_defragd</code>, the APFS filesystem defragmenter.</p>
<pre><code>{&quot;share_with_app_devs&quot;:1,&quot;app_version&quot;:&quot;&quot;,&quot;bug_type&quot;:&quot;202&quot;,&quot;times
tamp&quot;:&quot;2020-10-19 23:49:02.00 +0100&quot;,&quot;os_version&quot;:&quot;iPhone OS 14.2
 (18B5072f)&quot;,&quot;slice_uuid&quot;:&quot;047D42ED-E41C-38AE-81BE-E4ABCF05A703&quot;,
&quot;is_first_party&quot;:1,&quot;build_version&quot;:&quot;&quot;,&quot;incident_id&quot;:&quot;05D98B49-C8B
1-4F18-B494-491D76B2AA3C&quot;,&quot;app_name&quot;:&quot;apfs_defragd&quot;,&quot;name&quot;:&quot;apfs_
defragd&quot;}
Date/Time:        2020-10-19 23:46:29.268 +0100
End time:         2020-10-19 23:48:59.680 +0100
OS Version:       iPhone OS 14.2 (Build 18B5072f)
Architecture:     arm64e
Report Version:   32
Incident Identifier: 05D98B49-C8B1-4F18-B494-491D76B2AA3C
Share With Devs:  Yes

Data Source:      Microstackshots
Shared Cache:     D949F5BB-14F3-3223-9E0F-EB9B0E5D53E8 slid base
 address 0x191410000, slide 0x11410000

Command:          apfs_defragd
Path:            
 /System/Library/Filesystems/apfs.fs/apfs_defragd
Version:          ??? (???)
Parent:           UNKNOWN [1]
PID:              7877

Event:            cpu usage
Action taken:     none
CPU:              90 seconds cpu time over 150 seconds (60% cpu
 average), exceeding limit of 50% cpu over 180 seconds
CPU limit:        90s
Limit duration:   180s
CPU used:         90s
CPU duration:     150s
Duration:         150.41s
Duration Sampled: 119.32s
Steps:            23

Hardware model:   iPhone12,1
Active cpus:      6

Heaviest stack for the target process:
  18  ??? (libsystem_pthread.dylib + 14340) [0x1db258804]
  18  ??? (libdispatch.dylib + 89464) [0x19146ad78]
  18  ??? (libdispatch.dylib + 48220) [0x191460c5c]
  18  ??? (libdispatch.dylib + 45324) [0x19146010c]
  18  ??? (libdispatch.dylib + 15792) [0x191458db0]
  18  ??? (libdispatch.dylib + 8780) [0x19145724c]
  18  ??? (apfs_defragd + 18536) [0x104f30868]
  18  ??? (apfs_defragd + 177336) [0x104f574b8]
  18  ??? (apfs_defragd + 176680) [0x104f57228]
  18  ??? (apfs_defragd + 19380) [0x104f30bb4]
  16  ??? (apfs_defragd + 10128) [0x104f2e790]
  16  ??? (AppleFSCompression + 18424) [0x1c8e0a7f8]
  16  ??? (AppleFSCompression + 43828) [0x1c8e10b34]
  6   ??? (AppleFSCompression + 44780) [0x1c8e10eec]
  2   ??? (libz.1.dylib + 47196) [0x1dae8885c]


Powerstats for:   apfs_defragd [7877]
UUID:             047D42ED-E41C-38AE-81BE-E4ABCF05A703
Path:            
 /System/Library/Filesystems/apfs.fs/apfs_defragd
Architecture:     arm64e
Parent:           UNKNOWN [1]
UID:              0
Sudden Term:      Tracked (allows idle exit)
Footprint:        120.84 MB
Start time:       2020-10-19 23:47:00.334 +0100
End time:         2020-10-19 23:48:58.707 +0100
Num samples:      18 (78%)
Primary state:    10 samples Non-Frontmost App, Non-Suppressed,
 Kernel mode, Effective Thread QoS Background, Requested Thread
 QoS Background, Override Thread QoS Unspecified
User Activity:    18 samples Idle, 0 samples Active
Power Source:     0 samples on Battery, 18 samples on AC
  18  ??? (libsystem_pthread.dylib + 14340) [0x1db258804]
    18  ??? (libdispatch.dylib + 89464) [0x19146ad78]
.
.

  Binary Images:
           0x104f2c000 -                ???  apfs_defragd        
     &lt;047D42ED-E41C-38AE-81BE-E4ABCF05A703&gt;
 /System/Library/Filesystems/apfs.fs/apfs_defragd
.
.

Powerstats for:   PerfPowerServicesExtended
UUID:             AC943755-DBF7-306D-8D54-5F1FA7D45C1A
Path:             /usr/bin/PerfPowerServicesExtended
Architecture:     arm64e
Start time:       2020-10-19 23:47:41.119 +0100
End time:         2020-10-19 23:48:19.856 +0100
Num samples:      3 (13%)
Primary state:    2 samples Non-Frontmost App, Non-Suppressed,
 User mode, Effective Thread QoS Background, Requested Thread QoS
 Background, Override Thread QoS Unspecified
User Activity:    3 samples Idle, 0 samples Active
Power Source:     0 samples on Battery, 3 samples on AC
  3  ??? (libsystem_pthread.dylib + 14340) [0x1db258804]
    3  ??? (libdispatch.dylib + 89464) [0x19146ad78]
.
.

  Binary Images:
           0x104e78000 -                ???
 PerfPowerServicesExtended &lt;AC943755-DBF7-306D-8D54-5F1FA7D45C1A&gt;
  /usr/bin/PerfPowerServicesExtended
           0x191455000 -        0x191497fff  libdispatch.dylib   
      &lt;187D8E52-371D-33F2-B0D4-C6D154917885&gt;
 /usr/lib/system/libdispatch.dylib
.
.</code></pre>
<h3 id="disk-utilization-logs">Disk Utilization Logs</h3>
<p><code>SUBSYSTEM.diskwrites_resource-YEAR.MONTH.DAY_*.ips.synced</code> covers <em>Disk Utilization</em> profile logs.</p>
<p>Here is an example from <code>assetd</code>, the Asset Manager.</p>
<pre><code>{&quot;share_with_app_devs&quot;:1,&quot;app_version&quot;:&quot;&quot;,&quot;bug_type&quot;:&quot;145&quot;,&quot;times
tamp&quot;:&quot;2020-10-18 02:55:57.00 +0100&quot;,&quot;os_version&quot;:&quot;iPhone OS 14.2
 (18B5072f)&quot;,&quot;slice_uuid&quot;:&quot;6192DA47-C99E-33F4-8FC5-CF071E4EE26B&quot;,
&quot;is_first_party&quot;:1,&quot;build_version&quot;:&quot;&quot;,&quot;incident_id&quot;:&quot;BB4403D7-A0C
F-4C50-AEA6-EFF26FACF690&quot;,&quot;app_name&quot;:&quot;assetsd&quot;,&quot;name&quot;:&quot;assetsd&quot;}
Date/Time:        2020-10-17 23:26:36.891 +0100
End time:         2020-10-18 02:55:56.835 +0100
OS Version:       iPhone OS 14.2 (Build 18B5072f)
Architecture:     arm64e
Report Version:   32
Incident Identifier: BB4403D7-A0CF-4C50-AEA6-EFF26FACF690
Share With Devs:  Yes

Data Source:      Microstackshots
Shared Cache:     D949F5BB-14F3-3223-9E0F-EB9B0E5D53E8 slid base
 address 0x191410000, slide 0x11410000

Command:          assetsd
Path:            
 /System/Library/Frameworks/AssetsLibrary.framework/Support/asset
sd
Version:          ??? (???)
Parent:           launchd [1]
PID:              124

Event:            disk writes
Action taken:     none
Writes:           1073.75 MB of file backed memory dirtied over
 12560 seconds (85.49 KB per second average), exceeding limit of
 12.43 KB per second over 86400 seconds
Writes limit:     1073.74 MB
Limit duration:   86400s
Writes caused:    1073.75 MB
Writes duration:  12560s
Duration:         12559.94s
Duration Sampled: 12460.16s
Steps:            81 ( (10.49 MB/step))

Hardware model:   iPhone12,1
Active cpus:      6


Heaviest stack for the target process:
  6  ??? (libsystem_pthread.dylib + 14340) [0x1db258804]
  6  ??? (libdispatch.dylib + 89464) [0x19146ad78]
  6  ??? (libdispatch.dylib + 48220) [0x191460c5c]
  6  ??? (libdispatch.dylib + 45324) [0x19146010c]
  6  ??? (libdispatch.dylib + 15792) [0x191458db0]
  6  ??? (libdispatch.dylib + 8780) [0x19145724c]
  6  ??? (AssetsLibraryServices + 240248) [0x1a3090a78]
  6  ??? (PhotoLibraryServices + 5982616) [0x1a2eda998]
  6  ??? (PhotoLibraryServices + 5903404) [0x1a2ec742c]
  5  ??? (libsqlite3.dylib + 272472) [0x1ab453858]
  5  ??? (libsqlite3.dylib + 335252) [0x1ab462d94]
  5  ??? (libsqlite3.dylib + 147268) [0x1ab434f44]
  5  ??? (libsqlite3.dylib + 365168) [0x1ab46a270]
  5  ??? (libsqlite3.dylib + 450844) [0x1ab47f11c]
  5  ??? (libsqlite3.dylib + 778840) [0x1ab4cf258]
  5  ??? (libsqlite3.dylib + 452760) [0x1ab47f898]
  5  ??? (libsystem_kernel.dylib + 172372) [0x1becf8154]


Powerstats for:   assetsd [124]
UUID:             6192DA47-C99E-33F4-8FC5-CF071E4EE26B
Path:            
 /System/Library/Frameworks/AssetsLibrary.framework/Support/asset
sd
Architecture:     arm64e
Parent:           launchd [1]
UID:              501
Sudden Term:      Tracked (allows idle exit)
Footprint:        19.98 MB
Start time:       2020-10-18 02:54:02.699 +0100
End time:         2020-10-18 02:55:24.063 +0100
Num samples:      6 (7%)
Primary state:    6 samples Non-Frontmost App, Non-Suppressed,
 Kernel mode, Effective Thread QoS Background, Requested Thread
 QoS Utility, Override Thread QoS Unspecified
User Activity:    6 samples Idle, 0 samples Active
Power Source:     0 samples on Battery, 6 samples on AC
  6  ??? (libsystem_pthread.dylib + 14340) [0x1db258804]
.
.

  Binary Images:
           0x104bf4000 -                ???  assetsd             
    &lt;6192DA47-C99E-33F4-8FC5-CF071E4EE26B&gt;
 /System/Library/Frameworks/AssetsLibrary.framework/Support/asset
sd
           0x191455000 -        0x191497fff  libdispatch.dylib   
    &lt;187D8E52-371D-33F2-B0D4-C6D154917885&gt;
 /usr/lib/system/libdispatch.dylib
.
.</code></pre>
<h3 id="jetsam-reports">Jetsam reports</h3>
<p>The term “Jetsam” is originally a Nautical term, where a ship would throw off unwanted items into the sea, to lighten the ship. In iOS, Jetsam is the system that ejects applications from memory in order to service the needs of the current foremost app.</p>
<p>Aggressive memory management is a hallmark of iOS as compared to macOS which has very liberal limits on memory usage. Mobile Devices have traditionally been memory constrained devices. However, as Mobile Devices become more capable, in particular iPad devices, the difference is reduced. In modern times, it is the Apple Watch that is considered a memory constrained device. Nevertheless, the strict memory management system of Jetsam serves us well to keep the user experience optimal for a given amount of RAM.</p>
<p>It is best to think of Jetsam as a normal behavior, and being ejected from memory is not necessarily a fault of the design of our app. We could have been running in the background consuming a modest amount of memory when the user used the Camera app and did a burst of photo taking and image effects that drove up memory usage.</p>
<p>If we get ejected from memory frequently, we must consider whether we are using too much memory in the background; we should aim for about 50 MB or less. We should also write our app to save context, destroy caches, and save state so it can then be resumed from the saved state. Then we should hook in such functionality whenever we get a message from the system indicating memory pressure, such as the <code>applicationDidReceiveMemoryWarning:</code> callback in our <code>AppDelegate</code>.</p>
<p>Apple document the various reasons that a Jetsam event can occur, and memory management techniques to avoid them. <span class="citation" data-cites="jetsamreport">(“Identifying High-Memory Use with Jetsam Event Reports” 2020)</span></p>
<p>The actual limits are not documented, but generally apps can have more background memory use than app extensions. App extensions come in various types of extension, each with their own limits. For example, a photo editing Application Extension will have a large limit due to it generally being a heavy-weight image processing program.</p>
<p>The first thing to look for in a Jetsam report is the <em>reason</em> field.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Jetsam Reason</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>per-process-limit</code></td>
<td>The resident memory limit was reached. The limit varies depending type of the app, or app extension.</td>
</tr>
<tr class="even">
<td><code>vm-pageshortage</code></td>
<td>The kernel wants to give clean pages to another process but has run out of them, so killed our process.</td>
</tr>
<tr class="odd">
<td><code>vnode-limit</code></td>
<td>The kernel has run out of vnodes (a generalization of UNIX files) so is killing our process to free some more vnodes.</td>
</tr>
<tr class="even">
<td><code>highwater</code></td>
<td>Too much physical memory used by process.</td>
</tr>
<tr class="odd">
<td><code>fc-thrashing</code></td>
<td>Too much random access to memory mapped files causing fragmentation/thrashing of the file cache.</td>
</tr>
<tr class="even">
<td><code>jettisoned</code></td>
<td>Some other reason for the Jetsam.</td>
</tr>
</tbody>
</table>
<p>In practice, we have not seen <code>fc-thrashing</code> or <code>jettisoned</code> but they remain a possibility.</p>
<p>Jetsam reports are named <code>JetsamEvent-YEAR.MONTH.DAY_*.ips.synced</code>.</p>
<p>Here is an example report showing a “highwater” event for <code>wifianalyticsd</code>:</p>
<pre><code>{&quot;bug_type&quot;:&quot;298&quot;,&quot;timestamp&quot;:&quot;2020-10-15 17:29:58.79
 +0100&quot;,&quot;os_version&quot;:&quot;iPhone OS 14.2
 (18B5061e)&quot;,&quot;incident_id&quot;:&quot;B04A36B1-19EC-4895-B203-6AE21BE52B02&quot;
}
{
  &quot;crashReporterKey&quot; :
 &quot;d3e622273dd1296e8599964c99f70e07d25c8ddc&quot;,
  &quot;kernel&quot; : &quot;Darwin Kernel Version 20.1.0: Mon Sep 21 00:09:01
 PDT 2020; root:xnu-7195.40.113.0.2~22\/RELEASE_ARM64_T8030&quot;,
  &quot;product&quot; : &quot;iPhone12,1&quot;,
  &quot;incident&quot; : &quot;B04A36B1-19EC-4895-B203-6AE21BE52B02&quot;,
  &quot;date&quot; : &quot;2020-10-15 17:29:58.79 +0100&quot;,
  &quot;build&quot; : &quot;iPhone OS 14.2 (18B5061e)&quot;,
  &quot;timeDelta&quot; : 7,
  &quot;memoryStatus&quot; : {
  &quot;compressorSize&quot; : 96635,
  &quot;compressions&quot; : 3009015,
  &quot;decompressions&quot; : 2533158,
  &quot;zoneMapCap&quot; : 1472872448,
  &quot;largestZone&quot; : &quot;APFS_4K_OBJS&quot;,
  &quot;largestZoneSize&quot; : 41271296,
  &quot;pageSize&quot; : 16384,
  &quot;uncompressed&quot; : 257255,
  &quot;zoneMapSize&quot; : 193200128,
  &quot;memoryPages&quot; : {
    &quot;active&quot; : 45459,
    &quot;throttled&quot; : 0,
    &quot;fileBacked&quot; : 34023,
    &quot;wired&quot; : 49236,
    &quot;anonymous&quot; : 55900,
    &quot;purgeable&quot; : 12,
    &quot;inactive&quot; : 40671,
    &quot;free&quot; : 5142,
    &quot;speculative&quot; : 3793
  }
},
  &quot;largestProcess&quot; : &quot;AppStore&quot;,
  &quot;genCounter&quot; : 1,
  &quot;processes&quot; : [
  {
    &quot;uuid&quot; : &quot;7607487f-d2b1-3251-a2a6-562c8c4be18c&quot;,
    &quot;states&quot; : [
      &quot;daemon&quot;,
      &quot;idle&quot;
    ],
    &quot;age&quot; : 3724485992920,
    &quot;purgeable&quot; : 0,
    &quot;fds&quot; : 25,
    &quot;coalition&quot; : 68,
    &quot;rpages&quot; : 229,
    &quot;priority&quot; : 0,
    &quot;physicalPages&quot; : {
      &quot;internal&quot; : [
        6,
        183
      ]
    },
    &quot;pid&quot; : 350,
    &quot;cpuTime&quot; : 0.066796999999999995,
    &quot;name&quot; : &quot;SBRendererService&quot;,
    &quot;lifetimeMax&quot; : 976
  },
.
.
{
  &quot;uuid&quot; : &quot;f71f1e2b-a7ca-332d-bf87-42193c153ef8&quot;,
  &quot;states&quot; : [
    &quot;daemon&quot;,
    &quot;idle&quot;
  ],
  &quot;lifetimeMax&quot; : 385,
  &quot;killDelta&quot; : 13595,
  &quot;age&quot; : 94337735133,
  &quot;purgeable&quot; : 0,
  &quot;fds&quot; : 50,
  &quot;genCount&quot; : 0,
  &quot;coalition&quot; : 320,
  &quot;rpages&quot; : 382,
  &quot;priority&quot; : 1,
  &quot;reason&quot; : &quot;highwater&quot;,
  &quot;physicalPages&quot; : {
    &quot;internal&quot; : [
      327,
      41
    ]
  },
  &quot;pid&quot; : 2527,
  &quot;idleDelta&quot; : 41601646,
  &quot;name&quot; : &quot;wifianalyticsd&quot;,
  &quot;cpuTime&quot; : 0.634077
},
.
.</code></pre>
<h1 id="the-crash-report">The Crash Report</h1>
<p>In this chapter, we get into the details of what comprises a Crash Report. Our main focus is the iOS Crash Report. We also cover the macOS Crash Report, which carries a slightly different structure but serves the same purpose.</p>
<p>Note, it is possible for an app to install crash handlers from third parties, either to get enhanced crash reporting diagnostics, or to link application crashes to a web-based service for managing Crash Reports across a potentially large population of users. In this chapter we assume the app has not done this, and therefore the Apple CrashReport tool comes into play.</p>
<p>Furthermore, there are other variant scenarios where we can crash. It could be a macOS Intel X86 program running translated on an Apple Silicon Mac, or it could be a iOS ARM app running on an Apple Silicon Mac. Those subtleties are separated out into the chapter covering Apple Silicon.</p>
<p>When a crash occurs the <code>ReportCrash</code> program extracts information from the crashing process from the Operating System. The result is a text file with a <code>.crash</code> extension.</p>
<p>When symbol information is available, Xcode will symbolicate the Crash Report to show symbolic names instead of machine addresses. This improves the comprehensibility of the report.</p>
<p>Apple has produced a detailed document explaining the anatomy of a crash dump. <span class="citation" data-cites="tn2151">(“Apple Crash Dump Technote 2151” 2018)</span></p>
<h2 id="guided-tour-of-an-ios-crash-report">Guided tour of an iOS Crash Report</h2>
<p>Here we go through each section of an iOS Crash Report and explain the fields. <span class="citation" data-cites="tn2151">(“Apple Crash Dump Technote 2151” 2018)</span></p>
<p>tvOS and watchOS may be just considered subsets of iOS for our purposes and have similar Crash Reports.</p>
<p>Note here we use the term “iOS Crash Report” to mean a Crash Report that came from a physical target device. After a crash, apps are often debugged on the Simulator. The exception code may be different in that case because the Simulator uses a different methodology to cause the app to stop under the debugger.</p>
<h3 id="ios-crash-report-header-section">iOS Crash Report Header Section</h3>
<p>A Crash Report starts with the following header:</p>
<pre><code>Incident Identifier: 692E5696-6994-4FB3-B42D-C9317D956EE7
CrashReporter Key:   1f2cdb7448d354584634e8576c1e5257634fc0cd
Hardware Model:      iPhone12,1
Process:             get [1737]
Path:               
 /private/var/containers/Bundle/Application/2BF678BB-7CC6-4CAC-BF
49-0298B611F1BA/get.app/get
Identifier:         
 com.soul.merge.cat.cute.simulator.adventure.get
Version:             44 (1.4.4)
AppStoreTools:       11C29
AppVariant:          1:iPhone12,1:13
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:          
 com.soul.merge.cat.cute.simulator.adventure.get [757]</code></pre>
<p>These items are explained by the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Entry</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Incident Identifier</td>
<td>Unique report number of crash</td>
</tr>
<tr class="even">
<td>Beta Identifier</td>
<td>Unique identifier scoped to the software author and client device in TestFlight builds</td>
</tr>
<tr class="odd">
<td>CrashReporter Key</td>
<td>Unique identifier for the device that crashed</td>
</tr>
<tr class="even">
<td>Hardware Model</td>
<td>Apple Hardware Model <span class="citation" data-cites="ios-devices">(“List of iOS Devices” 2018)</span></td>
</tr>
<tr class="odd">
<td>Process</td>
<td>Process name (number) that crashed</td>
</tr>
<tr class="even">
<td>Path</td>
<td>Full pathname of crashing program on the device file system</td>
</tr>
<tr class="odd">
<td>Identifier</td>
<td>Bundle identifier from <code>Info.plist</code></td>
</tr>
<tr class="even">
<td>Version</td>
<td>CFBundleVersion; also CFBundleVersionString in brackets</td>
</tr>
<tr class="odd">
<td>AppStoreTools</td>
<td>The version of Xcode the app author used to build the app for when <em>bitcode</em> was enabled</td>
</tr>
<tr class="even">
<td>AppVariant</td>
<td>The variant of the app produced by <em>app thinning</em> by the App Store before it was deployed to the device</td>
</tr>
<tr class="odd">
<td>Beta</td>
<td>YES if the crash was TestFlight beta software otherwise absent</td>
</tr>
<tr class="even">
<td>Code Type</td>
<td>Target architecture of the process that crashed</td>
</tr>
<tr class="odd">
<td>Role</td>
<td>The process <code>task_role</code>. An indicator if we were in the background, foreground, or was a console app. Mainly affects the scheduling priority of the process.</td>
</tr>
<tr class="even">
<td>Parent Process</td>
<td>Parent of the crashing process. <code>launchd</code> is a process launcher and is often the parent.</td>
</tr>
<tr class="odd">
<td>Coalition</td>
<td>Tasks are grouped into coalitions so they can pool together their consumption of resources <span class="citation" data-cites="resource-management">(“Resource Management” 2015)</span></td>
</tr>
</tbody>
</table>
<p>The <code>AppVariant</code> field, when present, is explained by <em>internalVersion</em>:<em>nameOfVariantClass</em>:<em>osVersionVariant</em>.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>internalVersion</td>
<td>Private field used in the Apple implementation</td>
</tr>
<tr class="even">
<td>nameOfVariantClass</td>
<td>Usually a product name or something that characterizes a type of hardware device class</td>
</tr>
<tr class="odd">
<td>osVersionVariant</td>
<td>Variant introduced from a given version of the OS</td>
</tr>
</tbody>
</table>
<p>The first thing to look at is the version. Typically, if we are a small team or an individual, we will not have the resources to diagnose crashes in older versions of our app, so the first thing might be to get the customer to install the latest version.</p>
<p>If we have many crashes then a pattern may emerge. It could be one customer (common CrashReporter key seen), or many customers (different CrashReporter keys seen). This may affect how we rank the priority of the crash.</p>
<p>The hardware model could be interesting. Is it iPad only devices, or iPhone only, or both? Maybe our code has less testing, or unique code paths, for a given platform. The hardware model might indicate an older device which we have not tested on.</p>
<p>Whether the app crashed in the Foreground or Background (the Role) is interesting because most applications are not tested whilst they are in the background. For example, we might receive a phone call, or have task switched between apps.</p>
<p>The Code Type (target architecture) is now mostly 64-bit ARM. However, we might see ARM being reported - the original 32-bit ARM.</p>
<h3 id="ios-crash-report-date-and-version-section">iOS Crash Report Date and Version Section</h3>
<p>A Crash Report will continue with date and version information:</p>
<pre><code>Date/Time:           2018-07-16 10:15:31.4746 +0100
Launch Time:         2018-07-16 10:15:31.3763 +0100
OS Version:          iPhone OS 11.3 (15E216)
Baseband Version:    n/a
Report Version:      104</code></pre>
<p>These items are explained by the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Entry</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Date/Time</td>
<td>When the crash occurred</td>
</tr>
<tr class="even">
<td>Launch Time</td>
<td>When the process was originally launched before crashing</td>
</tr>
<tr class="odd">
<td>OS Version</td>
<td>Operating System Version (Build number). <span class="citation" data-cites="ios-versions">(“IOS Version History” 2018)</span></td>
</tr>
<tr class="even">
<td>Release Type</td>
<td><em>Beta</em> when the OS was Beta software</td>
</tr>
<tr class="odd">
<td>Baseband Version</td>
<td>Version number of the firmware of the cellular modem (used for phone calls) or <code>n/a</code> if the device has no cellular modem (most iPads, iPod Touch, etc.)</td>
</tr>
<tr class="even">
<td>Report Version</td>
<td>The version of ReportCrash used to produce the report</td>
</tr>
</tbody>
</table>
<p>The first thing to check is the OS Version. Is it newer or older than we’ve tested? Is it a beta version of the operating system?</p>
<p>The next thing to check is the difference between the launch time and the time of the crash. Did the app crash immediately or after a long time? Early start crashes can sometimes be a packaging and deployment problem. We shall visit some techniques to tackle those later on.</p>
<p>Is the date a sensible value? Sometimes a device is set back or forwards in time, perhaps to trigger date checks on security certificates or license keys. Make sure the date is a realistic looking one.</p>
<p>Normally the baseband version is not interesting. The presence of the baseband means we could be interrupted by a phone call (of course there is VOIP calling as well in any case). iPad software is generally written to assume we’re not going to get a phone call but iPads can be purchased with a cellular modem option.</p>
<h3 id="ios-crash-report-exception-section">iOS Crash Report Exception Section</h3>
<p>A Crash Report will next have an exception information section:</p>
<pre><code>Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Triggered by Thread:  0</code></pre>
<p>or it may provide a more detailed exception information section:</p>
<pre><code>Exception Type:  EXC_CRASH (SIGKILL)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Termination Reason: Namespace &lt;0xF&gt;, Code 0xdead10cc
Triggered by Thread:  0</code></pre>
<p>What has happened is that the MachOS kernel has raised an Operating System Exception on the problematic process, which terminates the process. The ReportCrash program then retrieves from the OS the details of such an exception.</p>
<p>These items are explained by the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Entry</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exception Type</td>
<td>The type of exception in Mach OS. <span class="citation" data-cites="exception-types">(“Mach Exception Types” 2018)</span></td>
</tr>
<tr class="even">
<td>Exception Codes</td>
<td>These codes encode the kind of exception, such as trying to access an invalid address, and supporting information. <span class="citation" data-cites="exception-types">(“Mach Exception Types” 2018)</span></td>
</tr>
<tr class="odd">
<td>Exception Note</td>
<td>Either this says <code>SIMULATED (this is NOT a crash)</code> because the process was killed by the watchdog timer, or it says <code>EXC_CORPSE_NOTIFY</code> because the process crashed</td>
</tr>
<tr class="even">
<td>Termination Reason</td>
<td>Optionally present, this gives a Namespace (number or subsystem name) and a magic number Code (normally a hex number that looks like a English word). See below for details on each Termination Code.</td>
</tr>
<tr class="odd">
<td>Triggered by Thread</td>
<td>The thread in the process that caused the crash</td>
</tr>
</tbody>
</table>
<p>In this section, the most important item is the exception type.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Exception Type</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>EXC_CRASH (SIGABRT)</code></td>
<td>Our program raised a programming language exception such as a failed assertion and this caused the OS to Abort our app</td>
</tr>
<tr class="even">
<td><code>EXC_CRASH (SIGQUIT)</code></td>
<td>A process received a quit signal from another process that is managing it. Typically, this means a Keyboard extension took too long or used up too much memory. App extensions are given only limited amounts of memory.</td>
</tr>
<tr class="odd">
<td><code>EXC_CRASH (SIGKILL)</code></td>
<td>The system killed our app (or app extension), usually because some resource limit had been reached. The Termination Reason needs to be looked at to work out what policy violation was the reason for termination.</td>
</tr>
<tr class="even">
<td><code>EXC_BAD_ACCESS (SIGSEGV)</code> or <code>EXC_BAD_ACCESS (SIGBUS)</code></td>
<td>Our program most likely tried to access a bad memory location or the address was good but we did not have the privilege to access it. The memory might have been deallocated due to memory pressure. The pointer to memory we used might have become changed and thus become invalid due to Pointer Authentication</td>
</tr>
<tr class="odd">
<td><code>EXC_BREAKPOINT (SIGTRAP)</code></td>
<td>This is due to an <code>NSException</code> being raised (possibly by a library on our behalf) or <code>_NSLockError</code> or <code>objc_exception_throw</code> being called. For example, this can be the Swift environment detecting an anomaly such as force unwrapping a nil optional</td>
</tr>
<tr class="even">
<td><code>EXC_BAD_INSTRUCTION (SIGILL)</code></td>
<td>This is when the program code itself is faulty, not the memory it might be accessing. This should be rare on iOS devices; perhaps a compiler or optimizer bug, or faulty hand written assembly code. On Simulator, it is a different story as using an undefined opcode is a technique used by the Swift runtime to stop on access to zombie objects (deallocated objects). Furthermore, for Apple Silicon Macs running an app in Rosetta Translation mode, this may suggest an unsupported instruction.</td>
</tr>
<tr class="odd">
<td><code>EXC_GUARD</code></td>
<td>This is when the program closed a file descriptor that was guarded. An example is the SQLite database used by the system.</td>
</tr>
<tr class="even">
<td><code>EXC_RESOURCE</code></td>
<td>This is when the system killed the app because too much of a resource, such as CPU usage, was consumed. In more recent crash reports, this information is replaced with an Event information section.</td>
</tr>
</tbody>
</table>
<p>When Termination Reason is present, we can look up the Code as follows:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Termination Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0xdead10cc</code></td>
<td>We held a file lock or sqlite database lock before suspending. We should release locks before suspending.</td>
</tr>
<tr class="even">
<td><code>0xbaaaaaad</code></td>
<td>A stackshot was done of the entire system via the side and both volume buttons. See earlier section on System Diagnostics</td>
</tr>
<tr class="odd">
<td><code>0xbad22222</code></td>
<td>VOIP was terminated as it resumed too frequently. Also seen with code using networking whilst in the background. If our TCP connection is woken up too many times (say 15 wakes in 300 seconds) we get this crash.</td>
</tr>
<tr class="even">
<td><code>0x8badf00d</code></td>
<td>Our app took too long to perform a state change (starting up, shutting down, handling system message, etc.). The watchdog timer noticed the policy violation and caused the termination. The most common culprit is doing synchronous networking on the main thread.</td>
</tr>
<tr class="odd">
<td><code>0xc00010ff</code></td>
<td>The system detected a thermal event and killed off our app. If it’s just on one device it could be a hardware issue, not a software problem in our app. If it happens on other devices, check our app’s power usage using Instruments.</td>
</tr>
<tr class="even">
<td><code>0x2bad45ec</code></td>
<td>There was a security violation. If the Termination Description says, “Process detected doing insecure drawing while in secure mode” it means our app tried to write to the screen when it was not allowed because for example the Lock Screen was being shown.</td>
</tr>
</tbody>
</table>
<h4 id="magic-numbers-and-their-hexspeak">Magic Numbers and their Hexspeak</h4>
<p>With a certain geek humor, the termination codes, when discussed, are spoken as follows:</p>
<table>
<thead>
<tr class="header">
<th>Magic Number</th>
<th>Spoken Phrase</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0xdead10cc</code></td>
<td>Deadlock</td>
</tr>
<tr class="even">
<td><code>0xbaaaaaad</code></td>
<td>Bad</td>
</tr>
<tr class="odd">
<td><code>0xbad22222</code></td>
<td>Bad too (two) many times</td>
</tr>
<tr class="even">
<td><code>0x8badf00d</code></td>
<td>Ate (eight) bad food</td>
</tr>
<tr class="odd">
<td><code>0xc00010ff</code></td>
<td>Cool Off</td>
</tr>
<tr class="even">
<td><code>0x2bad45ec</code></td>
<td>Too bad for security</td>
</tr>
</tbody>
</table>
<h4 id="aborts">Aborts</h4>
<p>When we have a <code>SIGABRT</code>, we should look for what exceptions and assertions are present in our code from the stack trace of the crashed thread.</p>
<h4 id="memory-issues">Memory Issues</h4>
<p>When we have a memory issue, <code>EXC_BAD_ACCESS</code>, with <code>SIGSEGV</code> or <code>SIGBUS</code>, the faulty memory reference is the second number of the Exception Codes number pair. For this type of problem, the diagnostics settings within Xcode for the target scheme is relevant. The address sanitizer should be switched on to see if it could spot the error.</p>
<p>If Xcode shows a lot of memory is being used by the app, then it might be that memory we were relying upon has been freed by the system. For this, switch on the Malloc Stack logging option, selecting All Allocation and Free History. Then at some point during the app, the MemGraph button can be clicked, and then the allocation history of objects explored.</p>
<p>For more details, see the Memory Diagnostics Chapter.</p>
<h4 id="exceptions">Exceptions</h4>
<p>When we have a <code>EXC_BREAKPOINT</code> it can seem confusing. The program may have been running standalone without a debugger so where did the breakpoint come from? Typically, we are running <code>NSException</code> code. This will make the system signal the process with the trace trap signal and this makes any available debugger attach to the process to aid debugging. So in the case where we were running the app under the debugger, even with breakpoints switched off, we would breakpoint in here so we can find out why there was a runtime exception. In the case of normal app running, there is no debugger so we would just crash the app.</p>
<h4 id="illegal-instructions">Illegal Instructions</h4>
<p>When we have a <code>EXC_BAD_INSTRUCTION</code>, the exception codes (second number) will be the problematic assembly code. This should be a rare condition. It is worthwhile adjusting the optimization level of the code at fault in the Build Settings because higher level optimizations can cause more exotic instructions to be emitted during build time, and hence a bigger chance for a compiler bug. Alternatively, the problem might be a lower level library that has hand assembly optimizations in it - such as a multimedia library. Handwritten assembly can be the cause of bad instructions.</p>
<h4 id="guard-exceptions">Guard exceptions</h4>
<p>Certain files descriptors on the system are specially protected because they are used by the Operating System. When such file descriptors are closed (or otherwise modified) we can get a <code>EXC_GUARD</code> exception.</p>
<p>An example is:</p>
<pre><code>Exception Type:  EXC_GUARD
Exception Codes: 0x0000000100000000, 0x08fd4dbfade2dead
Crashed Thread:  5</code></pre>
<p>The exception code <code>0x08fd4dbfade2dead</code> indicates a database related file descriptor was modified (in our example it was closed). The hex string could be read as “Ate (8) File Descriptor (fd) for (4) Database (db)” in “hex speak”.</p>
<p>When such problems occur, we look at the file operation of the crashed thread. In our example:</p>
<pre><code>Thread 5 name:  Dispatch queue: com.apple.root.default-priority
Thread 5 Crashed:
0   libsystem_kernel.dylib          0x3a287294 close + 8
1   ExternalAccessory               
0x32951be2 -[EASession dealloc] + 226</code></pre>
<p>Here a close operation was performed.</p>
<p>If we have code talking to file descriptors, we should always check the return value for the close operation in particular.</p>
<p>It is possible to infer the file operation from the first of the exception codes. It is a 64-bit flag, specified as follows:</p>
<table>
<thead>
<tr class="header">
<th>Bit Range</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>63:61</td>
<td>Guard Type where 0x2 means file descriptor</td>
</tr>
<tr class="even">
<td>60:32</td>
<td>Flavor</td>
</tr>
<tr class="odd">
<td>31:00</td>
<td>File descriptor number</td>
</tr>
</tbody>
</table>
<p>From observation, we think the Guard type is not used.</p>
<p>The Flavor is a further bit vector:</p>
<table>
<thead>
<tr class="header">
<th>Flavor Bit</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>close()</code> attempted</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>dup()</code>, <code>dup2()</code> or <code>fcntl()</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>sendmsg()</code> attempted via a socket</td>
</tr>
<tr class="even">
<td>4</td>
<td><code>write()</code> attempted</td>
</tr>
</tbody>
</table>
<h3 id="ios-crash-report-filtered-syslog-section">iOS Crash Report Filtered Syslog Section</h3>
<p>The Crash Report continues with the syslog section:</p>
<pre><code>Filtered syslog:
None found</code></pre>
<p>This is an anomalous section because it is supposed to look at the process ID of the crashed process and then look to see if there are any syslog (System Log) entries for that process. We have never seen filtered entries in a crash, and only see <code>None found</code> reported.</p>
<p>In later versions of the iOS Crash Report, this section has been removed.</p>
<h3 id="ios-crash-report-exception-backtrace-section">iOS Crash Report Exception Backtrace section</h3>
<p>When our app has detected a problem and has asked the Operating System to terminate the app, we get an Exception Backtrace section of the report. This covers the cases of calling <code>abort</code>, <code>NSException</code>, <code>_NSLockError</code>, or <code>objc_exception_throw</code> either ourselves or indirectly through the Swift, Objective-C or C runtime support libraries.</p>
<p>What we don’t get is the text of the actual assertion that had occurred. One presumes that the prior section for filtered syslog information was supposed to do that job. Nevertheless, <em>Window-&gt;Devices and Simulators-&gt;Open Console</em> will allow us to recover that information.</p>
<p>When we see an Exception Backtrace in a customer Crash Report, we should ask for the device console log of the crashing device.</p>
<p>We would for example see:</p>
<pre><code>default 13:36:58.000000 +0000   icdab_nsdata
     My data is &lt;&gt; - ok since we can handle a nil

default 13:36:58.000000 +0100   icdab_nsdata     
-[__NSCFConstantString _isDispatchData]:
unrecognized selector sent to instance 0x3f054

default 13:36:58.000000 +0100   icdab_nsdata
     *** Terminating app due to
uncaught exception &#39;NSInvalidArgumentException&#39;, reason:
&#39;-[__NSCFConstantString _isDispatchData]:
 unrecognized selector sent to
instance 0x3f054&#39;
    *** First throw call stack:
    (0x25aa391b 0x2523ee17 0x25aa92b5 0x25aa6ee1 0x259d2238
     0x2627e9a5 0x3d997
    0x2a093785 0x2a2bb2d1 0x2a2bf285 0x2a2d383d 0x2a2bc7b3
     0x27146c07
    0x27146ab9 0x27146db9 0x25a65dff 0x25a659ed 0x25a63d5b
     0x259b3229
     0x259b3015 0x2a08cc3d 0x2a087189 0x3d80d 0x2565b873)

default 13:36:58.000000 +0100   SpringBoard  Application
&#39;UIKitApplication:www.perivalebluebell.icdab-nsdata[0x51b9]&#39;
 crashed.

default 13:36:58.000000 +0100   UserEventAgent
     2769630555571:
 id=www.perivalebluebell.icdab-nsdata pid=386, state=0

default 13:36:58.000000 +0000   ReportCrash  Formulating
report for corpse[386] icdab_nsdata

default 13:36:58.000000 +0000   ReportCrash  Saved type
 &#39;109(109_icdab_nsdata)&#39;
 report (2 of max 25) at
 /var/mobile/Library/Logs/CrashReporter/
 icdab_nsdata-2018-07-27-133658.ips</code></pre>
<p>The line of interest is:</p>
<pre><code>&#39;-[__NSCFConstantString _isDispatchData]:
unrecognized selector sent to instance 0x3f054&#39;</code></pre>
<p>This means the <code>NSString</code> class was sent the <code>_isDispatchData</code> method. No such method exists.</p>
<p>The matching exception backtrace seen in the Crash Report is:</p>
<pre><code>Last Exception Backtrace:
0   CoreFoundation                  
0x25aa3916 __exceptionPreprocess + 122
1   libobjc.A.dylib                 
0x2523ee12 objc_exception_throw + 33
2   CoreFoundation                  0x25aa92b0
-[NSObject+ 1045168 (NSObject) doesNotRecognizeSelector:] + 183
3   CoreFoundation                  
0x25aa6edc ___forwarding___ + 695
4   CoreFoundation                  
0x259d2234 _CF_forwarding_prep_0 + 19
5   Foundation                      0x2627e9a0
-[_NSPlaceholderData initWithData:] + 123
6   icdab_nsdata                    0x000f89ba
-[AppDelegate application:didFinishLaunchingWithOptions:]
 + 27066 (AppDelegate.m:26)
7   UIKit                           0x2a093780
-[UIApplication
 _handleDelegateCallbacksWithOptions:isSuspended:restoreState:]
 + 387
8   UIKit                           0x2a2bb2cc
-[UIApplication
 _callInitializationDelegatesForMainScene:transitionContext:]
 + 3075
9   UIKit                           0x2a2bf280
-[UIApplication
 _runWithMainScene:transitionContext:completion:] + 1583
10  UIKit                           0x2a2d3838
__84-[UIApplication
 _handleApplicationActivationWithScene:transitionContext:
completion:]_block_invoke3286 + 31
11  UIKit                           0x2a2bc7ae
-[UIApplication workspaceDidEndTransaction:] + 129
12  FrontBoardServices              0x27146c02
__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 13
13  FrontBoardServices              0x27146ab4
-[FBSSerialQueue _performNext] + 219
14  FrontBoardServices              0x27146db4
-[FBSSerialQueue _performNextFromRunLoopSource] + 43
15  CoreFoundation                  0x25a65dfa
__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 9
16  CoreFoundation                  
0x25a659e8 __CFRunLoopDoSources0 + 447
17  CoreFoundation                  
0x25a63d56 __CFRunLoopRun + 789
18  CoreFoundation                  
0x259b3224 CFRunLoopRunSpecific + 515
19  CoreFoundation                  
0x259b3010 CFRunLoopRunInMode + 103
20  UIKit                           
0x2a08cc38 -[UIApplication _run] + 519
21  UIKit                           
0x2a087184 UIApplicationMain + 139
22  icdab_nsdata                    
0x000f8830 main + 26672 (main.m:14)
23  libdyld.dylib                   
0x2565b86e tlv_get_addr + 41</code></pre>
<p>The format of this backtrace is the same as the thread backtrace, described later.</p>
<p>The purpose of the exception back trace section is to give more detail than that provided by the crashing thread.</p>
<p>The crashing thread in the above scenario had the thread backtrace:</p>
<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x2572ec5c __pthread_kill
 + 8
1   libsystem_pthread.dylib         0x257d8732 pthread_kill +
 62
2   libsystem_c.dylib               0x256c30ac abort + 108
3   libc++abi.dylib                 0x2521aae4 __cxa_bad_cast
 + 0
4   libc++abi.dylib                 0x2523369e
default_terminate_handler+ 104094 () + 266
5   libobjc.A.dylib                 0x2523f0b0
_objc_terminate+ 28848 () + 192
6   libc++abi.dylib                 0x25230e16
std::__terminate(void (*)+ 93718 ()) + 78
7   libc++abi.dylib                 0x252308f8
__cxa_increment_exception_refcount + 0
8   libobjc.A.dylib                 
0x2523ef5e objc_exception_rethrow + 42
9   CoreFoundation                  
0x259b32ae CFRunLoopRunSpecific + 654
10  CoreFoundation                  
0x259b3014 CFRunLoopRunInMode + 108
11  UIKit                           
0x2a08cc3c -[UIApplication _run] + 524
12  UIKit                           
0x2a087188 UIApplicationMain + 144
13  icdab_nsdata                    
0x000f8834 main + 26676 (main.m:14)
14  libdyld.dylib                   
0x2565b872 start + 2</code></pre>
<p>If we only had the thread backtrace, we would know there was a casting problem <code>__cxa_bad_cast</code> but not much more.</p>
<p>A little bit of Internet searching reveals that <code>NSData</code> has a private helper class <code>_NSPlaceholderData</code></p>
<p>What has happened here is that an <code>NSString</code> object was provided where an <code>NSData</code> object was expected.</p>
<h3 id="ios-crash-report-thread-section">iOS Crash Report Thread Section</h3>
<p>The Crash Report continues with a dump of the thread backtraces as follows (formatted for ease of demonstration)</p>
<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x0000000183a012ec
 __pthread_kill + 8
1   libsystem_pthread.dylib         0x0000000183ba2288
 pthread_kill$VARIANT$mp + 376
2   libsystem_c.dylib               0x000000018396fd0c
 abort + 140
3   libsystem_c.dylib               0x0000000183944000
 basename_r + 0
4   icdab_planets                   
0x0000000104e145bc
 -[PlanetViewController viewDidLoad] + 17852
  (PlanetViewController.mm:33)
5   UIKit                           0x000000018db56ee0
 -[UIViewController loadViewIfRequired] + 1020
6   UIKit                           0x000000018db56acc
 -[UIViewController view] + 28
7   UIKit                           0x000000018db47d60
 -[UIWindow addRootViewControllerViewIfPossible] + 136
8   UIKit                           0x000000018db46b94
 -[UIWindow _setHidden:forced:] + 272
9   UIKit                           0x000000018dbd46a8
-[UIWindow makeKeyAndVisible] + 48
10  UIKit                           0x000000018db4a2f0
 -[UIApplication
  _callInitializationDelegatesForMainScene:transitionContext:]
  + 3660
11  UIKit                           0x000000018db1765c
-[UIApplication
_runWithMainScene:transitionContext:completion:] + 1680
12  UIKit                           0x000000018e147a0c
__111-[__UICanvasLifecycleMonitor_Compatability
_scheduleFirstCommitForScene:transition:firstActivation:
completion:]_block_invoke + 784
13  UIKit                           0x000000018db16e4c
+[_UICanvas _enqueuePostSettingUpdateTransactionBlock:] + 160
14  UIKit                           0x000000018db16ce8
-[__UICanvasLifecycleMonitor_Compatability
_scheduleFirstCommitForScene:transition:
firstActivation:completion:] + 240
15  UIKit                           0x000000018db15b78
-[__UICanvasLifecycleMonitor_Compatability
activateEventsOnly:withContext:completion:] + 724
16  UIKit                           0x000000018e7ab72c
__82-[_UIApplicationCanvas
 _transitionLifecycleStateWithTransitionContext:
completion:]_block_invoke + 296
17  UIKit                           0x000000018db15268
-[_UIApplicationCanvas
 _transitionLifecycleStateWithTransitionContext:
completion:] + 432
18  UIKit                           0x000000018e5909b8
__125-[_UICanvasLifecycleSettingsDiffAction
performActionsForCanvas:
withUpdatedScene:settingsDiff:fromSettings:
transitionContext:]_block_invoke + 220
19  UIKit                           0x000000018e6deae8
_performActionsWithDelayForTransitionContext + 112
20  UIKit                           0x000000018db14c88
-[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:
withUpdatedScene:settingsDiff:fromSettings:
transitionContext:] + 248
21  UIKit                           0x000000018db14624
-[_UICanvas
scene:didUpdateWithDiff:transitionContext:completion:] + 368
22  UIKit                           0x000000018db1165c
-[UIApplication workspace:didCreateScene:withTransitionContext:
completion:] + 540
23  UIKit                           0x000000018db113ac
-[UIApplicationSceneClientAgent scene:didInitializeWithEvent:
completion:] + 364
24  FrontBoardServices              0x0000000186778470
-[FBSSceneImpl
_didCreateWithTransitionContext:completion:] + 364
25  FrontBoardServices              0x0000000186780d6c
__56-[FBSWorkspace client:handleCreateScene:withCompletion:]
_block_invoke_2 + 224
26  libdispatch.dylib               0x000000018386cae4
_dispatch_client_callout + 16
27  libdispatch.dylib               0x00000001838741f4
_dispatch_block_invoke_direct$VARIANT$mp + 224
28  FrontBoardServices              0x00000001867ac878
__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 36
29  FrontBoardServices              0x00000001867ac51c
-[FBSSerialQueue _performNext] + 404
30  FrontBoardServices              0x00000001867acab8
-[FBSSerialQueue _performNextFromRunLoopSource] + 56
31  CoreFoundation                  0x0000000183f23404
__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
32  CoreFoundation                  0x0000000183f22c2c
__CFRunLoopDoSources0 + 276
33  CoreFoundation                  0x0000000183f2079c
 __CFRunLoopRun + 1204
34  CoreFoundation                  0x0000000183e40da8
CFRunLoopRunSpecific + 552
35  GraphicsServices                0x0000000185e23020
 GSEventRunModal + 100
36  UIKit                           0x000000018de2178c
 UIApplicationMain + 236
37  icdab_planets                   0x0000000104e14c94
 main + 19604 (main.m:14)
38  libdyld.dylib                   0x00000001838d1fc0
 start + 4

Thread 1:
0   libsystem_pthread.dylib         0x0000000183b9fb04
 start_wqthread + 0

Thread 2:
0   libsystem_kernel.dylib          0x0000000183a01d84
 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000183b9feb4
 _pthread_wqthread + 928
2   libsystem_pthread.dylib         0x0000000183b9fb08
 start_wqthread + 4

Thread 3:
0   libsystem_pthread.dylib         0x0000000183b9fb04
start_wqthread + 0

Thread 4:
0   libsystem_kernel.dylib          0x0000000183a01d84
 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000183b9feb4
 _pthread_wqthread + 928
2   libsystem_pthread.dylib         0x0000000183b9fb08
start_wqthread + 4

Thread 5:
0   libsystem_kernel.dylib          0x0000000183a01d84
 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000183b9feb4
 _pthread_wqthread + 928
2   libsystem_pthread.dylib         0x0000000183b9fb08
 start_wqthread + 4

Thread 6 name:  com.apple.uikit.eventfetch-thread
Thread 6:
0   libsystem_kernel.dylib          0x00000001839dfe08
 mach_msg_trap + 8
1   libsystem_kernel.dylib          0x00000001839dfc80
 mach_msg + 72
2   CoreFoundation                  0x0000000183f22e40
__CFRunLoopServiceMachPort + 196
3   CoreFoundation                  0x0000000183f20908
 __CFRunLoopRun + 1568
4   CoreFoundation                  0x0000000183e40da8
CFRunLoopRunSpecific + 552
5   Foundation                      0x00000001848b5674
-[NSRunLoop+ 34420 (NSRunLoop) runMode:beforeDate:] + 304
6   Foundation                      0x00000001848b551c
-[NSRunLoop+ 34076 (NSRunLoop) runUntilDate:] + 148
7   UIKit                           0x000000018db067e4
-[UIEventFetcher threadMain] + 136
8   Foundation                      0x00000001849c5efc
__NSThread__start__ + 1040
9   libsystem_pthread.dylib         0x0000000183ba1220
 _pthread_body + 272
10  libsystem_pthread.dylib         0x0000000183ba1110
 _pthread_body + 0
11  libsystem_pthread.dylib         0x0000000183b9fb10
 thread_start + 4

Thread 7:
0   libsystem_pthread.dylib         0x0000000183b9fb04
 start_wqthread + 0</code></pre>
<p>The Crash Report will explicitly tell us which thread crashed.</p>
<pre><code>Thread 0 Crashed:</code></pre>
<p>Threads are numbered, and if they have a name, we are told this:</p>
<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread</code></pre>
<p>Most of our focus should be on the crashed thread; it is often thread 0. Take note of the thread name. Note no long duration tasks such as networking may be done on the main thread, <code>com.apple.main-thread</code>, because that thread is used to handle user interactions.</p>
<p>The references to <code>__workq_kernreturn</code> just indicate a thread waiting for work so can be ignored unless there are a huge number of them.</p>
<p>Similarly, the references to <code>mach_msg_trap</code> just indicate the thread is waiting for a message to come in.</p>
<p>When looking at stack backtraces, stack frame 0, the top of the stack, comes first, and then calling frames are listed. Therefore, the last thing being done is in frame 0.</p>
<h4 id="stack-backtrace-items">Stack backtrace items</h4>
<p>Let us now focus on backtrace items for each thread. For example:</p>
<pre><code>20  UIKit                           0x000000018db14c88
-[_UICanvasLifecycleSettingsDiffAction
performActionsForCanvas:
withUpdatedScene:settingsDiff:fromSettings:
transitionContext:] + 248</code></pre>
<table>
<thead>
<tr class="header">
<th>Column</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Stack frame number, with 0 the most recently executed.</td>
</tr>
<tr class="even">
<td>2</td>
<td>Binary file executing.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Execution position (frame 0), or return position (frame 1 onwards)</td>
</tr>
<tr class="even">
<td>4+</td>
<td>Symbolic function name or address with offset within the function</td>
</tr>
</tbody>
</table>
<p>The frame numbers, as they count upwards takes us backwards in time in terms of program execution order. The top of stack, or most recently run code, is in frame 0. One reason for writing code with meaningful function names is that the call stack describes what is going on conceptually. Using small single-purpose functions is good practice. It serves the needs of both diagnostics and maintainability.</p>
<p>The second column in a back trace is the binary file. We focus on our own binary mostly because framework code from Apple is generally very reliable. Faults usually occur either directly in our code, or by faults caused by incorrect usage of Apple APIs. Just because the code crashed in Apple provided code does not mean the fault is in Apple code.</p>
<p>The third column, the execution position, is slightly tricky. If it is for frame 0, it is the actual position in the code that was running. If it is for any later frame, it is the position in the code we shall resume from once the child functions have returned.</p>
<p>The fourth column is the site at which the code is running (for frame 0), or the site that is making a function call (for later frames). For symbolicated crashes, we will see the symbolic form for the address. This will include a positional offset from the start of a function to reach the code calling the child function. If we have only short functions, this offset will be a small value. It means much less stepping through code, or much less reading assembly code when performing diagnosis. That is another reason for keeping our functions short. If our crash is not symbolicated then we shall just see a memory address value.</p>
<p>Therefore, with the example stack frame we have:</p>
<ul>
<li>Stack Frame 20.</li>
<li>UIKit Binary File.</li>
<li><code>0x000000018db14c88</code> return address after frames 0 - 19 return.</li>
<li>Call site is 248 bytes from the beginning of method<br />
<code>performActionsForCanvas</code></li>
<li>Class is <code>_UICanvasLifecycleSettingsDiffAction</code></li>
</ul>
<h3 id="ios-crash-report-thread-state-section">iOS Crash Report Thread State Section</h3>
<p>iOS Crash Reports will be either from ARM-64 binaries (most common) or legacy ARM 32 bit binaries.</p>
<p>In each case, we get similar looking information describing the state of the ARM registers.</p>
<p>One thing to look out for is the special hex code, <code>0xbaddc0dedeadbead</code> which means a non-initialized pointer. However, newer versions of the Swift runtime don’t make use of this.</p>
<h4 id="bit-thread-state">32-bit thread state</h4>
<pre><code>Thread 0 crashed with ARM Thread State (32-bit):
    r0: 0x00000000    r1: 0x00000000      r2: 0x00000000
          r3: 0x00000000
    r4: 0x00000006    r5: 0x3c42f000      r6: 0x3b66d304
          r7: 0x002054c8
    r8: 0x14d5f480    r9: 0x252348fd     r10: 0x90eecad7
         r11: 0x14d5f4a4
    ip: 0x00000148    sp: 0x002054bc      lr: 0x257d8733
          pc: 0x2572ec5c
  cpsr: 0x00000010</code></pre>
<h4 id="bit-thread-state-from-older-swift-runtimes">64-bit thread state from older Swift runtimes</h4>
<pre><code>Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x0000000000000028   x1: 0x0000000000000029
       x2: 0x0000000000000008
       x3: 0x0000000183a4906c
    x4: 0x0000000104440260   x5: 0x0000000000000047
       x6: 0x000000000000000a
       x7: 0x0000000138819df0
    x8: 0x0000000000000000   x9: 0x0000000000000000
      x10: 0x0000000000000003
      x11: 0xbaddc0dedeadbead
   x12: 0x0000000000000012  x13: 0x0000000000000002
     x14: 0x0000000000000000
     x15: 0x0000010000000100
   x16: 0x0000000183b9b8cc  x17: 0x0000000000000100
     x18: 0x0000000000000000
     x19: 0x00000001b5c241c8
   x20: 0x00000001c0071b00  x21: 0x0000000000000018
     x22: 0x000000018e89b27a
     x23: 0x0000000000000000
   x24: 0x00000001c4033d60  x25: 0x0000000000000001
     x26: 0x0000000000000288
     x27: 0x00000000000000e0
   x28: 0x0000000000000010   fp: 0x000000016bde54b0
      lr: 0x000000010401ca04
    sp: 0x000000016bde53e0   pc: 0x000000010401c6c8
     cpsr: 0x80000000</code></pre>
<h4 id="bit-thread-state-on-newer-swift-runtimes">64-bit thread state on newer Swift runtimes</h4>
<pre><code>Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x00000001005f0000   x1: 0x000000028041e980
      x2: 0x0000000000000007   x3: 0x00000001a3688d84
    x4: 0x0000000000000000   x5: 0x0000000000000013   
      x6: 0x0000000000000020   x7: 0x00000000000003f8
    x8: 0x000000009de24040   x9: 0x000000000000007f  
      x10: 0x0000000000000054  x11: 0x00000000000007fb
   x12: 0x00000000000007fd  x13: 0x0000000000000000  
      x14: 0x000000009e024800  x15: 0x0000000000000049
   x16: 0x0000000080000000  x17: 0x000000001e000000  
      x18: 0x0000000000000000  x19: 0x000000000000002d
   x20: 0x0000000000000000  x21: 0x0000000000000002  
      x22: 0x0000000000000002  x23: 0x0000000000000044
   x24: 0x00000001005a7010  x25: 0x0000000283f31c00  
      x26: 0x000000010086d920  x27: 0x00000000000020ff
   x28: 0x00000001005a6f6a   fp: 0x000000016f8668f0   
      lr: 0x00000001b0e53d70
    sp: 0x000000016f8668d0   pc: 0x00000001b0e53d70
      cpsr: 0x60000000
   esr: 0xf2000001  Address size fault</code></pre>
<p>Here we see that for a ARM64 crash, we no longer get <code>0xbaddc0dedeadbead</code> set in <code>x11</code>. Instead, we get a new entry <code>esr:</code>. This means “Exception Syndrome Register”. <span class="citation" data-cites="ARMv8_ESR">(“Exception Syndrome Register” 2020)</span>.</p>
<table>
<thead>
<tr class="header">
<th>Bit Range</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>31:26</td>
<td>Exception Class</td>
</tr>
<tr class="even">
<td>25</td>
<td>Instruction Length</td>
</tr>
<tr class="odd">
<td>15:0</td>
<td>Comment</td>
</tr>
</tbody>
</table>
<p>In this instance bits <code>[31:26]</code> value <code>0b111100</code> means a <code>BRK</code> instruction was executed. Bit <code>25</code> whose value is <code>1</code> means in our case a <code>A64</code> <code>BRK</code> instruction was supplied. The bottom bits <code>[15:0]</code> value <code>1</code> means <code>1</code> when supplied when <code>BRK</code> was invoked. <span class="citation" data-cites="ARM_BRK">(“ARM Breakpoint Instruction” 2020)</span></p>
<h3 id="ios-crash-report-binary-images-section">iOS Crash Report Binary Images section</h3>
<p>The Crash Report has a section enumerating all the binary images loaded by the process that crashed. It is usually a long list. It highlights the fact that there are many supporting frameworks for our apps. Most frameworks are private frameworks. The iOS development kit might seem a huge set of APIs, but that is just the tip of the iceberg.</p>
<p>Here is an example list, edited for ease of demonstration:</p>
<pre><code>Binary Images:

0x104018000 - 0x10401ffff icdab_as arm64
  &lt;b82579f401603481990d1c1c9a42b773&gt;
/var/containers/Bundle/Application/
1A05BC59-491C-4D0A-B4F6-8A98A804F74D/icdab_as.app/icdab_as

0x104030000 - 0x104037fff libswiftCoreFoundation.dylib arm64
  &lt;81f66e04bab133feb3369b4162a68afc&gt;
  /var/containers/Bundle/Application/
1A05BC59-491C-4D0A-B4F6-8A98A804F74D/icdab_as.app/
Frameworks/libswiftCoreFoundation.dylib


0x104044000 - 0x104057fff libswiftCoreGraphics.dylib arm64
  &lt;f1f2287fb5153a28beea12ec2d547bf8&gt;
  /var/containers/Bundle/Application/
1A05BC59-491C-4D0A-B4F6-8A98A804F74D/icdab_as.app/
Frameworks/libswiftCoreGraphics.dylib

0x104078000 - 0x10407ffff libswiftCoreImage.dylib arm64
  &lt;9433fc53f72630dc8c53851703dd440b&gt;
  /var/containers/Bundle/Application/
1A05BC59-491C-4D0A-B4F6-8A98A804F74D/icdab_as.app/
Frameworks/libswiftCoreImage.dylib

0x104094000 - 0x1040cffff dyld arm64
  &lt;06dc98224ae03573bf72c78810c81a78&gt; /usr/lib/dyld</code></pre>
<p>The first part is where the image has been loaded into memory. Here <code>icdab_as</code> has been loaded into the range <code>0x104018000</code> - <code>0x10401ffff</code></p>
<p>The second part is the name of the binary. Here it is <code>icdab_as</code>.</p>
<p>The third part is the architecture slice within the binary that was loaded. We generally expect to just see <code>arm64</code> here (ARM 64-bit).</p>
<p>The fourth part is the UUID of the binary. Here <code>icdab_as</code> has UUID <code>b82579f401603481990d1c1c9a42b773</code></p>
<p>Symbolification will fail if our DSYM file UUID does not match the binary.</p>
<p>Here is an example of corresponding UUIDs seen in DSYM and application binaries using the <code>dwarfdump</code> command:</p>
<pre><code>$ dwarfdump --uuid icdab_as.app/icdab_as
icdab_as.app.dSYM/Contents/Resources/DWARF/icdab_as

UUID: 25BCB4EC-21DE-3CE6-97A8-B759F31501B7
 (arm64) icdab_as.app/icdab_as

UUID: 25BCB4EC-21DE-3CE6-97A8-B759F31501B7
 (arm64)
icdab_as.app.dSYM/Contents/Resources/DWARF/icdab_as</code></pre>
<p>The fifth part is the path to the binary as it appears on the device.</p>
<p>Most of the binaries have a self-explanatory name. The <code>dyld</code> binary is the dynamic loader. It is seen at the bottom of all stack backtraces because it is responsible for commencing the loading of binaries before their execution.</p>
<p>The dynamic loader does many tasks in preparing our binary for execution. If our binary references libraries, it will load them. If they are absent, it will fail to load our app. This is why it is possible to crash even before any code in <code>main.m</code> is called. Later on, we shall study how to diagnose such problems.</p>
<h2 id="guided-tour-of-a-macos-crash-report">Guided tour of a macOS Crash Report</h2>
<p>The macOS Crash Report is similar to an iOS Crash Report even though macOS CrashReport and iOS CrashReport are distinctly different programs. To avoid repetition, we just highlight notable differences from iOS.</p>
<p>Traditionally Mac computers only used the Intel CPU but that has changed with the introduction of Apple Silicon. So we can now see both ARM-64 and X86-64 crashes on Mac hardware.</p>
<p>A number of subtle issues can arise because Apple Silicon Macs can translate X86-64 instructions as well as running native ARM-64 binaries. Therefore we shall focus on Intel X86-64 crashes in this chapter, and leave Apple Silicon Mac crashes to their own chapter.</p>
<p>Since Apple Silicon Macs and iOS devices share the same underlying CPU architecture, Apple has provided support for unmodified iOS apps to be run on Apple Silicon Macs. One way to think of this is that macOS is a host operating system but provides iOS support libraries so that guest iOS apps can still make use of the frameworks they are expecting to be in place. We cover this variant in the Apple Silicon chapter.</p>
<h3 id="macos-crash-report-header-section">macOS Crash Report Header Section</h3>
<p>The crash dump starts with the header:</p>
<pre><code>Process:               SiriNCService [1045]
Path:                  /System/Library/CoreServices/Siri.app/
Contents/XPCServices/SiriNCService.xpc/
Contents/MacOS/SiriNCService
Identifier:            com.apple.SiriNCService
Version:               146.4.5.1 (146.4.5.1)
Build Info:            AssistantUIX-146004005001000~1
Code Type:             X86-64 (Native)
Parent Process:        ??? [1]
Responsible:           Siri [863]
User ID:               501</code></pre>
<p>Here we see familiar information describing the binary at fault. The process that crashed was SiriNCService, and the process responsible for that was Siri. There was a cross process communication at the time of the crash (XPC) between Siri and SiriNCService.</p>
<p>Whilst iOS is a system that runs the user experience as one user, the macOS system exposes the fact that there are multiple User IDs in the system.</p>
<h3 id="macos-crash-report-date-and-version-section">macOS Crash Report Date and Version Section</h3>
<p>We continue with version information:</p>
<pre><code>Date/Time:             2018-06-24 09:52:01.419 +0100
OS Version:            Mac OS X 10.13.5 (17F77)
Report Version:        12
Anonymous UUID:        00CC683B-425F-ABF0-515A-3ED73BACDDB5

Sleep/Wake UUID:       10AE8838-17A9-4405-B03D-B680DDC84436
</code></pre>
<p>The Anonymous UUID will uniquely identify the computer. The Sleep/Wake UUID is used to match up sleep and wake events. Failed wakeup is a common cause of a system crash (in contrast to the application crashes we have been discussing). Further information can be obtained using the <code>pmset</code> power management command.</p>
<h3 id="macos-duration-section">macOS Duration Section</h3>
<p>The macOS Crash Report shows how soon the application crash occurred.</p>
<pre><code>Time Awake Since Boot: 100000 seconds
Time Since Wake:       2000 seconds</code></pre>
<p>We use this as a broad indication only because the numbers seen always rounded to a convenient number.</p>
<h3 id="macos-crash-report-system-integrity-section">macOS Crash Report System Integrity Section</h3>
<pre><code>System Integrity Protection: enabled</code></pre>
<p>Modern macOS by default runs as “rootless”. This means that even if we are logged in as the superuser we cannot change system binaries. Those are protected with the help of firmware. It is possible to boot macOS with System Integrity Protection disabled. If we only get crashes where SIP is disabled, then we need to ask why SIP is off and what changes were made to the Operating System.</p>
<h3 id="macos-crash-report-exception-section">macOS Crash Report Exception Section</h3>
<p>We next get an exceptions section.</p>
<pre><code>Crashed Thread:        0  Dispatch queue: com.apple.main-thread

Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000018
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Segmentation fault: 11
Termination Reason:    Namespace SIGNAL, Code 0xb
Terminating Process:   exc handler [0]

VM Regions Near 0x18:
--&gt;
    __TEXT                 0000000100238000-0000000100247000
     [   60K] r-x/rwx SM=COW  
     /System/Library/CoreServices/Siri.app/
     Contents/XPCServices/SiriNCService.xpc/Contents/MacOS/
     SiriNCService

Application Specific Information:
objc_msgSend() selector name: didUnlockScreen:</code></pre>
<p>This is similar to iOS. However, we should note that if we are reproducing an iOS crash on the simulator, then the simulator might model the same programming error differently. We can get a different exception on x86 hardware than its ARM counterpart.</p>
<p>Consider the following code, setup with legacy manual reference counting (MRC) instead of automatic reference counting (ARC)</p>
<pre><code>void use_sema() {
    dispatch_semaphore_t aSemaphore =
     dispatch_semaphore_create(1);
    dispatch_semaphore_wait(aSemaphore, DISPATCH_TIME_FOREVER);
    dispatch_release(aSemaphore);
}</code></pre>
<p>This code causes a crash because a semaphore was manually released whilst we were waiting on it.</p>
<p>When it runs on iOS on ARM hardware we get the crash,</p>
<pre><code>Exception Type:  EXC_BREAKPOINT (SIGTRAP)
Exception Codes: 0x0000000000000001, 0x00000001814076b8
Termination Signal: Trace/BPT trap: 5
Termination Reason: Namespace SIGNAL, Code 0x5
Terminating Process: exc handler [0]
Triggered by Thread:  0

Application Specific Information:
BUG IN CLIENT OF LIBDISPATCH: Semaphore object deallocated while
 in use
 Abort Cause 1</code></pre>
<p>When it runs on the iOS simulator, we get the debugger attaching with</p>
<pre><code>Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</code></pre>
<p>The simulator uses a bad assembly instruction to trigger the crash.</p>
<p>Furthermore, if we write a macOS app that runs the same code, we get the crash:</p>
<pre><code>Crashed Thread:        0  Dispatch queue: com.apple.main-thread

Exception Type:        EXC_BAD_INSTRUCTION (SIGILL)
Exception Codes:       0x0000000000000001, 0x0000000000000000
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Illegal instruction: 4
Termination Reason:    Namespace SIGNAL, Code 0x4
Terminating Process:   exc handler [0]

Application Specific Information:
BUG IN CLIENT OF LIBDISPATCH:
Semaphore object deallocated while in use</code></pre>
<p>The take away message is when iOS ARM crashes are being reproduced on x86 hardware, either via the Simulator or via equivalent macOS code, expect the runtime environment to be different and cause a slightly different looking crash.</p>
<p>Fortunately, here it is clear that a semaphore was deallocated whilst it was in use in both Crash Reports.</p>
<h3 id="macos-crash-report-thread-section">macOS Crash Report Thread Section</h3>
<p>We next have the thread section. This is similar to iOS.</p>
<p>Here is an example thread in a macOS Crash Report:</p>
<pre><code>Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libobjc.A.dylib                 
0x00007fff69feae9d objc_msgSend + 29
1   com.apple.CoreFoundation        0x00007fff42e19f2c
 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 12
2   com.apple.CoreFoundation        0x00007fff42e19eaf
___CFXRegistrationPost_block_invoke + 63
3   com.apple.CoreFoundation        0x00007fff42e228cc
 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
4   com.apple.CoreFoundation        0x00007fff42e052a3
__CFRunLoopDoBlocks + 275
5   com.apple.CoreFoundation        0x00007fff42e0492e
__CFRunLoopRun + 1278
6   com.apple.CoreFoundation        0x00007fff42e041a3
CFRunLoopRunSpecific + 483
7   com.apple.HIToolbox             0x00007fff420ead96
RunCurrentEventLoopInMode + 286
8   com.apple.HIToolbox             0x00007fff420eab06
ReceiveNextEventCommon + 613
9   com.apple.HIToolbox             0x00007fff420ea884
 _BlockUntilNextEventMatchingListInModeWithFilter + 64
10  com.apple.AppKit                0x00007fff4039ca73
_DPSNextEvent + 2085
11  com.apple.AppKit                0x00007fff40b32e34
-[NSApplication(NSEvent) _nextEventMatchingEventMask:
untilDate:inMode:dequeue:] + 3044
12  com.apple.ViewBridge            0x00007fff67859df0
-[NSViewServiceApplication nextEventMatchingMask:
untilDate:inMode:dequeue:] + 92
13  com.apple.AppKit                0x00007fff40391885
-[NSApplication run] + 764
14  com.apple.AppKit                0x00007fff40360a72
NSApplicationMain + 804
15  libxpc.dylib                    0x00007fff6af6cdc7
 _xpc_objc_main + 580
16  libxpc.dylib                    0x00007fff6af6ba1a
 xpc_main + 433
17  com.apple.ViewBridge            0x00007fff67859c15
-[NSXPCSharedListener resume] + 16
18  com.apple.ViewBridge            0x00007fff67857abe
 NSViewServiceApplicationMain + 2903
19  com.apple.SiriNCService         0x00000001002396e0
 main + 180
20  libdyld.dylib                   0x00007fff6ac12015
 start + 1</code></pre>
<h3 id="macos-crash-report-thread-state-section">macOS Crash Report Thread State Section</h3>
<p>The macOS Crash Report shows details of the X86 registers in the crashed thread.</p>
<pre><code>Thread 0 crashed with X86 Thread State (64-bit):
  rax: 0x0000600000249bd0  rbx: 0x0000600000869ac0
    rcx: 0x00007fe798f55320
    rdx: 0x0000600000249bd0
  rdi: 0x00007fe798f55320  rsi: 0x00007fff642de919
    rbp: 0x00007ffeef9c6220
    rsp: 0x00007ffeef9c6218
   r8: 0x0000000000000000   r9: 0x21eb0d26c23ae422
     r10: 0x0000000000000000
     r11: 0x00007fff642de919
  r12: 0x00006080001e8700  r13: 0x0000600000869ac0
    r14: 0x0000600000448910
    r15: 0x0000600000222e60
  rip: 0x00007fff69feae9d  rfl: 0x0000000000010246
    cr2: 0x0000000000000018

Logical CPU:     2
Error Code:      0x00000004
Trap Number:     14</code></pre>
<p>In addition to the iOS equivalent, we get further information about the CPU that was running the thread. The trap number can be looked up in the Darwin XNU source code if needed.</p>
<p>A convenient mirror of the Darwin XNU source code is hosted by GitHub: https://github.com/apple/darwin-xnu</p>
<p>The traps can be searched for. Here we have <code>osfmk/x86_64/idt_table.h</code> indicating Trap 14 is a page fault. The Error Code is a bit vector, used to describe the mach error code. <span class="citation" data-cites="macherror">(“Making Sense of I/O Kit Error Codes” 2018)</span></p>
<h3 id="macos-crash-report-binary-images-section">macOS Crash Report Binary Images section</h3>
<p>Next, we have the binary images loaded by the crashing app.</p>
<p>Here is an example of the first few binaries in a Crash Report, truncated for ease of demonstration:</p>
<pre><code>Binary Images:
       0x100238000 -        0x1ß00246fff
         com.apple.SiriNCService (146.4.5.1 - 146.4.5.1)
          &lt;5730AE18-4DF0-3D47-B4F7-EAA84456A9F7&gt;
           /System/Library/CoreServices/Siri.app/Contents/
           XPCServices/SiriNCService.xpc/Contents/MacOS/
           SiriNCService

       0x101106000 -        0x10110affb
         com.apple.audio.AppleHDAHALPlugIn (281.52 - 281.52)
          &lt;23C7DDE6-A44B-3BE4-B47C-EB3045B267D9&gt;
           /System/Library/Extensions/AppleHDA.kext/Contents/
           PlugIns/AppleHDAHALPlugIn.bundle/Contents/MacOS/
           AppleHDAHALPlugIn</code></pre>
<p>When a plus sign appears next to the binary it is meant to mean the binary is part of the OS. However, we see examples of the plus sign present in third party binaries and absent in system binaries, so the plus sign is not a reliable indicator (last tested on OS X 10.13.6).</p>
<h3 id="macos-crash-report-modification-summary">macOS Crash Report Modification Summary</h3>
<p>Next, we have a section describing any external modifications to our crashed process:</p>
<pre><code>External Modification Summary:
  Calls made by other processes targeting this process:
    task_for_pid: 184
    thread_create: 0
    thread_set_state: 0
  Calls made by this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by all processes on this machine:
    task_for_pid: 72970
    thread_create: 0
    thread_set_state: 0</code></pre>
<p>macOS is a more open platform than iOS. This permits, under certain conditions, modification of our process. We need to know if such a thing happened. It can invalidate any design assumption in our the code. Changing the registers of a running process can induce a crash.</p>
<p>Ordinarily the above snapshot would be seen. Notably <code>thread_set_state</code> is zero in all cases. This means no process has directly attached to the process to change the state of a register. Such actions would be acceptable for implementations of managed runtimes, or debuggers. Outside of these scenarios, such actions would be suspicious and need further investigation.</p>
<p>In the following example, we see that the thread state had been changed by an external process on one occasion, in addition to 200 <code>task_for_pid</code> calls.</p>
<pre><code>External Modification Summary:
  Calls made by other processes targeting this process:
    task_for_pid: 201
    thread_create: 0
    thread_set_state: 1
  Calls made by this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by all processes on this machine:
    task_for_pid: 6184
    thread_create: 0
    thread_set_state: 1</code></pre>
<p>Such data would normally make us suspicious of the environment the program ran in, before crashing.</p>
<p>Ordinarily only first party (Apple provided) programs have privilege to perform the above modifications. It is possible to install software that also does this.</p>
<p>The requirements for accessing process modification APIs are:</p>
<ul>
<li>System Integrity Protection needs to be disabled.</li>
<li>The process making the modification must run as root.</li>
<li>The program making the modifications must be code signed.</li>
<li>The entitlement assigned to the program must have <code>SecTaskAccess</code> set to <code>allowed</code> and <code>debug</code></li>
<li>The user must agree to trust the program in their security settings.</li>
</ul>
<p>The example code <code>tfpexample</code> demonstrates this. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<h3 id="macos-crash-report-virtual-memory-section">macOS Crash Report Virtual Memory Section</h3>
<p>The next section of the Crash Report is the virtual memory summary and region type breakdown. If we have a graphics heavy app that renders pages of a document, we might look at how big the CoreUI image data region is, for example. Virtual memory statistics are only meaningful when the app has already been studied in the Xcode Instruments memory profiler because then we can get a feel for the dynamic usage of memory in the app, and thus begin to spot when things look numerically wrong.</p>
<p>Here is an example of the VM Region Section of the report:</p>
<pre><code>VM Region Summary:
ReadOnly portion of Libraries: Total=544.2M resident=0K(0%)
swapped_out_or_unallocated=544.2M(100%)
Writable regions: Total=157.9M written=0K(0%) resident=0K(0%)
swapped_out=0K(0%) unallocated=157.9M(100%)

                                VIRTUAL   REGION
REGION TYPE                        SIZE    COUNT (non-coalesced)
===========                     =======  =======
Accelerate framework               128K        2
Activity Tracing                   256K        2
CoreAnimation                      700K       16
CoreGraphics                         8K        2
CoreImage                           20K        4
CoreServices                      11.9M        3
CoreUI image data                  764K        6
CoreUI image file                  364K        8
Foundation                          24K        3
IOKit                             7940K        2
Image IO                           144K        2
Kernel Alloc Once                    8K        2
MALLOC                           133.1M       36
MALLOC guard page                   48K       13
Memory Tag 242                      12K        2
Memory Tag 251                      16K        2
OpenGL GLSL                        256K        4
SQLite page cache                   64K        2
STACK GUARD                       56.0M        6
Stack                             10.0M        8
VM_ALLOCATE                        640K        8
__DATA                            58.3M      514
__FONT_DATA                          4K        2
__GLSLBUILTINS                    2588K        2
__LINKEDIT                       194.0M       26
__TEXT                           350.2M      516
__UNICODE                          560K        2
mapped file                       78.2M       29
shared memory                     2824K       11
===========                     =======  =======
TOTAL                            908.7M     1206</code></pre>
<h3 id="macos-crash-report-system-profile-section">macOS Crash Report System Profile section</h3>
<p>The next part of the Crash Report is a summary of the hardware in place:</p>
<pre><code>System Profile:
Network Service: Wi-Fi, AirPort, en1
Thunderbolt Bus: iMac, Apple Inc., 26.1
Boot Volume File System Type: apfs
Memory Module: BANK 0/DIMM0, 8 GB, DDR3, 1600 MHz, 0x802C,
 0x31364B544631473634485A2D314736453220
Memory Module: BANK 1/DIMM0, 8 GB, DDR3, 1600 MHz, 0x802C,
 0x31364B544631473634485A2D314736453220
USB Device: USB 3.0 Bus
USB Device: BRCM20702 Hub
USB Device: Bluetooth USB Host Controller
USB Device: FaceTime HD Camera (Built-in)
USB Device: iPod
USB Device: USB Keyboard
Serial ATA Device: APPLE SSD SM0512F, 500.28 GB
Model: iMac15,1, BootROM IM151.0217.B00, 4 processors,
 Intel Core i5, 3.5 GHz, 16 GB, SMC 2.22f16
Graphics: AMD Radeon R9 M290X, AMD Radeon R9 M290X, PCIe
AirPort: spairport_wireless_card_type_airport_extreme
 (0x14E4, 0x142), Broadcom BCM43xx 1.0 (7.77.37.31.1a9)
Bluetooth: Version 6.0.6f2, 3 services, 27 devices,
 1 incoming serial ports</code></pre>
<p>Sometimes our app closely interacts with a hardware peripheral, and if that is via a standards based interface such as USB, then a lot of variability is possible. Consider disk drives. Many vendors provide disk drives, and they may be directly powered, or independently powered. They may be directly attached, attached via a USB cable, or via a USB hub.</p>
<p>Sometimes newer hardware, such as a new type of MacBook Pro comes with its own hardware issues, so crashes unrelated to our app can be seen.</p>
<p>The key to understanding whether the hardware environment comes into play is to see a number of crashes to look for patterns.</p>
<p>As application developers, we only see crashes in our app. If we have contact with the user who has provided a crash, we can ask if any other apps are crashing, or if any system stability issues are present.</p>
<p>Another interesting aspect is that not all hardware is actively used by the system all the time. For example, when a MacBook Pro is connected to an external display, different graphics RAM is used and a different graphics card is used (external versus an internal GPU). If our app does something special, when connected to an external display, the fault may be in the hardware instead of our code due to it triggering a latent fault in the hardware.</p>
<p>Running system diagnostics and looking to see if the problems are appearing against only specific Anonymous UUID Crash Reports are ways to try and understand if we have a machine specific hardware issue.</p>
<h1 id="apple-silicon">Apple Silicon</h1>
<p>In this chapter we look at crashes on Apple Silicon Macs, crashes arising from the use of the Rosetta translation system, and crashes arising from unmodified iOS apps running on macOS. Furthermore we look at new types of crashes that are possible from multi-architecture code that supports both ARM and Intel CPUs.</p>
<h2 id="what-is-an-apple-silicon-mac">What is an Apple Silicon Mac?</h2>
<p>Apple Silicon means the design of the chip is from Apple, not from a third party. The A-series chips from Apple can be considered Apple Silicon. However, the focus of this chapter are Apple Silicon Macs. These have commenced with the Apple M1  chip. Presumably the reason why these Macs are not called “ARM-based Macs” is that Apple have made a significant contribution at the design level whilst still conforming to the ARM ABI. These provide marketable benefits for the customer when switching from Intel-based Macs to Apple Silicon Macs, such as long battery life and high performance.</p>
<h2 id="what-is-rosetta">What is Rosetta?</h2>
<p>Rosetta is an instruction translator present on Apple Silicon Macs. When presented an Application with Intel instructions as part of the binary, it can translate those to ARM instructions, and then run them. Think of it as a Ahead Of Time (AOT) compiler. <span class="citation" data-cites="rosetta">(“About the Rosetta Translation Environment” 2020)</span> The origins of the technology come from an earlier era when Macs were transitioning from the PowerPC chip to Intel chips. Apple was assisted by technology from Transitive Technologies Ltd. to produce Rosetta version 1. <span class="citation" data-cites="transitive">(“Heroes of Software Engineering - the Men and Women at Transitive” 2020)</span> <span class="citation" data-cites="rosetta_news">(“The Brains Behind Apple’s Rosetta: Transitive” 2020)</span> In Rosetta version 2, we have a system allowing on a per process basis, Intel instructions to be pre-translated to ARM instructions, and then run at native speed.</p>
<h3 id="rosetta-binaries">Rosetta binaries</h3>
<p>On Apple Silicon Macs, the Rosetta software resides in</p>
<pre><code>/Library/Apple/usr/libexec/oah</code></pre>
<p>Within this directory is the runtime engine, <code>runtime_t8027</code>, the translator <code>oahd-helper</code>, a command line tool <code>translate_tool</code>, and other artifacts. Its operation is largely transparent to end users apart from a small startup delay or slightly lower performance. From a crash dump perspective, we see its presence in terms of memory footprint, exception helper and runtime helpers.</p>
<h3 id="rosetta-limitations">Rosetta limitations</h3>
<p>Rosetta is a powerful system but it has some limitations. These concern mainly high performance multimedia applications and Operating System virtualization solutions.</p>
<p>Excluded from Rosetta are:</p>
<ul>
<li>Kernel extensions</li>
<li><code>x86_64</code> virtualization support instructions</li>
<li>vector instructions, such as AVX, AVX2, and AVX512</li>
</ul>
<p>Interestingly, Rosetta does support Just-In-Time compilation apps. These applications are special because they generate their own code and then execute them. Most applications have fixed read-only code (the program text) which is then executed, and only have their data as mutable (but not executable). Presumably this was because JIT is a common technology for the JavaScript runtime.</p>
<p>Apple advise checking for optional hardware features before calling code that utilizes such functionality. To determine what optional hardware support is present on our platform, we can run <code>sysctl hw | grep optional</code>. In code, we have the <code>sysctlbyname</code> function to achieve the same thing.</p>
<h3 id="forcing-rosetta-execution">Forcing Rosetta execution</h3>
<p>If we accept the standard build architecture options for our program, which are <code>Build Active Architecture Only</code> set to <code>Yes</code> for <code>Debug</code> builds, and <code>No</code> for <code>Release</code> builds, then when running under the Debugger, we shall only see Native binaries. That is because in the Debug case, we do not want to waste time building an architecture not relevant to the machine we are testing on.</p>
<p>If we do an archive build, <code>Product &gt; Archive</code>, and then select <code>Distribute App</code> we end up with a Release Build. With default settings, this will be a Fat Binary File offering <code>x86</code> and <code>arm64</code> within the multi-architecture binary.</p>
<p>Once we have a Fat binary we can use <code>Finder</code> app, right-click <code>File info</code> to set Rosetta to perform translation of our binary so that on an Apple Silicon Mac, the Intel instructions are translated from the Fat binary.</p>
<p><img src="screenshots/univeral_application_icdab_rosetta_thread.png" /></p>
<h2 id="code-translation-example">Code Translation Example</h2>
<p>Our working example in this chapter is the <code>icdab_thread</code> program; it is available on the web. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> This program attempts to call <code>thread_set_state</code> and then deliberately crashes 60 seconds later using <code>abort</code>. It is not able to actually do this because of recent security enhancements in macOS to prevent the use of such an API; it was an attack vector for malware. Nevertheless, this program is interesting because of a closely related artifact upon crashing, the number of times <code>task_for_pid</code> had been called.</p>
<p>We have adapted the command line executable program <code>icdab_thread</code> into an application which merely calls the same underlying code. The application is called <code>icdab_rosetta_thread</code>. The reason for this is because UNIX command line executables are not eligible for running Translated but Applications are.</p>
<h3 id="icdab_rosetta_thread-lipo-information"><code>icdab_rosetta_thread</code> Lipo Information</h3>
<p>The following command shows our application supports both ARM and Intel instructions.</p>
<pre><code># lipo -archs
 icdab_rosetta_thread.app/Contents/MacOS/icdab_rosetta_thread
x86_64 arm64</code></pre>
<h2 id="translated-crashes">Translated Crashes</h2>
<p>If we run the <code>icdab_rosetta_thread</code> application, clicking on <code>Start Threads Test</code>, after one minute we have a crash. Comparing the crash dump between Native and Translated cases, we see differences in the Crash Report.</p>
<h3 id="code-type">Code Type</h3>
<pre><code>Code Type:             ARM-64 (Native)</code></pre>
<p>when running natively, becomes under translation,</p>
<pre><code>Code Type:             X86-64 (Translated)</code></pre>
<h3 id="thread-dumps">Thread Dumps</h3>
<p>The crashed thread (and others) look similar, apart from the pointers are based much higher in the Translated case.</p>
<p>For the native crash we have:</p>
<pre><code>Thread 1 Crashed:: Dispatch queue: com.apple.root.default-qos
0   libsystem_kernel.dylib              0x00000001de3015d8
 __pthread_kill + 8
1   libsystem_pthread.dylib             0x00000001de3accbc
 pthread_kill + 292
2   libsystem_c.dylib                   0x00000001de274904 abort
 + 104
3   perivalebluebell.com.icdab-rosetta-thread  
 0x00000001002cd478 start_threads + 244
4   perivalebluebell.com.icdab-rosetta-thread  
 0x00000001002cd858 thunk for @escaping @callee_guaranteed () -&gt;
 () + 20
5   libdispatch.dylib                   0x00000001de139658
 _dispatch_call_block_and_release + 32
6   libdispatch.dylib                   0x00000001de13b150
 _dispatch_client_callout + 20
7   libdispatch.dylib                   0x00000001de13e090
 _dispatch_queue_override_invoke + 692
8   libdispatch.dylib                   0x00000001de14b774
 _dispatch_root_queue_drain + 356
9   libdispatch.dylib                   0x00000001de14bf6c
 _dispatch_worker_thread2 + 116
10  libsystem_pthread.dylib             0x00000001de3a9110
 _pthread_wqthread + 216
11  libsystem_pthread.dylib             0x00000001de3a7e80
 start_wqthread + 8</code></pre>
<p>For the translated crash we have:</p>
<pre><code>Thread 1 Crashed:: Dispatch queue: com.apple.root.default-qos
0   ???                                 0x00007fff0144ff40 ???
1   libsystem_kernel.dylib              0x00007fff6bdc4812
 __pthread_kill + 10
2   libsystem_c.dylib                   0x00007fff6bd377f0 abort
 + 120
3   perivalebluebell.com.icdab-rosetta-thread  
 0x0000000100d1c5ab start_threads + 259
4   perivalebluebell.com.icdab-rosetta-thread  
 0x0000000100d1ca1e thunk for @escaping @callee_guaranteed () -&gt;
 () + 14
5   libdispatch.dylib                   0x00007fff6bbf753d
 _dispatch_call_block_and_release + 12
6   libdispatch.dylib                   0x00007fff6bbf8727
 _dispatch_client_callout + 8
7   libdispatch.dylib                   0x00007fff6bbfad7c
 _dispatch_queue_override_invoke + 777
8   libdispatch.dylib                   0x00007fff6bc077a5
 _dispatch_root_queue_drain + 326
9   libdispatch.dylib                   0x00007fff6bc07f06
 _dispatch_worker_thread2 + 92
10  libsystem_pthread.dylib             0x00007fff6be8c4ac
 _pthread_wqthread + 244
11  libsystem_pthread.dylib             0x00007fff6be8b4c3
 start_wqthread + 15</code></pre>
<p>Note the actual line of code in thread stack 0 is <code>???</code> in the translated case. Presumably this is the actual translated code that is synthesized by Rosetta.</p>
<p>Furthermore we have an additional two threads in the translated case, the exception server, and the runtime environment:</p>
<pre><code>Thread 3:: com.apple.rosetta.exceptionserver
0   runtime_t8027                       0x00007ffdfff76af8
 0x7ffdfff74000 + 11000
1   runtime_t8027                       0x00007ffdfff803cc
 0x7ffdfff74000 + 50124
2   runtime_t8027                       0x00007ffdfff82738
 0x7ffdfff74000 + 59192

Thread 4:
0   runtime_t8027                       0x00007ffdfffce8ac
 0x7ffdfff74000 + 370860</code></pre>
<h3 id="crashed-thread-state-registers">Crashed Thread State Registers</h3>
<p>In the native case, we get thread state registers:</p>
<pre><code>Thread 1 crashed with ARM Thread State (64-bit):
    x0: 0x0000000000000000   x1: 0x0000000000000000   x2:
 0x0000000000000000   x3: 0x0000000000000000
    x4: 0x000000000000003c   x5: 0x0000000000000000   x6:
 0x0000000000000000   x7: 0x0000000000000000
    x8: 0x00000000000005b9   x9: 0xb91ed5337c66d7ee  x10:
 0x0000000000003ffe  x11: 0x0000000206c1fa22
   x12: 0x0000000206c1fa22  x13: 0x000000000000001e  x14:
 0x0000000000000881  x15: 0x000000008000001f
   x16: 0x0000000000000148  x17: 0x0000000200e28528  x18:
 0x0000000000000000  x19: 0x0000000000000006
   x20: 0x000000016fbbb000  x21: 0x0000000000001707  x22:
 0x000000016fbbb0e0  x23: 0x0000000000000114
   x24: 0x000000016fbbb0e0  x25: 0x000000020252d184  x26:
 0x00000000000005ff  x27: 0x000000020252d6c0
   x28: 0x0000000002ffffff   fp: 0x000000016fbbab70   lr:
 0x00000001de3accbc
    sp: 0x000000016fbbab50   pc: 0x00000001de3015d8 cpsr:
 0x40000000
   far: 0x0000000100ff8000  esr: 0x56000080</code></pre>
<p>In the translated case, we get thread state registers:</p>
<pre><code>Thread 1 crashed with X86 Thread State (64-bit):
  rax: 0x0000000000000000  rbx: 0x000000030600b000  rcx:
 0x0000000000000000  rdx: 0x0000000000000000
  rdi: 0x0000000000000000  rsi: 0x0000000000000003  rbp:
 0x0000000000000000  rsp: 0x000000000000003c
   r8: 0x000000030600ad40   r9: 0x0000000000000000  r10:
 0x000000030600b000  r11: 0x00007fff6bd37778
  r12: 0x0000000000003d03  r13: 0x0000000000000000  r14:
 0x0000000000000006  r15: 0x0000000000000016
  rip: &lt;unavailable&gt;  rfl: 0x0000000000000287</code></pre>
<h3 id="translated-code-information">Translated Code information</h3>
<p>In the translated case, we get extra information, presumably useful for those engineers that work on debugging Rosetta:</p>
<pre><code>Translated Code Information:
  tmp0: 0xffffffffffffffff tmp1: 0x00007fff0144ff14 tmp2:
 0x00007fff6bdc4808</code></pre>
<h3 id="external-modification-summary">External Modification Summary</h3>
<p>In the native case, we saw:</p>
<pre><code>External Modification Summary:
  Calls made by other processes targeting this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by all processes on this machine:
    task_for_pid: 914636
    thread_create: 0
    thread_set_state: 804</code></pre>
<p>Our code had attempted to call <code>thread_set_state</code> but was not able to (under any platform configuration due to macOS restrictions).</p>
<p>Looking that the translated case,</p>
<pre><code>External Modification Summary:
  Calls made by other processes targeting this process:
    task_for_pid: 1
    thread_create: 0
    thread_set_state: 0
  Calls made by this process:
    task_for_pid: 0
    thread_create: 0
    thread_set_state: 0
  Calls made by all processes on this machine:
    task_for_pid: 915091
    thread_create: 0
    thread_set_state: 804</code></pre>
<p>We see almost the same statistics, but interestingly we have <code>task_for_pid</code> set to 1. So the translation environment only did a minimal observation/modification of the actual process under translation.</p>
<h3 id="virtual-memory-regions">Virtual Memory Regions</h3>
<p>The translated version of the program runs a bit heavier on RAM usage than the native version.</p>
<p>In the native case, we have:</p>
<pre><code>                                VIRTUAL   REGION
REGION TYPE                        SIZE    COUNT (non-coalesced)
===========                     =======  =======
TOTAL                              1.7G     2053
TOTAL, minus reserved VM space     1.3G     2053</code></pre>
<p>versus the translated case:</p>
<pre><code>REGION TYPE                        SIZE    COUNT (non-coalesced)
===========                     =======  =======
TOTAL                              5.4G     1512
TOTAL, minus reserved VM space     5.1G     1512</code></pre>
<p>Note in the translated case we have additional Virtual Memory regions for Rosetta:</p>
<pre><code>Rosetta Arena                     2048K        1
Rosetta Generic                    864K       19
Rosetta IndirectBranch             512K        1
Rosetta JIT                      128.0M        1
Rosetta Return Stack               192K       12
Rosetta Thread Context             192K       12</code></pre>
<h2 id="rosetta-crashes">Rosetta Crashes</h2>
<p>Rosetta is a powerful translation system. But it does not translate all X86-64 instructions. Vector instructions, as an example, cannot be translated and generate a crash when encountered. <span class="citation" data-cites="rosetta">(“About the Rosetta Translation Environment” 2020)</span></p>
<p>Before diagnosing specific problems, it is worth familiarizing ourselves with the Porting Guide from Apple because this can help us develop a reasonable hypothesis for why our program may be crashing. <span class="citation" data-cites="rosettaPortingGuide">(“Porting Your macOS Apps to Apple Silicon” 2020)</span></p>
<h3 id="icdab_avx-vector-instruction-crash"><code>icdab_avx</code> vector instruction crash</h3>
<p>When an Intel AVX vector instruction is encountered on a Apple Silicon Mac running the app using translation, we get a crash. We have a sample application, <code>icdab_avx</code>, that demonstrates this.</p>
<p>The crash Code Type will be:</p>
<pre><code>Code Type:             X86-64 (Translated)</code></pre>
<p>The crash type will be <code>EXC_BAD_INSTRUCTION</code> as follows: </p>
<pre><code>Exception Type:        EXC_BAD_INSTRUCTION (SIGILL)
Exception Codes:       0x0000000000000001, 0x0000000000000000
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Illegal instruction: 4
Termination Reason:    Namespace SIGNAL, Code 0x4
Terminating Process:   exc handler [26823]</code></pre>
<p>The thread state upon crash in our case is:</p>
<pre><code>Thread 0 crashed with X86 Thread State (64-bit):
  rax: 0x0000000000000001  rbx: 0x0000600001fcf5c0  rcx:
 0x00007f87d143f8c0  rdx: 0x00007f87d143f8c0
  rdi: 0x00000001047d6fa0  rsi: 0x00000001047d770a  rbp:
 0x000000030d132ab0  rsp: 0x000000030d132ab0
   r8: 0x0000000000000003   r9: 0x0000000104b0e000  r10:
 0x00000001047dc702  r11: 0x00000001047d57d0
  r12: 0x00006000012d5100  r13: 0x00007fff6a9d4000  r14:
 0x00007f87d143f8c0  r15: 0x00000001047d770a
  rip: 0x00000001047d56cb  rfl: 0x0000000000000206</code></pre>
<p>The application binary (program text) is loaded as follows:</p>
<pre><code>Binary Images:
       0x1047d4000 -        0x1047d7fff
 +perivalebluebell.com.icdab-avx (1.0 - 1)
 &lt;3D9E0DED-2C66-30EE-AC6C-7C426246332E&gt;
 /Users/USER/Desktop/*/icdab_avx.app/Contents/MacOS/icdab_avx</code></pre>
<p>If we see that an Apple Silicon Mac has crashed our app in this way, we could quickly search for any vector instructions if we have such a suspicion.</p>
<pre><code># objdump -d icdab_avx.app/Contents/MacOS/icdab_avx | grep vmov |
 head
100004527: c5 fa 10 84 24 a4 00 00 00      vmovss    164(%rsp),
 %xmm0
100004530: c5 fa 10 8c 24 a0 00 00 00      vmovss    160(%rsp),
 %xmm1
10000453f: c5 fa 10 8c 24 a8 00 00 00      vmovss    168(%rsp),
 %xmm1
10000454e: c5 fa 10 8c 24 ac 00 00 00      vmovss    172(%rsp),
 %xmm1
10000455d: c5 fa 10 8c 24 b4 00 00 00      vmovss    180(%rsp),
 %xmm1
100004566: c5 fa 10 94 24 b0 00 00 00      vmovss    176(%rsp),
 %xmm2
100004575: c5 fa 10 94 24 b8 00 00 00      vmovss    184(%rsp),
 %xmm2
100004584: c5 fa 10 94 24 bc 00 00 00      vmovss    188(%rsp),
 %xmm2
100004593: c5 f8 29 8c 24 90 00 00 00      vmovaps    %xmm1,
 144(%rsp)
10000459c: c5 f8 29 84 24 80 00 00 00      vmovaps    %xmm0,
 128(%rsp)</code></pre>
<p>However, to be more precise, we can make use of the instruction pointer at the time of the crash. We see that from the crashed thread state, we have:</p>
<pre><code>  rip: 0x00000001047d56cb  rfl: 0x0000000000000206</code></pre>
<p>and we see from Binary Images, the program was loaded at address <code>0x1047d4000</code>.</p>
<p>Using the techniques we explored in the <em>Symbolification</em> chapter, we can load up the icdab_avx binary in Hopper, change the base address of the binary to <code>0x1047d4000</code> and then goto the instruction pointer, <code>rip</code>, address <code>0x00000001047d56cb</code>.</p>
<p>We then see the assembly dump:</p>
<pre><code>_compute_delta:
push       rbp          ; CODE
 XREF=_$s9icdab_avx14ViewControllerC31runVectorOperationsButtonAc
tionyySo12NSButtonCellCF+32
mov        rbp, rsp
and        rsp, 0xffffffffffffffe0
sub        rsp, 0x160
mov        dword [rsp+0x160+var_A4], 0x40000000
mov        dword [rsp+0x160+var_A8], 0x40800000
mov        dword [rsp+0x160+var_AC], 0x40c00000
mov        dword [rsp+0x160+var_B0], 0x41000000
mov        dword [rsp+0x160+var_B4], 0x41200000
mov        dword [rsp+0x160+var_B8], 0x41400000
mov        dword [rsp+0x160+var_BC], 0x41600000
mov        dword [rsp+0x160+var_C0], 0x41800000
vmovss     xmm0, dword [rsp+0x160+var_BC]
vmovss     xmm1, dword [rsp+0x160+var_C0]</code></pre>
<p>So we didn’t land on the exact instruction that failed, but we did land on the function at fault, <code>compute_delta</code>, which looks to have been inlined in this Release binary due to it being within the <code>runVectorOperationsButtonAction</code> method. Nevertheless, we’ve been given enough help to be able to explore the binary in the relevant area and establish confirmation that the vector operation, <code>vmovss</code> was called. This is not supported by Rosetta.</p>
<p>Our original code that caused the issue was:</p>
<pre><code>void
compute_delta() {
    /* Initialize the two argument vectors */
    __m256 evens = _mm256_set_ps(2.0, 4.0, 6.0, 8.0, 10.0, 12.0,
 14.0, 16.0);
    __m256 odds = _mm256_set_ps(1.0, 3.0, 5.0, 7.0, 9.0, 11.0,
 13.0, 15.0);
    
    /* Compute the difference between the two vectors */
    __m256 result = _mm256_sub_ps(evens, odds);
    
    /* Display the elements of the result vector */
    float* f = (float*)&amp;result;
    printf(&quot;%f %f %f %f %f %f %f %f\n&quot;,
           f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]);
    
    return;
}</code></pre>
<p>In order to avoid the problem we should have used a utility function to detect if the environment supported AVX, as follows:</p>
<pre><code>bool
avx_v1_supported() {
    int ret = 0;
    size_t size = sizeof(ret);
    if (sysctlbyname(&quot;hw.optional.avx1_0&quot;, &amp;ret, &amp;size, NULL, 0)
 == -1)
    {
       if (errno == ENOENT)
          return false;
       return false;
    }
    bool supported = (ret != 0);
    return supported;
}</code></pre>
<p>This function returns <code>true</code> is AVX version 1 is supported (and there was no error in retrieving the information).</p>
<h2 id="ios-on-mac">iOS on Mac</h2>
<p>Since Apple Silicon Macs and iOS devices share the same ARM CPU architecture, Apple has made available a “bonus feature”. It is possible for unmodified iOS apps to run on ARM-based macOS. For this to work, ARM-based macOS has some special iOS support libraries.</p>
<p>The way we can think about it is that macOS is the <em>host</em> that provides support libraries and frameworks, such as <code>UIKit</code>, that iOS <em>guest</em> apps expect to be in place.</p>
<p>When such an app crashes, we get a crash report that is a macOS crash report, but most of the details involve iOS libraries.</p>
<h3 id="icdab_wrap-ios-app-crash-on-macos"><code>icdab_wrap</code> iOS app crash on macOS</h3>
<p>If we run the <code>icdab_wrap</code> iOS app natively on an Apple Silicon Mac, it will launch because macOS provides the <code>UIKit</code> framework that <code>icdab_wrap</code> assumes is present. This app is written to demonstrate a problem when a nil optional is dereferenced.</p>
<p>Upon crash, we see:</p>
<pre><code>Code Type:             ARM-64 (Native)
Parent Process:        ??? [1]
Responsible:           icdab_wrap [2802]
User ID:               501</code></pre>
<p>This shows that the application was running native code, not translated code.</p>
<pre><code>Date/Time:             2020-11-14 11:58:17.668 +0000
OS Version:            Mac OS X 10.16 (20A5343i)
Report Version:        12
Anonymous UUID:        0118DF8D-2876-0263-8668-41B1482DDC38</code></pre>
<p>This shows we were obviously running on a Mac.</p>
<pre><code>System Integrity Protection: enabled

Crashed Thread:        0  Dispatch queue: com.apple.main-thread

Exception Type:        EXC_BREAKPOINT (SIGTRAP)
Exception Codes:       EXC_ARM_BREAKPOINT at 0x00000001c6c8f1f0
 (brk 1)
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Trace/BPT trap: 5
Termination Reason:    Namespace SIGNAL, Code 0x5
Terminating Process:   exc handler [2802]

Application Specific Information:
dyld3 mode
Fatal error: Unexpectedly found nil while implicitly unwrapping
 an Optional value: file icdab_wrap/PlanetViewController.swift,
 line 45</code></pre>
<p>This shows the program crashed unwrapping a nil optional.</p>
<pre><code>Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libswiftCore.dylib                  0x00000001c6c8f1f0
 closure #1 in closure #1 in closure #1 in
 _assertionFailure(_:_:file:line:flags:) + 404
1   libswiftCore.dylib                  0x00000001c6c8f1f0
 closure #1 in closure #1 in closure #1 in
 _assertionFailure(_:_:file:line:flags:) + 404
2   libswiftCore.dylib                  0x00000001c6c8e660
 _assertionFailure(_:_:file:line:flags:) + 488
3   www.perivalebluebell.icdab-wrap     0x0000000104937da4
 PlanetViewController.imageDownloaded(_:) + 196
 (PlanetViewController.swift:45)
.
.
.

16  com.apple.AppKit                    0x0000000189740824
 _DPSNextEvent + 880
17  com.apple.AppKit                    0x000000018973f1fc
 -[NSApplication(NSEvent)
 _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1300
18  com.apple.AppKit                    0x00000001897313c4
 -[NSApplication run] + 600
19  com.apple.AppKit                    0x0000000189703550
 NSApplicationMain + 1064
20  com.apple.AppKit                    0x00000001899e92f8
 _NSApplicationMainWithInfoDictionary + 24
21  com.apple.UIKitMacHelper            0x00000001bd9a6038
 UINSApplicationMain + 476
22  com.apple.UIKitCore                 0x00000001d333d1b0
 UIApplicationMain + 2108
23  www.perivalebluebell.icdab-wrap     0x0000000104933a38 main +
 88 (AppDelegate.swift:12)
24  libdyld.dylib                       0x00000001c758ca50 start
 + 4</code></pre>
<p>This shows that when the program was loaded by <code>libdyld.dylib</code>, the UIKit it expected, <code>UIKitCore</code>, was implemented via <code>UIKitMacHelper</code> support layer.</p>
<pre><code>Binary Images:
       0x10492c000 -        0x10493bfff
 +www.perivalebluebell.icdab-wrap (1.0 - 1)
 &lt;E9A2E2CC-E879-37B0-820C-F336DF2AACDA&gt;
 /Users/USER/Library/Developer/Xcode/DerivedData/icdab-gbtgrhpqeh
gqogaglrpuvzajteku/Build/Products/Debug-iphoneos/icdab_wrap.app/i
cdab_wrap
       0x104a1c000 -        0x104a27fff 
 libobjc-trampolines.dylib (817)
 &lt;4A2C66DE-9358-3AE9-A69F-36687DB19CE3&gt;
 /usr/lib/libobjc-trampolines.dylib
       0x104b34000 -        0x104baffff  dyld (828)
 &lt;7A9F335B-50E3-3018-A9CC-26E57B61D907&gt; /usr/lib/dyld
.
.

       0x189700000 -        0x18a400fff  com.apple.AppKit (6.9 -
 2004.102) &lt;96941AAC-01D7-36E7-9253-2C1187864719&gt;
 /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit
.
.

       0x1bd77f000 -        0x1bd9a1fff  com.apple.UIFoundation
 (1.0 - 714) &lt;D3335C2E-2366-30AD-A5F3-6058164D69EE&gt;
 /System/Library/PrivateFrameworks/UIFoundation.framework/Version
s/A/UIFoundation
       0x1bd9a2000 -        0x1bda37fff  com.apple.UIKitMacHelper
 (1.0 - 3979.1.400) &lt;F2F6D8F7-8178-3113-856E-F99614A4F13E&gt;
 /System/Library/PrivateFrameworks/UIKitMacHelper.framework/Versi
ons/A/UIKitMacHelper
       0x1bda38000 -        0x1bda4bfff  com.apple.UIKitServices
 (1.0 - 1) &lt;D8C4D101-A04C-37E6-87A3-6AD9ADFEC787&gt;
 /System/Library/PrivateFrameworks/UIKitServices.framework/Versio
ns/A/UIKitServices
.
.

       0x1c9b1b000 -        0x1c9b1bfff 
 com.apple.MobileCoreServices (1112.0.10 - 1112.0.10)
 &lt;992DAEC7-6964-3686-A910-4365B353D925&gt;
 /System/iOSSupport/System/Library/Frameworks/MobileCoreServices.
framework/Versions/A/MobileCoreServices
.
.

       0x1d333a000 -        0x1d462ffff  com.apple.UIKitCore (1.0
 - 3979.1.400) &lt;023078DD-44DA-3A11-82CA-12F8412661A2&gt;
 /System/iOSSupport/System/Library/PrivateFrameworks/UIKitCore.fr
amework/Versions/A/UIKitCore
.
.

       0x1d72fa000 -        0x1d7337fff  libswiftUIKit.dylib (15)
 &lt;68377BCA-6493-3E34-920E-0765BD07F2A7&gt;
 /System/iOSSupport/usr/lib/swift/libswiftUIKit.dylib</code></pre>
<p>The above sample of binaries shows that both AppKit and UIKit are present and the system is providing support frameworks in order to allow iOS apps to see the frameworks they are expecting.</p>
<p>For the most part, these crashes can be analyzed as if they were straightforward crashes on iOS. The more likely problem area is one of assumptions about the environment. For example, iOS devices have a gyroscope but macOS devices do not.</p>
<h3 id="supporting-the-mac-from-ios">Supporting the Mac from iOS</h3>
<p>Apple provide guidance on best practice when deploying iOS apps on Mac; <span class="citation" data-cites="iosOnMac">(“Running Your iOS Apps on macOS” 2020)</span>. The choices would be:</p>
<ol type="1">
<li>Decide that the iOS app is not suitable for macOS. In App Store Connect it can be de-configured.</li>
<li>Allow the app to be installed on iOS but add checks for available optional hardware functionality.</li>
<li>Enhance the app to use alternate features more accessible to Mac users. For example, add iOS keyboard support.</li>
<li>Add code to detect the iOS-on-Mac scenario. </li>
<li>Do a port to Mac, via Mac Catalyst  technology. This would first mean having a great iPadOS app as a starting point.</li>
<li>Write a native macOS app.</li>
</ol>
<p>For example, in the app <code>icdab_gyro</code> we show how to detect the iOS-on-Mac scenario:</p>
<pre><code>        let info = ProcessInfo()
        if #available(iOS 14.0, *) {
            if info.isiOSAppOnMac {
                print(&quot;We are an iOS app running on a Mac&quot;)
            }
        }</code></pre>
<p>Furthermore, when using the Gyroscope, we have</p>
<pre><code>var motion = CMMotionManager()</code></pre>
<p>and use the gyroscope only if available:</p>
<pre><code>if motion.isGyroAvailable {
          self.motion.gyroUpdateInterval = 1.0 / 60.0
          self.motion.startGyroUpdates()
.
.</code></pre>
<h1 id="pointer-authentication">Pointer Authentication</h1>
<p>In this chapter we shall examine Pointer Authentication, and related crashes.</p>
<p>Devices using the Apple A12 chip, or later, utilize a security feature known as <em>Pointer Authentication</em> as part of the ARMv8.3-A architecture. For example, iPhone XS, iPhone XS Max, and iPhone XR use the A12 chip. The basic idea is that there are unused bits in a 64-bit pointer because it can already address such a vast range of addresses, only 40 bits are allocated to such purposes. <span class="citation" data-cites="iospac">(“Examining Pointer Authentication on the iPhone Xs” 2019)</span> The remaining bits can therefore be used to store a hash value computed after combining the intended pointer address with a context value and a secret key. Then if the pointer address were to be changed, either because of a bug or malicious action, the pointer would be known to be invalid and would eventually cause a <code>SIGSEGV</code> if it were to be used to change the control flow of a program.</p>
<p>In actual fact, Pointer Authentication is used in a number of scenarios, such as ensuring C++ virtual dispatch tables have not been tampered with. But we shall look only at the simple case of an incorrectly manipulated jump address.</p>
<h2 id="configuring-pointer-authentication">Configuring Pointer Authentication</h2>
<p>Pointer Authentication is enabled by Apple in the kernel on Devices using the A12 chip, and newer. For user space code, Pointer Authentication is an opt-in feature. It can be enabled via the Build Settings for the project as seen here in Figure <em>Enable Pointer Authentication</em> for <code>icdab_ptr</code> <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span> We add Architecture <code>arm64e</code> to the Architectures setting.</p>
<figure>
<img src="screenshots/enable_ptr_auth.png" alt="Enable Pointer Authentication" /><figcaption aria-hidden="true">Enable Pointer Authentication</figcaption>
</figure>
<p>If we are writing security sensitive software, it is worthwhile being an early adopter of this feature.</p>
<h2 id="manipulating-pointers">Manipulating Pointers</h2>
<p>Let us consider the following program which manipulates pointers, albeit in an artificial way, to expose some of the ideas behind pointer authentication.</p>
<pre><code>#import &quot;ViewController.h&quot;

#include &quot;ptrauth.h&quot;

@interface ViewController ()

@end

@implementation ViewController

typedef void(*ptrFn)(void);

static void interestingJumpToFunc(void) {
    NSLog(@&quot;Simple interestingJumpToFunc\n&quot;);
}

// this function&#39;s address is where we will be jumping to
static void nextInterestingJumpToFunc(void) {
    NSLog(@&quot;Simple nextInterestingJumpToFunc\n&quot;);
}

- (void)viewDidLoad {
    [super viewDidLoad];
    ptrFn result = [self generatePtrToFn];
    NSLog(@&quot;ptrFn result is %p\n&quot;, result);
    result(); // will crash; deferences a pointer with a bad PAC
}

- (ptrFn)generatePtrToFn {
    uintptr_t a1 = (uintptr_t)interestingJumpToFunc;
    uintptr_t a2 = (uintptr_t)nextInterestingJumpToFunc;
    NSLog(@&quot;ptr addresses as uintptr_t are 0x%lx 0x%lx\n&quot;,
          a1, a2);
    ptrdiff_t delta = a2 - a1;
    ptrdiff_t clean_delta =
    ptrauth_strip(&amp;nextInterestingJumpToFunc,
                  ptrauth_key_asia) -
    ptrauth_strip(&amp;interestingJumpToFunc,
                  ptrauth_key_asia);
    
    NSLog(@&quot;delta is 0x%lx clean_delta is 0x%tx\n&quot;, delta,
 clean_delta);
    
    ptrFn func = interestingJumpToFunc;
    func += clean_delta; // correct offset but neglects PAC
 component
    return func;
}</code></pre>
<p>If we run the above program, we get a crash. The logging output of the program is:</p>
<pre><code>ptr addresses as uintptr_t are 0x2946180102c55dd8
 0x22b810102c55df8
delta is 0xd8e5690000000020 clean_delta is 0x20
ptrFn result is 0x2946180102c55df8</code></pre>
<p>We see that when a pointer to function, <code>interestingJumpToFunc</code>, is obtained, and then stored in an integer big enough to hold a pointer address, we get a large value, <code>0x2946180102c55dd8</code>. That is because the top 24 bits of the address are the Pointer Authentication Code (PAC). The PAC in this instance is <code>0x294618</code> and the effective pointer is <code>0x0102c55dd8</code>.</p>
<p>The next pointer, which is physically adjacent, <code>nextInterestingJumpToFunc</code> is <code>0x22b810102c55df8</code>; clearly it shares a similar effective address, <code>0x0102c55df8</code>, but has an entirely different PAC, <code>0x22b81</code>.</p>
<p>When we compute the delta between the pointers, we will clearly get a nonsense address because of the PAC portion of the value of the pointers. In order to correctly calculate the delta between the effective address of the pointers, we need to use the <code>ptrauth_strip</code> utility function. This is implemented as a built-in macro assembly instruction.</p>
<p>After macro preprocessing, the code is:</p>
<pre><code>ptrdiff_t clean_delta =
    __builtin_ptrauth_strip(&amp;nextInterestingJumpToFunc,
 ptrauth_key_asia) -

    __builtin_ptrauth_strip(&amp;interestingJumpToFunc,
 ptrauth_key_asia);</code></pre>
<p>The assembly instructions produced are of the form:</p>
<pre><code>    xpaci   x9</code></pre>
<p>when the <code>__builtin_ptrauth_strip</code> strip function is used. This removes the PAC from a register, in this case <code>x9</code>.</p>
<p>The benefit of using the strip functions was that we are able to correctly determine the distance between the two functions of interest. It is <code>0x20</code>. Our function <code>generatePtrToFn</code> essentially just adds the delta onto the address of <code>interestingJumpToFunc</code> to calculate the address of <code>nextInterestingJumpToFunc</code>, but it does it erroneously; it leaves the PAC for <code>interestingJumpToFunc</code> in the address it has calculated.</p>
<p>Notice none of this pointer manipulation causes a crash. The time of checking the pointer is when it is used for changing the link register. That is, when we act upon the pointer value to change the control flow of the program.</p>
<p>In the function <code>viewDidLoad()</code> when have the code</p>
<pre><code>result(); // will crash; deferences a pointer with a bad PAC</code></pre>
<p>The pointer used is our bad pointer <code>0x2946180102c55df8</code>. The bad pointer is detected by the assembly instruction</p>
<pre><code>blraaz  x8</code></pre>
<p>This is Branch with Link to Register, with pointer authentication using Instruction Key A.</p>
<p>Note that when we were stripping the pointer, we used <code>ptrauth_key_asia</code> to remove Instruction Key A. However, we do not have access to the special values needed to do the reverse, to sign a pointer with Instruction Key A with the appropriate “salt” values to get a contextually correct signed pointer.</p>
<p>Now that we have examined our faulty code, let us look what happens when it crashes.</p>
<h2 id="icdab_ptr-pac-crash"><code>icdab_ptr</code> PAC crash</h2>
<p>On an iPhone 11, which has an A13 Bionic chip, we see the following crash when running the <code>icdab_ptr</code> program. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<pre><code>Incident Identifier: DA9FE0C7-6127-4660-A214-5DF5D432DBD9
CrashReporter Key:   d3e622273dd1296e8599964c99f70e07d25c8ddc
Hardware Model:      iPhone12,1
Process:             icdab_ptr [2125]
Path:               
 /private/var/containers/Bundle/Application/32E9356D-AF19-4F30-BB
87-E4C056468063/icdab_ptr.app/icdab_ptr
Identifier:          perivalebluebell.com.icdab-ptr
Version:             1 (1.0)
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           perivalebluebell.com.icdab-ptr [1288]

Date/Time:           2020-10-14 23:09:20.9645 +0100
Launch Time:         2020-10-14 23:09:20.6958 +0100
OS Version:          iPhone OS 14.2 (18B5061e)
Release Type:        Beta
Baseband Version:    2.02.00
Report Version:      104

Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x2000000100ae9df8 -&gt;
 0x0000000100ae9df8 (possible pointer authentication failure)
VM Region Info: 0x100ae9df8 is in 0x100ae4000-0x100aec000;  bytes
 after start: 24056  bytes before end: 8711
      REGION TYPE                 START - END      [ VSIZE]
 PRT/MAX SHRMOD  REGION DETAIL
      UNUSED SPACE AT START
---&gt;  __TEXT                   100ae4000-100aec000 [   32K]
 r-x/r-x SM=COW  ...app/icdab_ptr
      __DATA_CONST             100aec000-100af0000 [   16K]
 r--/rw- SM=COW  ...app/icdab_ptr

Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [2125]
Triggered by Thread:  0

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   icdab_ptr                           0x0000000100ae9df8
 nextInterestingJumpToFunc + 24056 (ViewController.m:26)
1   icdab_ptr                           0x0000000100ae9cf0
 -[ViewController viewDidLoad] + 23792 (ViewController.m:35)
2   UIKitCore                           0x00000001aca4cda0
 -[UIViewController
 _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 108
3   UIKitCore                           0x00000001aca515fc
 -[UIViewController loadViewIfRequired] + 956
4   UIKitCore                           0x00000001aca519c0
 -[UIViewController view] + 32
.
.

Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x0000000103809718   x1: 0x0000000103809718   x2:
 0x0000000000000000   x3: 0x00000000000036c8
    x4: 0x00000000000062dc   x5: 0x000000016f319b20   x6:
 0x0000000000000031   x7: 0x0000000000000700
    x8: 0x045d340100ae9df8   x9: 0x786bdebd0a110081  x10:
 0x0000000103809718  x11: 0x00000000000007fd
   x12: 0x0000000000000001  x13: 0x00000000d14208c1  x14:
 0x00000000d1621000  x15: 0x0000000000000042
   x16: 0xe16d9e01bf21b57c  x17: 0x00000002057e0758  x18:
 0x0000000000000000  x19: 0x0000000102109620
   x20: 0x0000000000000000  x21: 0x0000000209717000  x22:
 0x00000001f615ffcb  x23: 0x0000000000000001
   x24: 0x0000000000000001  x25: 0x00000001ffac7000  x26:
 0x0000000282c599a0  x27: 0x00000002057a44a8
   x28: 0x00000001f5cfa024   fp: 0x000000016f319dd0   lr:
 0x0000000100ae9cf0
    sp: 0x000000016f319da0   pc: 0x0000000100ae9df8 cpsr:
 0x60000000
   esr: 0x82000004 (Instruction Abort) Translation fault

Binary Images:
0x100ae4000 - 0x100aebfff icdab_ptr arm64e 
 &lt;83e44566e30039258fd14db647344501&gt;
 /var/containers/Bundle/Application/32E9356D-AF19-4F30-BB87-E4C05
6468063/icdab_ptr.app/icdab_ptr</code></pre>
<p>Firstly, we notice that the point at which we crashed was <code>ViewController.m:26</code> from</p>
<pre><code>0   icdab_ptr                           0x0000000100ae9df8
 nextInterestingJumpToFunc + 24056 (ViewController.m:26)</code></pre>
<p>Our source code has:</p>
<pre><code>24 // this function&#39;s address is where we will be jumping to
25 static void nextInterestingJumpToFunc(void) {
26     NSLog(@&quot;Simple nextInterestingJumpToFunc\n&quot;);
27 }</code></pre>
<p>The purpose of the program was to calculate the address of the <code>nextInterestingJumpToFunc</code> function by means of pointer arithmetic and then jump to it. It managed to do so but then crashed. We know from the previous section that this was because we deliberately used the function address PAC borrowed from the <code>interestingJumpToFunc</code> function.</p>
<p>The crash reporting system demangles the pointer understanding what the effective pointer address is given the faulty pointer. We have:</p>
<pre><code>Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x2000000100ae9df8 -&gt;
 0x0000000100ae9df8 (possible pointer authentication failure)
VM Region Info: 0x100ae9df8 is in 0x100ae4000-0x100aec000;  bytes
 after start: 24056  bytes before end: 8711
      REGION TYPE                 START - END      [ VSIZE]
 PRT/MAX SHRMOD  REGION DETAIL
      UNUSED SPACE AT START
---&gt;  __TEXT                   100ae4000-100aec000 [   32K]
 r-x/r-x SM=COW  ...app/icdab_ptr
      __DATA_CONST             100aec000-100af0000 [   16K]
 r--/rw- SM=COW  ...app/icdab_ptr</code></pre>
<p>Our pointer, <code>0x2000000100ae9df8</code> points to the text region of the program at <code>0x0000000100ae9df8</code> but the upper 24 bits of the pointer are incorrect, hence the message <code>(possible pointer authentication failure)</code> and this results in the <code>SIGSEGV</code>. Notice the PAC is a special value <code>0x200000</code> which presumably the value representing <code>invalid PAC</code>.</p>
<p>From the previous section, we know that the code which checks the PAC in our program is:</p>
<pre><code>blraaz  x8</code></pre>
<p>Our <code>x8</code> register was <code>0x045d340100ae9df8</code> so presumably the faulty PAC was <code>0x045d34</code>.</p>
<h2 id="pointer-authentication-debugging-tips">Pointer Authentication Debugging Tips</h2>
<p>In this section we point out some differences when running the debugger on a Architecture <code>armv8e</code> target. We also show how to match a crash report to a debugging session.</p>
<p>When we print out pointers, we get the pointer with the PAC value stripped out. For example, for a pointer <code>0x36f93010201ddf8</code>, our <code>result</code> variable, we would get:</p>
<pre><code>(lldb) po result
(actual=0x000000010201ddf8 icdab_ptr`nextInterestingJumpToFunc at
 ViewController.m:25)</code></pre>
<p>This value is from the execution that produced the following output</p>
<pre><code>ptr addresses as uintptr_t are 0x36f93010201ddd8
 0xc7777b010201ddf8
delta is 0xc407e80000000020 clean_delta is 0x20
ptrFn result is 0x36f93010201ddf8</code></pre>
<p>Whilst we are attached via the debugger, we don’t see the crash dump report. However, if we detach our debugger:</p>
<pre><code>(lldb) detach</code></pre>
<p>the system will continue on, and perform a crash, and then generate a report.</p>
<pre><code>Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x200000010201ddf8 -&gt;
 0x000000010201ddf8 (possible pointer authentication failure)
VM Region Info: 0x10201ddf8 is in 0x10201c000-0x102020000;  bytes
 after start: 7672  bytes before end: 8711
      REGION TYPE                 START - END      [ VSIZE]
 PRT/MAX SHRMOD  REGION DETAIL
      __TEXT                   102018000-10201c000 [   16K]
 r-x/r-x SM=COW  ...app/icdab_ptr
---&gt;  __TEXT                   10201c000-102020000 [   16K]
 r-x/rwx SM=COW  ...app/icdab_ptr
      __DATA_CONST             102020000-102024000 [   16K]
 r--/rw- SM=COW  ...app/icdab_ptr

Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [2477]
Triggered by Thread:  0

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   icdab_ptr                       0x000000010201ddf8
 nextInterestingJumpToFunc + 24056 (ViewController.m:25)
1   icdab_ptr                       0x000000010201dcf0
 -[ViewController viewDidLoad] + 23792 (ViewController.m:34)
2   UIKitCore                       0x00000001aca4cda0
 -[UIViewController
 _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 108
3   UIKitCore                       0x00000001aca515fc
 -[UIViewController loadViewIfRequired] + 956
4   UIKitCore                       0x00000001aca519c0
 -[UIViewController view] + 32
.
.

Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x000000010c80a738   x1: 0x000000010c80a738   x2:
 0x000000000000000d   x3: 0x0000000000000000
    x4: 0x000000016dde59b8   x5: 0x0000000000000040   x6:
 0x0000000000000033   x7: 0x0000000000000800
    x8: 0x036f93010201ddf8   x9: 0xb179df14ab2900d1  x10:
 0x000000010c80a738  x11: 0x00000000000007fd
   x12: 0x0000000000000001  x13: 0x00000000b3e33897  x14:
 0x00000000b4034000  x15: 0x0000000000000068
   x16: 0x582bcd01bf21b57c  x17: 0x00000002057e0758  x18:
 0x0000000000000000  x19: 0x000000010be0d760
   x20: 0x0000000000000000  x21: 0x0000000209717000  x22:
 0x00000001f615ffcb  x23: 0x0000000000000001
   x24: 0x0000000000000001  x25: 0x00000001ffac7000  x26:
 0x0000000280436140  x27: 0x00000002057a44a8
   x28: 0x00000001f5cfa024   fp: 0x000000016dde5b60   lr:
 0x000000010201dcf0
    sp: 0x000000016dde5b30   pc: 0x000000010201ddf8 cpsr:
 0x60000000
   esr: 0x82000004 (Instruction Abort) Translation fault</code></pre>
<p>This approach is handy because then we can directly correlate the crash dump report to our analysis in the debugger. Notice that the <code>x8</code> register is exactly the <code>result</code> value we explored earlier.</p>
<h1 id="analytic-troubleshooting">Analytic Troubleshooting</h1>
<p>This chapter discusses a formal technique for solving problems. The idea is to provide a framework that prompts the right questions to be asked.</p>
<p>There is a famous phrase cautioning us on taking an overzealous approach:</p>
<blockquote>
<p>“Don’t use a sledgehammer to crack a nut.”</p>
</blockquote>
<p>Most problems have a direct and obvious way forward to progress towards their resolution. As engineers, developers, and testers, we are well acquainted with such problem solving. This chapter does not concern those types of problems.</p>
<p>There is another less well-known phrase:</p>
<blockquote>
<p>“When you hold a hammer, everything looks like a nail.”</p>
</blockquote>
<p>A hammer is best for hammering in nails, and smashing things generally, but not useful for other types of task. A hammer is a solution to a restricted set of problems. Furthermore, our way of thinking about problems is framed by the available tools at our disposal. If we increase the available tools, we can start thinking about problems in different ways, one of which may lead to the answers we desire.</p>
<p>Suppose we had a spanner and a hacksaw in our toolbox. We wanted to remove an old bathroom fitting held in place with rusty bolts. Using the spanner might not work, due to the bolts not turning. However, using a hack saw to remove the bolt heads might be a workable next best solution. Observing an experienced plumber, or mechanic, reveals such tricks of the trade.</p>
<p>In this context, we introduce “Analytic Troubleshooting”. <span class="citation" data-cites="kepnertregoe">(“Analytic Troubleshooting” 2018)</span> This will help us move forwards on problems when the obvious things have already been tried, and we are running out of ideas.</p>
<p>This methodology is a cut-down version of that taught by Kepner Tregoe.</p>
<h2 id="prioritizing-our-problem">Prioritizing our problem</h2>
<p>If we are a sole developer of an app, perhaps with a few customers, and receive a Crash Report, it can feel like we are being offered a curious intellectual challenge.</p>
<p>In a professional software engineering context, the reality is starkly different. There is typically a team of people involved, we are some levels removed from the customer, and there are many different Crash Reports from different customers, for different products and product variants.</p>
<p>We have to prioritize which crash to work on. We can consider three different aspects of the problem: Seriousness, Urgency and Growth.</p>
<h3 id="prioritizing-based-upon-impact">Prioritizing based upon impact</h3>
<p>In many development teams, crashes are considered top-priority “P1” bugs because the customer can no longer do anything further with the app. To judge the seriousness of the bug, we need to assess the <strong>impact</strong> of the bug. What use cases were being done at the time of the problem?</p>
<p>If the customer is in the middle of doing an e-commerce purchase, then clearly revenue is at stake if the problem is not solved.</p>
<p>If whilst updating our privacy settings, we see a crash, we have a privacy issue. Depending on the type of market we are operating in, that could be a major problem.</p>
<p>One way to assess impact is to build analytics into our app. Then the set of steps, and more broadly, the customer use case, can be studied alongside the crash. Crashes from the most important use cases can then be identified as high impact bugs to fix. One advantage of third party crash reporting services is that they allow logs to be recorded that are delivered to the Crash Report server along with the crash.</p>
<p>The following are good places to introduce a log message:</p>
<ul>
<li>any time a life-cycle event occurs, such as foregrounding, backgrounding, appearing, disappearing,</li>
<li>button clicks,</li>
<li>segues,</li>
<li>notifications,</li>
<li>alert pop ups,</li>
<li>launching helper components such as the photo picker.</li>
</ul>
<h3 id="prioritizing-based-upon-deadlines">Prioritizing based upon deadlines</h3>
<p>To judge the urgency of a bug fix, we need to assess the <strong>deadline</strong> associated with the bug. Whenever Apple updates their product line, for example, historically iPhone is updated in September, then a natural product lifecycle cadence is seen in the market. New customers will come to the App Store to provision new apps. There will be a lot of discussion about Apple product features in the press. Consequently, it becomes a good market window to target. Any crash that prevents app store approval or app first time use issues becomes more important at this time. Occasionally, Apple introduces a new app category, for example watch apps, or sticker packs. Being available on the first day provides a first-mover advantage, and the possibility of being featured as part of the Apple launch event.</p>
<h3 id="prioritizing-based-upon-trend">Prioritizing based upon trend</h3>
<p>The growth in the number of Crash Reports we see can be alarming, and needs to be assessed by analyzing the <strong>trend</strong>. We can see how many Crash Reports we get over time, and see if there is a spike, or an upward trend.</p>
<p>If our app crashes due to features in a new major release of iOS then the first people to experience the problem are early adopters of the beta releases of iOS. After that, iOS devices will start being automatically upgraded. Sometimes the new version of iOS is released in geographic staggered updates. We would expect to see this reflected in the trend we see amongst our Crash Reports.</p>
<p>If we see a spike (a sharp rise and then a sharp fall) in our Crash Reports, then there may be other factors of components of the system architecture in play. For example, if our app relies on a back-end server that is updated in a problematic way for our app, we could see crashes until the server has been fixed.</p>
<p>The timing of problems can be awkward. For example, when dealing with security credentials such as certificates, it is best to set their expiry date to not being during traditional vacation periods (such as Christmas or Chinese New Year) because when they expire, there might be few staff available to rectify the problem.</p>
<p>It is bad practice to release a major software update prior to a popular vacation period. If our market opportunity requires the product be released for a vacation period, staffing needs to be setup to accommodate potential problems.</p>
<p>Keeping an eye on trends allows us to schedule work to fix problems before they become widespread amongst our customers. Different apps have different risk profiles. For example, a Mobile Device Management API sensitive app should be tested with Beta versions of iOS because at the systems level, subtle changes can have dramatic impact and need to be picked up early. If we have a graphics sensitive app, then we should keep an eye on new hardware devices, hardware specification updates, and we should have a test suite that exercises the key APIs in the platform we depend upon, so a new OS version, or hardware platform, can be quickly assessed.</p>
<p>The Crash Report trend need not be adverse. If an unusual crash is seen only on older hardware, then we expect the trend to be downwards over time, so it might be possible to de-prioritize such crashes.</p>
<h2 id="stating-the-problem">Stating the problem</h2>
<p>The information we have for a crash: the Crash Report, customer logs, analytic data etc. should be summarized into an OBJECT / DEFECT style short problem statement. This is often a critical first step in triaging a potentially large number of Crash Reports. This gives us a first level approximation of what is at hand and allows managers and other interested parties to get a feel for where we are with product quality, maturity, risks, etc.</p>
<p>First, we state the object of the problem. That is the app, or product, that is failing. Then, we state the defect. That is the “undesirable behavior” we see. It should be as simple as “CameraApp Lite crashes during the Apple Share button is used”. The problem should be tracked in a bug management system.</p>
<h2 id="specifying-the-problem">Specifying the problem</h2>
<p>Specifying the problem is the most important step in the Analytic Troubleshooting methodology because here we see the gaps in our knowledge, and that prompts the questions that lead us forwards to a resolution.</p>
<p>We write out a large grid with four rows and two columns as follows:</p>
<table>
<thead>
<tr class="header">
<th>Item</th>
<th>IS</th>
<th>IS NOT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WHAT</td>
<td>Seen</td>
<td>Not Seen</td>
</tr>
<tr class="even">
<td>WHERE</td>
<td>Seen</td>
<td>Not Seen</td>
</tr>
<tr class="odd">
<td>WHEN</td>
<td>Seen</td>
<td>Not Seen</td>
</tr>
<tr class="even">
<td>EXTENT</td>
<td>Seen</td>
<td>Not Seen</td>
</tr>
</tbody>
</table>
<p>Analytical Troubleshooting works well in a team setting. By having some domain experts, together with people from other disciplines, and non-technical staff, makes for a good troubleshooting team. Experts sometimes overlook asking the basic questions, and less informed staff could ask good clarifying questions that further shake out implicit assumptions in the problem specification. Hot customer problems can cause anxiety, so having the team come together to troubleshoot can ease tensions and build morale. Sometimes our customer can be invited to participate; that can often speed up the process and shake out even more assumptions.</p>
<p>When troubleshooting as a team, we can just use a whiteboard divided up into a grid as above. Each person can be given a handout that enumerates the questions to ask for each box within the grid.</p>
<p>On the web site associated with this book are support materials and handouts for Analytic Troubleshooting. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>When troubleshooting on our own, having a print out of the questions and writing up a grid of answers is a good approach. Being away from our computer, and making a list of items to check is good because it can remove the immediate impulse to dive into details. Instead, once we have our list of items for follow up, we can prioritize our work.</p>
<p>We fill out details in the IS column first. Then we fill out the IS NOT column. Often we notice a big blank area in the grid where we have no data. That is a signal for us to go and collect more data or do research. The idea is to make <em>relevant</em> differences between the IS and IS NOT columns as small as possible. This allows us to develop a good hypothesis that we can test, or perhaps a number of hypotheses we can prioritize for testing.</p>
<p>Any potential solution to the problem must entirely explain <strong>all</strong> the IS and IS NOT parts of the problem specification. Often the first solution we think of only explains part of the pattern of defects seen in the problem specification. Spending a little more time thinking about potential causes, or doing a little more research can be a good investment of time particularly if it is difficult or time-consuming to try out different candidate solutions.</p>
<p>We will have an understanding of the system specification and its behavior when operating within those constraints. In practice, the system evolves over time with new software and hardware releases. Therefore, we must keep going back to primary information sources, and perform experimentation to refine this understanding. This allows us to discover good questions, and allows us to develop a hypothesis. There is normally a positive feedback loop here between asking questions, learning about our system, and then discovering new relevant questions.</p>
<h3 id="questions-to-ask">Questions to ask</h3>
<ul>
<li>WHAT IS
<ul>
<li>What things have a problem?</li>
<li>What is wrong with them?<br />
</li>
</ul></li>
<li>WHAT IS NOT
<ul>
<li>What things could have a problem but don’t?</li>
<li>What could be wrong but is not?<br />
</li>
</ul></li>
<li>WHERE IS
<ul>
<li>When the problem was noticed, where was it geographically?</li>
<li>Where is the problem on the thing?<br />
</li>
</ul></li>
<li>WHERE IS NOT
<ul>
<li>Where could the thing be when we should have seen the problem but did not?</li>
<li>Where could the problem be on the thing but isn’t?<br />
</li>
</ul></li>
<li>WHEN IS
<ul>
<li>When was the problem first noticed?</li>
<li>When has the problem been seen again?</li>
<li>Is there any pattern in the timing?</li>
<li>When in the lifecycle of the thing was the problem first noticed?<br />
</li>
</ul></li>
<li>WHEN IS NOT
<ul>
<li>When could the problem have been noticed but wasn’t?</li>
<li>When could it have been seen again but wasn’t?</li>
<li>When else in the lifecycle of the thing could the problem be seen but wasn’t?<br />
</li>
</ul></li>
<li>EXTENT IS
<ul>
<li>How many things have the problem?</li>
<li>What is the extent of the defect?</li>
<li>How many defects are on the thing?</li>
<li>What is the trend?<br />
</li>
</ul></li>
<li>EXTENT IS NOT
<ul>
<li>How many things could have the problem but don’t?</li>
<li>What could be the extent of the problem but isn’t?</li>
<li>How many defects could be present but aren’t?</li>
<li>What could the trend be but isn’t?</li>
</ul></li>
</ul>
<h2 id="example-problem-specifications">Example problem specifications</h2>
<p>The problem specification questions seem unusual at first, and awkwardly phrased. Looking at some practical examples helps explain things more clearly. Here will use different hypothetical examples to focus in on particular questions but we don’t do the full suite of questions on any given example, for the sake of brevity.</p>
<h3 id="cameraapp-what-is-is-not-example">CameraApp What Is / Is Not Example</h3>
<p>Consider the problem “The Camera App crashes when the customer presses the Apple Share Button”</p>
<ul>
<li>WHAT IS
<ul>
<li>What things have a problem?
<ul>
<li>Version 1.4.5 of CameraApp on iOS 10.1, 10.2, 10.3.</li>
<li>On the main thread.</li>
<li>Function isAllowedToShare()</li>
<li>Apple Share Button<br />
</li>
</ul></li>
<li>What is wrong with them?
<ul>
<li>The share button causes the app to crash.<br />
</li>
</ul></li>
</ul></li>
<li>WHAT IS NOT
<ul>
<li>What things could have a problem but don’t?
<ul>
<li>Version 1.4.4 of CameraApp on iOS 9.3.5</li>
<li>The background thread never has a crash.</li>
<li>Other functions for startup and photo taking work ok.</li>
<li>Taking a photo button works.<br />
</li>
</ul></li>
<li>What could be wrong but is not?
<ul>
<li>Other buttons could cause a crash but those work ok.</li>
<li>We don’t see any system pop up errors.</li>
</ul></li>
</ul></li>
</ul>
<p>To make progress we need to match up and tighten the IS and IS NOT answers. We look at the IS NOT section first as this is often the side of the grid that is fairly empty and requires some thought and inspiration to come up with extra IS NOT answers that are relevant to the IS section.</p>
<p>The obvious thing to find out is if app version 1.4.4 works on iOS 10.x.</p>
<p>iOS 10.x is a major update to iOS 9.3.5, so its specification and requirements on apps will differ. Therefore, the next thing to look at is the “What’s New” section in the Apple documentation to see at a high level what is new in iOS 10.x over 9.x. That will prompt us to ask clarifying questions.</p>
<p>If 10.x requires apps to have certain <code>Info.plist</code> settings then in our grid above we can explain any <code>Info.plist</code> differences in our Camera App, as well as <code>Info.plist</code> differences with other Apps known to work on iOS 10.x and 9.x that do sharing.</p>
<p>In this example the share button is broken. We could get some sample code that uses the share button and see if it crashes in a similar environment to our problem. We could test the code in a standalone app, as well as grafted into our Camera App to see if it works there.</p>
<p>In this example, we only said system pop ups did not appear. How about console messages? We might find that tell us the reason why the system is crashing our app.</p>
<p>A candidate solution would be “iOS 10.x requires different <code>Info.plist</code> settings in order for sharing to work otherwise the system is specified to crash our app as we have seen.”</p>
<h3 id="imac-where-is-is-not-example">iMac Where Is / Is Not Example</h3>
<p>Consider the problem “An iMac crashes regularly needing constant hardware repair.”</p>
<ul>
<li>WHERE IS
<ul>
<li>When the problem was noticed, where was it geographically?
<ul>
<li>The Apple iMac was sitting in the first floor corner office by the window.<br />
</li>
</ul></li>
<li>Where is the problem on the thing?
<ul>
<li>The problems were electrical faults on the power supply, the screen, the main system board, and the memory chips (multiple instances of problems).<br />
</li>
</ul></li>
</ul></li>
<li>WHERE IS NOT
<ul>
<li>Where could the thing be when we should have seen the problem but did not?
<ul>
<li>The same Apple iMac was fine when it was in the basement, when it was in the IT department staging area, and when it was tested at the Apple factory.<br />
</li>
</ul></li>
<li>Where could the problem be on the thing but isn’t?
<ul>
<li>The problem could have been in software but wasn’t.</li>
<li>The problem could have been the USB peripherals but weren’t.</li>
<li>The problem could have been electrical faults in the printer, desk lamp, lights or air conditioning but wasn’t.</li>
<li>The problem could have been the laptop computer in the desk drawer but wasn’t.</li>
</ul></li>
</ul></li>
</ul>
<p>In this example, we have many items in the IS NOT column. Immediately it feels like we can think about good hypotheses consequently. Contrast this with the WHAT IS NOT section in the earlier example where we had to do a lot more research before suggesting a hypothesis.</p>
<p>We notice that only the iMac has a problem, not the printer. If we swap the location of the printer and the iMac, since they are both sensitive electronic products, we could get a good contrast between IS and IS NOT.</p>
<p>Electronic equipment can only operate within certain specified environmental conditions. Correct voltage, current, temperature, humidity, limited electromagnetic interference, etc. is needed. If we do a site survey with such a requirements specification in mind, we can discover what may be the reason for this location specific issue. We could also try with and without surge protectors since it is known that power spikes can damage electronic equipment.</p>
<h3 id="database-app-when-is-is-not-example">Database app When Is / Is Not Example</h3>
<p>Consider the problem “A database app crashes during app review”</p>
<ul>
<li>WHEN IS
<ul>
<li>When was the problem first noticed?
<ul>
<li>App store review team was the first time we found out about the problem.<br />
</li>
</ul></li>
<li>When has the problem been seen again?
<ul>
<li>The second time we submitted the app for review.<br />
</li>
</ul></li>
<li>Is there any pattern in the timing?
<ul>
<li>The problem happens at the same amount of elapsed time since launch.<br />
</li>
</ul></li>
<li>When in the lifecycle of the thing was the problem first noticed?
<ul>
<li>The problem is always during app launch.<br />
</li>
</ul></li>
</ul></li>
<li>WHEN IS NOT
<ul>
<li>When could the problem have been noticed but wasn’t?
<ul>
<li>The problem was never seen on the developer environment.<br />
</li>
</ul></li>
<li>When could it have been seen again but wasn’t?
<ul>
<li>Subsequent launches of the app were all fine also.<br />
</li>
</ul></li>
<li>When else in the lifecycle of the thing could the problem be seen but wasn’t?
<ul>
<li>When the Update button is pressed in the app, or the target database connection string is changed, the problem is not seen.</li>
</ul></li>
</ul></li>
</ul>
<p>This is clearly an app start up issue. This example highlights that sometimes questions in one area trigger questions and research in another area. How clean the environment is and what configuration state it is launched with are obvious questions for the WHAT IS / IS NOT section.</p>
<p>One clue is found in the WHEN IS NOT section. Database connection strings can be setup and re-configured. It could be that a null connection string, or absent setting, or first time use setup code is not being triggered. Maybe the code for debug builds has a hack to skip first time use workflows to speed up development of features but such features are not present in the release deployment of the app used for App Store review.</p>
<h3 id="game-app-extent-is-is-not-example">Game app Extent Is / Is Not Example</h3>
<p>Consider the problem “AlienGame performance issue/crash during playing different game levels”</p>
<ul>
<li>EXTENT IS
<ul>
<li>How many things have the problem?
<ul>
<li>500 distinct installs of the app, out of 2000 in total.<br />
</li>
</ul></li>
<li>What is the extent of the defect?
<ul>
<li>Sometimes severe; we get a crash. Sometimes mild; we get dropped frames.</li>
<li>Sometimes the frame rate stays good the whole time.<br />
</li>
</ul></li>
<li>How many defects are on the thing?
<ul>
<li>5 different types of game rendering thread end up crashing (different occasions).<br />
</li>
</ul></li>
<li>What is the trend?
<ul>
<li>A slight downward trend in number of crashes as our installed base grows.<br />
</li>
</ul></li>
</ul></li>
<li>EXTENT IS NOT
<ul>
<li>How many things could have the problem but don’t?
<ul>
<li>It could be all installs, or no installs that have a problem, but we see 25%.</li>
</ul></li>
<li>What could be the extent of the problem but isn’t?
<ul>
<li>We never see the frame rate drop and then improve.</li>
<li>We never see good installs ever hitting the crash problem or dropped frame problem.<br />
</li>
</ul></li>
<li>How many defects could be present but aren’t?
<ul>
<li>We never see the main thread crash.</li>
<li>Of the 6 types of rendering thread, one is special because it has never been seen in a crash or dropped frame rate.<br />
</li>
</ul></li>
<li>What could the trend be but isn’t?
<ul>
<li>The trend could be the crashes become more commonplace (going above 25%) but we don’t.</li>
<li>The trend could be the crashes only occur on certain days, but that is not the case.</li>
</ul></li>
</ul></li>
</ul>
<p>This example is harder to understand. We need an understanding of the architecture of the app to ask good questions. Some clues appear. There are 6 types of rendering thread, one of whom is fine. In addition, the main thread is fine. We need to explore the relevant differences between them.</p>
<p>When we have a problem that does not always happen, one strategy is to think about what we could do to make the problem worse, and thus happen more frequently. Then, when we have a candidate solution, we can set a confidence threshold (number of iterations without a failure seen) and test the fix against this threshold in the special environment which makes the problem more likely.</p>
<p>Another clue is that 25% of installs have the problem. If the problem was due to the population of different hardware and thus varying hardware capability, we could see that about 25% of users are on iPad versus iPhone. However, being strictly a 25% problem without it varying is a marker to tell us maybe something else in the environment is affecting the behavior of the app. Perhaps during installation, a server is picked in round-robin fashion amongst four servers that host the back-end for the game. Furthermore, during development, perhaps the server used is a special development server different from production servers used by our customers. Again, the IS NOT section provides the most revealing clues as to where to look for a potential solution.</p>
<p>If we did not do Analytic Troubleshooting, in this example the first instinct would be to check for memory leaks, memory pressure, hardware limitations, etc. That kind of analysis can easily consume a week of engineering effort. Whilst it is possible for such issues to result in dropped frames that would not fully explain the pattern of defects we see; they would not explain why exactly 25% of users hit the problem.</p>
<h2 id="the-2018-macbook-pro-t2-problem">The 2018 MacBook Pro T2 Problem</h2>
<p>This section describes a problem with 2018 MacBook Pro computers that were crashing. The narrative has been built up from discussion group postings of affected users <span class="citation" data-cites="macbookproT2">(“2018 Macbook Pros Bridge Os Error” 2018)</span> and media reports <span class="citation" data-cites="appleinsiderimacpro">(“Apple’s T2 Chip May Be Behind iMac Pro, Macbook Pro Crashes” 2018)</span></p>
<p><strong>Problem Description:</strong> 2018 MacBook Pro computers crash during sleep with a Bridge OS Error.</p>
<ul>
<li>WHAT IS
<ul>
<li>What things have a problem?
<ul>
<li>MacBook Pro Mid 2018 (13-inch, 15-inch)</li>
<li>iMac Pro</li>
<li>iBridge2,1</li>
<li>iBridge2,3</li>
<li>A configuration instance with USB devices connected</li>
<li>A configuration instance with no USB devices, waking from sleep</li>
<li>A configuration instance with no USB devices but the power adapter, waking from sleep</li>
<li>A configuration instance with legacy kernel extensions (xboxcontroller)</li>
<li>A configuration instance with xboxcontroller removed (less frequent crash)</li>
<li>macOS high sierra 10.13.6, with supplemental update, from erase disk and clean install</li>
<li>Crash during sleep</li>
<li><code>panic: ANS2 Recoverable Panic - assert failed</code></li>
<li><code>panic: macOS watchdog detected</code></li>
<li><code>panic: x86 global reset detected</code></li>
<li><code>panic: x86 CPU CATERR detected</code></li>
<li>An instance with DiskUtility-&gt;First Aid crypto_val errors</li>
<li>An instance with erased disk to remove crypto_val errors</li>
<li>Fully replaced MacBook Pro hardware with same customer configuration</li>
<li>Mid 2018 MacBook Pro with Power Nap disabled</li>
<li>Not touching the Touch Bar still has the sleep/wake problem</li>
</ul></li>
<li>What is wrong with them?
<ul>
<li>System restarts following a Bridge OS panic</li>
<li>Computer gets hot</li>
<li>Disk checking fails</li>
<li>Peripherals are woken up spuriously</li>
</ul></li>
</ul></li>
<li>WHAT IS NOT
<ul>
<li>What things could have a problem but don’t?
<ul>
<li>MacBook Pro Mid 2017 models or older MacBook Pros</li>
<li>iBridge1,1</li>
<li>MacBook Pro booted in Safe Mode</li>
<li>iPad, iPhone, Apple Watch</li>
</ul></li>
<li>What could be wrong but is not?
<ul>
<li>It’s never a panic whilst the computer is actively running</li>
<li>It’s never a problem during booting</li>
<li>It’s never a problem when the system is being shutdown by a user</li>
</ul></li>
</ul></li>
<li>WHERE IS
<ul>
<li>When the problem was noticed, where was it geographically?
<ul>
<li>At customer premises</li>
<li>On desks, and in laptop bags</li>
</ul></li>
<li>Where is the problem on the thing?
<ul>
<li>In the T2 chip (watchOS-derived) BridgeOS operating system software</li>
</ul></li>
</ul></li>
<li>WHERE IS NOT
<ul>
<li>Where could the thing be when we should have seen the problem but did not?
<ul>
<li>Apple hardware validation facilities (presumably - only Apple knows)</li>
</ul></li>
<li>Where could the problem be on the thing but isn’t?
<ul>
<li>On the main CPU/board</li>
<li>On boot loaders</li>
<li>On Multimedia chips and Network chips (these have their own OS)</li>
</ul></li>
</ul></li>
<li>WHEN IS
<ul>
<li>When was the problem first noticed?
<ul>
<li>After about 30 minutes of sleep, then waking the computer</li>
</ul></li>
<li>When has the problem been seen again?
<ul>
<li>Randomly, say 5 instances in a day or week</li>
</ul></li>
<li>Is there any pattern in the timing?
<ul>
<li>Always after a sleep, after at least around 30 minutes</li>
</ul></li>
<li>When in the lifecycle of the thing was the problem first noticed?
<ul>
<li>After customer purchase and installation of software</li>
<li>After re-installs</li>
<li>After re-erase and install</li>
</ul></li>
</ul></li>
<li>WHEN IS NOT
<ul>
<li>When could the problem have been noticed but wasn’t?
<ul>
<li>At Apple assembly and validation facilities (presumably - only Apple knows)</li>
</ul></li>
<li>When could it have been seen again but wasn’t?
<ul>
<li>At returns department for handed back equipment (presumably - only Apple knows)</li>
</ul></li>
<li>When else in the lifecycle of the thing could the problem be seen but wasn’t?
<ul>
<li>Never during active use of the computer</li>
</ul></li>
</ul></li>
<li>EXTENT IS
<ul>
<li>How many things have the problem?
<ul>
<li>By indirect measurement, amongst iMac Pro service returns, 4 of 103 see the problem</li>
</ul></li>
<li>What is the extent of the defect?
<ul>
<li>Kernel panic, likely only one type of panic, maybe three</li>
</ul></li>
<li>How many defects are on the thing?
<ul>
<li>Single instance kernel panic failure</li>
</ul></li>
<li>What is the trend?
<ul>
<li>Repeats again after a random future sleep period, sometimes less frequent without peripherals</li>
</ul></li>
</ul></li>
<li>EXTENT IS NOT
<ul>
<li>How many things could have the problem but don’t?</li>
<li>There is a boot loader, main Operating System, and other electronic parts which never see a problem</li>
<li>What could be the extent of the problem but isn’t?</li>
<li>It could be sustained panic after panic crashes but this is not seen.</li>
<li>It could be a one time panic per machine, but panics are seen again</li>
<li>How many defects could be present but aren’t?</li>
<li>It could be warning or informational messages but we instead only have a panic</li>
<li>What could the trend be but isn’t?</li>
<li>The problem for each customer is randomly frequent but never increasing or decreasing</li>
</ul></li>
</ul>
<h3 id="analysis-of-failures">Analysis of failures</h3>
<p>The above information resembles what we often see in hard problems. There is a lot of data in the WHAT IS column.</p>
<p>The key first conclusion is that the problem must be the newer T2 chip used in iMac Pro and MacBook Pro. The pattern of defects and the actual panic (in Bridge OS that runs on the T2 chip) make this clear.</p>
<p>The second point is that the volume of failures is low. The iMac Pro is a low volume computer compared to the MacBook Pro so the problem most likely could have been seen during iMac Pro production but wasn’t due to it being a low probability failure.</p>
<p>We see the problem is never during boot up, orderly shutdown, or heavy usage. This is interesting because during hardware validation computers are generally stress tested to shake out problems. They are not normally left in a sleep state to see if they still perform wake up functions. Therefore, it is possible that there is a testing strategy gap.</p>
<p>Replacement hardware still has the same problem for customers. This is a helpful sign because it shows the stability of the defect. Over time, Apple will collect computers known to have the problem, so their faulty batch of computers, to do validation on, improves dramatically.</p>
<p>A major gap in the above data set is there are no <code>pmset</code> logs. These provide detailed sleep/wake behavior logs.</p>
<p>A potentially key data point is that a customer, using Safe Mode boot, never saw the problem. Is there something special about Safe Mode boot in respect of how Bridge OS behaves?</p>
<p>It seems that 30 minutes is a key figure in the sleep time. There may be a threshold at 30 minutes, perhaps to go into a deep sleep rather than a quick nap.</p>
<p>One strategy for understanding the problem is to make it occur more frequently. For example, it might be possible to make the computer very quickly go into deep sleep. That may make the problem appear after say 30 seconds, instead of randomly after 30 minutes of sleeping.</p>
<p>If the problem can be made more frequent then an automated system test could be written. Then any fix to the Bridge OS would have a robust test suite to validate it.</p>
<p>We do not have the source code of the Bridge OS. It would be interesting to discern the differences between the three crashes seen. For example, sometimes there is a case statement of 20 possible faults, and only one is being entered. This reveals something about WHERE IS NOT in the problem specification.</p>
<p>We do not have machine fault register information. When a low level problem occurs, the processor documentation will allow the system architect to look up exactly the kind of failure (timeouts, parity errors, etc.) In our problem specification, we need to be more precise WHERE the problem is. The BridgeOS may just be a canary telling us of a problem elsewhere. Some customers have received a full hardware replacement, but still see the problem. It indicates a software problem.</p>
<p>Intel have described an update in their architecture where a CATERR signal can be sent instead of IERR or MCERR. <span class="citation" data-cites="intelrob">(“Debugging Processor Reorder Buffer Timeout: Guide” 2018)</span> So an update in specification could mean system software is no longer aligned, and thus BridgeOS needs updating.</p>
<p>An approach would be to follow the Intel debugging guide <span class="citation" data-cites="intelrob">(“Debugging Processor Reorder Buffer Timeout: Guide” 2018)</span>. It has many good suggestions. When BridgeOS sees a problem, it should be updated to print out the relevant diagnostic registers.</p>
<h1 id="a-siri-crash">A Siri Crash</h1>
<h2 id="why-are-we-looking-at-a-siri-crash">Why are we looking at a Siri Crash?</h2>
<p>Here is an example of Siri crashing on a Mac. Note that binaries on a Mac are not encrypted. This means we can demonstrate the use of third party tools to explore the binaries at fault. Since only Apple has the source code for Siri, it adds to the challenge and forces us to think abstractly about the problem.</p>
<h2 id="the-crash-report-1">The Crash report</h2>
<p>Here is the Crash Report, suitably truncated for ease of demonstration:</p>
<pre><code>Process:               SiriNCService [1045]
Path:                  
/System/Library/CoreServices/Siri.app/Contents/
XPCServices/SiriNCService.xpc/Contents/MacOS/SiriNCService
Identifier:            com.apple.SiriNCService
Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000018
Exception Note:        EXC_CORPSE_NOTIFY
VM Regions Near 0x18:
--&gt;
    __TEXT                 0000000100238000-0000000100247000
    [   60K] r-x/rwx SM=COW
    /System/Library/CoreServices/Siri.app/Contents/
    XPCServices/SiriNCService.xpc/Contents/MacOS/SiriNCService

Application Specific Information:
objc_msgSend() selector name: didUnlockScreen:

Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libobjc.A.dylib                 
0x00007fff69feae9d objc_msgSend + 29
1   com.apple.CoreFoundation        0x00007fff42e19f2c
 __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 12
2   com.apple.CoreFoundation        0x00007fff42e19eaf
___CFXRegistrationPost_block_invoke + 63
3   com.apple.CoreFoundation        0x00007fff42e228cc
 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
4   com.apple.CoreFoundation        0x00007fff42e052a3
__CFRunLoopDoBlocks + 275
5   com.apple.CoreFoundation        0x00007fff42e0492e
 __CFRunLoopRun + 1278
6   com.apple.CoreFoundation        0x00007fff42e041a3
CFRunLoopRunSpecific + 483
7   com.apple.HIToolbox             0x00007fff420ead96
RunCurrentEventLoopInMode + 286
8   com.apple.HIToolbox             0x00007fff420eab06
ReceiveNextEventCommon + 613
9   com.apple.HIToolbox             0x00007fff420ea884
_BlockUntilNextEventMatchingListInModeWithFilter + 64
10  com.apple.AppKit                
0x00007fff4039ca73 _DPSNextEvent + 2085
11  com.apple.AppKit                0x00007fff40b32e34
-[NSApplication(NSEvent) _nextEventMatchingEventMask:
untilDate:inMode:dequeue:] + 3044
12  com.apple.ViewBridge            0x00007fff67859df0
-[NSViewServiceApplication nextEventMatchingMask:untilDate:
inMode:dequeue:] + 92
13  com.apple.AppKit                0x00007fff40391885
-[NSApplication run] + 764
14  com.apple.AppKit                0x00007fff40360a72
NSApplicationMain + 804
15  libxpc.dylib                    
0x00007fff6af6cdc7 _xpc_objc_main + 580
16  libxpc.dylib                    
0x00007fff6af6ba1a xpc_main + 433
17  com.apple.ViewBridge            0x00007fff67859c15
-[NSXPCSharedListener resume] + 16
18  com.apple.ViewBridge            0x00007fff67857abe
NSViewServiceApplicationMain + 2903
19  com.apple.SiriNCService         
0x00000001002396e0 main + 180
20  libdyld.dylib                   
0x00007fff6ac12015 start + 1</code></pre>
<h2 id="the-crash-details">The Crash details</h2>
<p>Looking at the 09:52 crash we see</p>
<p><code>Exception Type:        EXC_BAD_ACCESS (SIGSEGV)</code></p>
<p>This means we are accessing memory which does not exist. The program that was running (known as the TEXT) was</p>
<pre><code>/System/Library/CoreServices/Siri.app/Contents/
XPCServices/SiriNCService.xpc/Contents/MacOS/SiriNCService</code></pre>
<p>This is interesting because normally it’s applications that crash. Here we see a software component crashing. The Siri service is a distributed app which uses cross process communication (xpc) to do its work. We see that from references to xpc as above.</p>
<p>What method were we trying to call on an object that no longer exists? Helpfully, the crash dump provides the answer:</p>
<p><code>Application Specific Information: objc_msgSend() selector name: didUnlockScreen:</code></p>
<p>Now we have to a first level approximation answered the <em>what</em>, <em>where</em> and <em>when</em> aspect of the crash. It was a Siri component that crashed, in <code>SiriNCService</code> when <code>didUnlockScreen</code> was called on a non-existent object.</p>
<h2 id="applying-our-tool-box">Applying our Tool Box</h2>
<p>Now to understand further we need to reach for the <code>class-dump</code> tool.</p>
<p><code>class-dump SiriNCService &gt; SiriNCService.classdump.txt</code></p>
<p>Looking at a portion of the output is the following:</p>
<pre><code>@property __weak SiriNCService *service;
 // @synthesize service=_service;
- (void).cxx_destruct;
- (BOOL)isSiriListening;
- (void)_didUnlockScreen:(id)arg1;
- (void)_didLockScreen:(id)arg1;</code></pre>
<p>We see that there is indeed a method, <code>didUnlockScreen</code>, and we see that there is a service object which is owned <strong>weakly</strong>. This means that the object is not retained and could get freed. It typically means we a user of the <code>SiriNCService</code> but not the owner. We do not own the lifecycle of the object.</p>
<h2 id="software-engineering-insights">Software Engineering Insights</h2>
<p>The underlying software engineering problem here is one of lifecycle. Part of the application has a object lifecycle we were not expecting. The consumer should have been written to detect the absence of the service as a robustness and defensive programming best practice. What can happen is that the software is maintained over time, and the lifecycles of objects grow more complex over time as new functionality is added but the old code using the objects is not updated in sync.</p>
<p>Taking one step further back we should ask what weak properties are used by this component? From that we can create some simple unit test cases which test the code whilst those objects are nil. Then we can go back and add robustness to the code paths that assumed the object were non-nil.</p>
<p>Taking a further step back, is there anything unusual in the design of this component that calls for integration testing?</p>
<pre><code>grep -i heat SiriNCService.classdump.txt
@protocol SiriUXHeaterDelegate &lt;NSObject&gt;
- (void)heaterSuggestsPreheating:(SiriUXHeater *)arg1;
- (void)heaterSuggestsDefrosting:(SiriUXHeater *)arg1;
@interface SiriNCAlertViewController : NSViewController
&lt;SiriUXHeaterDelegate, AFUISiriViewControllerDataSource,
 AFUISiriViewControllerDelegate&gt;
    SiriUXHeater *_heater;
@property(readonly, nonatomic)
SiriUXHeater *heater; // @synthesize heater=_heater;
- (void)heaterSuggestsPreheating:(id)arg1;
- (void)heaterSuggestsDefrosting:(id)arg1;
@interface SiriUXHeater : NSObject
    id &lt;SiriUXHeaterDelegate&gt; _delegate;
@property(nonatomic)
__weak id &lt;SiriUXHeaterDelegate&gt; delegate;
 // @synthesize delegate=_delegate;
- (void)_suggestPreheat;</code></pre>
<p>It seems that this component can be prepared and made ready and has a variety of levels of initialization and de-initialization. Maybe this complexity is to make the user interface responsive. But it sends us a message that this component needs an integration test suite that codifies the state machine so we know the lifecycle of the service.</p>
<h2 id="lessons-learnt-2">Lessons Learnt</h2>
<p>We went from using HOWTO knowledge (understanding the Crash Report) to using tooling to get a baseline level of knowledge. Then we started to apply Software Engineering experiences, and then we started reasoning about the actual design of the component to ask how we got here and what should be done to avoid the problem. This journey from looking at the artefacts of a problem to getting to the root of what needs to be done is a common theme during crash dump analysis. It cannot be achieved by just focusing on the HOWTO of comprehending crash reports. We need to switch hats and see things from different perspectives in order to really make progress.</p>
<h1 id="runtime-environment-crashes">Runtime Environment Crashes</h1>
<p>In this chapter, we show examples of where the runtime libraries have detected a problem and have caused a crash.</p>
<p>These crashes are distinguished by reporting Exception Type, <code>EXC_BREAKPOINT (SIGTRAP)</code>, in their Crash Report.</p>
<p>We consider two examples. Our first example shows how the runtime handles force unwrapping a nil optional. Our second example shows how the runtime handles releasing a semaphore that is being waited on.</p>
<h2 id="unwrapping-a-nil-optional">Unwrapping a Nil Optional</h2>
<p>The Swift Programming Language is a significant step forward towards writing safe-by-default code.</p>
<p>A central concept within Swift is explicitly handling optionality. In type declarations, a trailing <code>?</code> indicates the value could be absent, as represented by <code>nil</code>. These types need explicit unwrapping to access the value they store.</p>
<p>When a value is not available at object initialization time, but later in the lifecycle of the object, then a trailing <code>!</code> is used for types that hold the value. This means the value can be treated in code without the need for explicit unwrapping. It is called an implicitly unwrapped optional. Note, from Swift 4.2, at the implementation level, it is an optional, with an annotation that indicates it can be used without explicit unwrapping.</p>
<p>We use the <code>icdab_wrap</code> example program to demonstrate crashes that can arise through the faulty use of optionals. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<h3 id="ios-uikit-outlets">iOS UIKit Outlets</h3>
<p>It is a standard paradigm to use a storyboard to declare the User Interface, and associate <code>UIViews</code> with <code>UIViewControllers</code>.</p>
<p>When the user interface updates, such as when launching our app, or performing a segue between scenes, the storyboard instantiates supporting <code>UIViewControllers</code> and sets up fields in our <code>UIViewController</code> objects to <code>UIViews</code> that have been created.</p>
<p>We will have a field declaration automatically generated when we link the storyboard to our controller code such as:</p>
<pre><code>@IBOutlet weak var planetImageOutlet: UIImageView!</code></pre>
<h3 id="ownership-rules">Ownership rules</h3>
<p>If we did not explicitly create an object, and we did not have ownership passed to us, we should not shorten the lifecycle of the object we are passed.</p>
<p>In our <code>icdab_wrap</code> example we have a parent screen, and we can tap into a child screen that has a large image of Pluto.<br />
The image is downloaded from the Internet. When that screen is left, and the original screen is visited the code tries to reduce memory by letting go of the memory associated with the image.</p>
<p>There is a separate argument about whether such an image clean up strategy is helpful or desirable. A profiling tool should be used to inform us when to try to economize our memory footprint.</p>
<p>Our code has a bug:</p>
<pre><code>override func viewWillDisappear(_ animated: Bool) {
        planetImageOutlet = nil
        // BUG; should be planetImageOutlet.image = nil
    }</code></pre>
<p>Instead of setting the image of the image view to nil, we set the image view itself to <code>nil</code></p>
<p>This means when we re-visit the Pluto scene, we crash when trying to store the downloaded image since our <code>planetImageOutlet</code> is <code>nil</code></p>
<pre><code>func imageDownloaded(_ image: UIImage) {
        self.planetImageOutlet.image = image
    }</code></pre>
<p>This code will crash, since it implicitly unwraps the optional, which has been set to <code>nil</code>.</p>
<h3 id="crash-report-for-unwrapped-nil-optionals">Crash Report for unwrapped nil optionals</h3>
<p>When we get a crash from the swift runtime force unwrapping a nil optional we see:</p>
<pre><code>Exception Type:  EXC_BREAKPOINT (SIGTRAP)
Exception Codes: 0x0000000000000001, 0x00000001ae3bbbb4
Termination Signal: Trace/BPT trap: 5
Termination Reason: Namespace SIGNAL, Code 0x5
Terminating Process: exc handler [623]
Triggered by Thread:  0</code></pre>
<p>The item to notice is the Exception Type, <code>EXC_BREAKPOINT (SIGTRAP)</code></p>
<p>We see that the runtime environment raised a breakpoint exception because it saw a problem. This is identified by seeing the swift core library at the top of the stack.</p>
<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libswiftCore.dylib                  0x00000001ae3bbbb4
 closure #1 in closure #1 in closure #1 in _assertionFailure+
 228276 (_:_:file:line:flags:) + 384
1   libswiftCore.dylib                  0x00000001ae3bbbb4
 closure #1 in closure #1 in closure #1 in _assertionFailure+
 228276 (_:_:file:line:flags:) + 384
2   libswiftCore.dylib                  0x00000001ae3bb090
 _assertionFailure+ 225424 (_:_:file:line:flags:) + 472
3   icdab_wrap                          0x00000001046a7da4
 PlanetViewController.imageDownloaded(_:) + 48548
 (PlanetViewController.swift:0)</code></pre>
<h4 id="uninitialized-pointers">Uninitialized pointers</h4>
<p>Older versions of the Swift Runtime, perhaps through the underlying C++ compiler technology, would place a special value <code>0xbaddc0dedeadbead</code> to indicate an uninitialized pointer, such as in the following register dump.</p>
<pre><code>Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x0000000100ecc100   x1: 0x00000001c005b9f0   
    x2: 0x0000000000000008
       x3: 0x0000000183a4906c
    x4: 0x0000000000000080   x5: 0x0000000000000020   
    x6: 0x0048000004210103
       x7: 0x00000000000010ff
    x8: 0x00000001c00577f0   x9: 0x0000000000000000  
    x10: 0x0000000000000002
      x11: 0xbaddc0dedeadbead
   x12: 0x0000000000000001  x13: 0x0000000000000002  
   x14: 0x0000000000000000
     x15: 0x000a65756c617620
   x16: 0x0000000183b9b8cc  x17: 0x0000000000000000  
   x18: 0x0000000000000000
     x19: 0x0000000000000000
   x20: 0x0000000000000002  x21: 0x0000000000000039  
   x22: 0x0000000100d3f3d0
     x23: 0x0000000000000002
   x24: 0x000000000000000b  x25: 0x0000000100d3f40a  
   x26: 0x0000000000000014
     x27: 0x0000000000000000
   x28: 0x0000000002ffffff   fp: 0x000000016f0ca8e0   
   lr: 0x00000001011f7ff8
    sp: 0x000000016f0ca8a0   pc: 0x00000001011f7ff8
    cpsr: 0x60000000</code></pre>
<p>However, modern register dumps, and in our unwrapped <code>nil</code> case, show:</p>
<pre><code>Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x0000000104708000   x1: 0x00000002820a3800   x2:
 0x0000000000000007   x3: 0x00000001ba034cf0
    x4: 0x00000000000062dc   x5: 0x0000000000000013   x6:
 0x0000000000000020   x7: 0x0000000000000001
    x8: 0x000000000000007f   x9: 0x0000000000000071  x10:
 0x00000000000007fb  x11: 0x00000000000007fd
   x12: 0x0000000000000001  x13: 0x00000000c6609046  x14:
 0x00000000c6809800  x15: 0x0000000000000013
   x16: 0x0000000080000000  x17: 0x0000000046800000  x18:
 0x0000000000000000  x19: 0x000000000000002d
   x20: 0x0000000000000000  x21: 0x0000000000000002  x22:
 0x0000000000000002  x23: 0x0000000000000044
   x24: 0x00000001046ab200  x25: 0x00000001047f79a0  x26:
 0x00000000000020ff  x27: 0x0000000000000114
   x28: 0x00000001046ab19a   fp: 0x000000016b762830   lr:
 0x465a8e01ae3bbbb4
    sp: 0x000000016b762810   pc: 0x00000001ae3bbbb4 cpsr:
 0x60000000
   esr: 0xf2000001  Address size fault</code></pre>
<h2 id="releasing-a-semaphore-that-is-in-use">Releasing a semaphore that is in use</h2>
<p>The <code>libdispatch</code> library has support for identifying runtime issues. When such problems arise, the app is crashed with Exception Type, <code>EXC_BREAKPOINT (SIGTRAP)</code></p>
<p>We use the <code>icdab_sema</code> example program to demonstrate a crash detected by <code>libdispatch</code> for the faulty use of semaphores. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>The <code>libdispatch</code> library is the operating system library for managing concurrency (known as Grand Central Dispatch or GCD). The library is available as Open Source from Apple. <span class="citation" data-cites="libdispatchtar">(“Libdispatch Open Source” 2018)</span></p>
<p>The library abstracts away the details of how the Operating System provides access to multi-core CPU resources. During a crash, it supplies extra information to the Crash Report. This means that if we wish to do so, we can find the code that detected the runtime issue.</p>
<h3 id="crash-example-releasing-a-semaphore">Crash example releasing a semaphore</h3>
<p>The <code>icdab_sema</code> example program results in a crash upon launch. The Crash Report is as follows (truncated for ease of demonstration):</p>
<pre><code>Exception Type:  EXC_BREAKPOINT (SIGTRAP)
Exception Codes: 0x0000000000000001, 0x00000001aa3f4788
Termination Signal: Trace/BPT trap: 5
Termination Reason: Namespace SIGNAL, Code 0x5
Terminating Process: exc handler [738]
Triggered by Thread:  0

Application Specific Information:
BUG IN CLIENT OF LIBDISPATCH:
 Semaphore object deallocated while in use
Abort Cause 1

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libdispatch.dylib                   0x00000001aa3f4788
 _dispatch_semaphore_dispose.cold.1 + 40
1   libdispatch.dylib                   0x00000001aa3c1954
 _dispatch_semaphore_signal_slow + 0
2   libdispatch.dylib                   0x00000001aa3bfc58
 _dispatch_dispose + 188
3   icdab_sema_ios                      0x000000010010e810
 use_sema + 26640 (main.m:17)
4   icdab_sema_ios                      0x000000010010e840 main +
 26688 (main.m:23)
5   libdyld.dylib                       0x00000001aa4016c0 start
 + 4

Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x000000028243c120   x1: 0x0000000000000001   x2:
 0x0000000000000000   x3: 0x000000028243c100
    x4: 0x000000028243c140   x5: 0x0000000000000000   x6:
 0x0000000000000000   x7: 0x0000000000000000
    x8: 0x0000000000000001   x9: 0x0000000000000000  x10:
 0x00000002096b02c0  x11: 0x000000000000000f
   x12: 0x0000000000f86e00  x13: 0x00000000c000000f  x14:
 0x0000000000000005  x15: 0x00000002096af268
   x16: 0x0000000000000000  x17: 0x00000001aa3c04d4  x18:
 0x0000000000000000  x19: 0x000000028243c0f0
   x20: 0x0000000000000000  x21: 0x0000000000000000  x22:
 0x00000002096b02c0  x23: 0x0000000000000000
   x24: 0x0000000000000000  x25: 0x0000000000000000  x26:
 0x0000000000000000  x27: 0x0000000000000000
   x28: 0x000000016fcf7ac0   fp: 0x000000016fcf79f0   lr:
 0x00000001aa3c1954
    sp: 0x000000016fcf79f0   pc: 0x00000001aa3f4788 cpsr:
 0x80000000
   esr: 0xf2000001  Address size fault</code></pre>
<h3 id="faulty-semaphore-code">Faulty semaphore code</h3>
<p>The code to reproduce the semaphore problem is based upon an Xcode project that uses Manual Reference Counting (MRC). This is a legacy setting but one that can be encountered whilst integrating with legacy code bases. At the project level, it is option “Objective-C Automatic Reference Counting” set to NO. This allows us to then make direct calls to the <code>dispatch_release</code> API.</p>
<p>The code is as follows:</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

void use_sema() {
    dispatch_semaphore_t aSemaphore =
     dispatch_semaphore_create(1);
    dispatch_semaphore_wait(aSemaphore,
       DISPATCH_TIME_FOREVER);
    // dispatch_semaphore_signal(aSemaphore);
    dispatch_release(aSemaphore);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        use_sema();
    }
    return 0;
}</code></pre>
<h3 id="using-application-specific-crash-report-information">Using application specific Crash Report information</h3>
<p>In our example, the <code>Application Specific Information</code> section of the Crash Report directly explains the problem.</p>
<pre><code>BUG IN CLIENT OF LIBDISPATCH:
 Semaphore object deallocated while in use</code></pre>
<p>We just need to signal the semaphore to avoid the problem.</p>
<p>If we had a more unusual problem or wanted to understand it at a deeper level, we could look up the source code of the library and find the diagnostic message in the code.</p>
<p>Here is the relevant library code:</p>
<pre><code>void
_dispatch_semaphore_dispose(dispatch_object_t dou,
        DISPATCH_UNUSED bool *allow_free)
{
    dispatch_semaphore_t dsema = dou._dsema;

    if (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) {
        DISPATCH_CLIENT_CRASH(
      dsema-&gt;dsema_orig - dsema-&gt;dsema_value,
                &quot;Semaphore object deallocated
 while in use&quot;
    );
    }

    _dispatch_sema4_dispose(&amp;dsema-&gt;dsema_sema,
     _DSEMA4_POLICY_FIFO);
}</code></pre>
<p>Here we can see the library causing a crash through the <code>DISPATCH_CLIENT_CRASH</code> macro.</p>
<h3 id="semaphore-crash-lessons-learnt">Semaphore Crash Lessons Learnt</h3>
<p>Manual Reference Counting should be avoided in modern application code.</p>
<p>When crashes occur via runtime libraries, we need to go back to the API specification to find out how we are violating the API contract that resulted in a crash. The Application Specific Information in the Crash Report should help focus our attention when re-reading the API document, studying working sample code, and looking into the detail level of the source code of the runtime library (when available).</p>
<p>Where MRC code has been carried forwards from a legacy code base, a design pattern should be used to wrap the code that is MRC based, and offer a clean API into it. Then the rest of the program can use Automatic Reference Counting (ARC). This will contain the problem, and allow the new code to benefit from ARC. It is possible also to mark specific files as being MRC. The compiler flag option, <code>-fno-objc-arc</code>, needs to be set for the file. It is found within <em>Build Phases -&gt; Compile Sources</em> area of Xcode.</p>
<p>If the legacy code does not need enhancement, it is best to leave it alone, and just wrap it with a facade API. We can then write some test cases for that API. Code that is not actively updated tends to only give rise to bugs when it is used in new ways. Sometimes the staff with knowledge of legacy code has left the project, so making updates can be risky by less knowledgeable staff.</p>
<p>It is great if legacy code can be replaced over time. Normally a business justification is needed. One strategy is to break down a legacy module into smaller pieces. If this is done strategically, then one of the smaller pieces can be re-worked, with modern coding practices. It becomes a win-win when such a module is enhanced to solve a new customer need as well.</p>
<h1 id="bad-memory-crashes">Bad Memory Crashes</h1>
<p>In this chapter, we study bad memory crashes.</p>
<p>These crashes are distinguished by reporting Exception Type, <code>EXC_BAD_ACCESS (SIGSEGV)</code>, or <code>EXC_BAD_ACCESS (SIGBUS)</code> in their Crash Report.</p>
<p>We look at a range of crashes obtained by searching the Internet.</p>
<h2 id="general-principles">General principles</h2>
<p>In operating systems, memory is managed by first collating contiguous memory into memory pages, and then collating pages into segments. This allows metadata properties to be assigned to a segment that applies to all pages within the segment. This allows the code of our program (the program <em>TEXT</em>) to be set to read only but executable. This improves performance and security.</p>
<p>SIGBUS (bus error) means the memory address is correctly mapped into the address space of the process, but the process is not allowed to access the memory.</p>
<p>SIGSEGV (segment violation) means the memory address is not even mapped into the process address space.</p>
<h2 id="segment-violation-segv-crashes">Segment Violation (SEGV) crashes</h2>
<h3 id="fud-crash">fud crash</h3>
<p>The <code>fud</code> program is an undocumented process within the private framework <code>MobileAccessoryUpdater</code>. From looking at the binary it appears to be a firmware update program.</p>
<p>Here we show the Crash Report of process <code>fud</code> on macOS, truncated for ease of demonstration:</p>
<pre><code>Process:               fud [84641]
Path:                  /System/Library/PrivateFrameworks/
MobileAccessoryUpdater.framework/Support/fud
Identifier:            fud
Version:               106.50.4
Code Type:             X86-64 (Native)
Parent Process:        launchd [1]
Responsible:           fud [84641]
User ID:               0

Date/Time:             2018-06-12 08:34:15.054 +0100
OS Version:            Mac OS X 10.13.4 (17E199)
Report Version:        12
Anonymous UUID:        6C1D2091-02B7-47C4-5BF9-E99AD5C45875

Sleep/Wake UUID:       369D13CB-F0D3-414B-A177-38B1E560EEC7

Time Awake Since Boot: 240000 seconds
Time Since Wake:       47 seconds

System Integrity Protection: enabled

Crashed Thread:        1
  Dispatch queue: com.apple.fud.processing.queue

Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       EXC_I386_GPFLT
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Segmentation fault: 11
Termination Reason:    Namespace SIGNAL, Code 0xb
Terminating Process:   exc handler [0]

Thread 1 Crashed:: Dispatch queue:
 com.apple.fud.processing.queue
0   libdispatch.dylib               0x00007fff67fc6cbd
 _dispatch_continuation_push + 4
1   fud                             0x0000000101d3ce57
 __38-[FudController handleXPCStreamEvent:]_block_invoke + 593
2   libdispatch.dylib               0x00007fff67fbb64a
 _dispatch_call_block_and_release + 12
3   libdispatch.dylib               0x00007fff67fb3e08
 _dispatch_client_callout + 8
4   libdispatch.dylib               0x00007fff67fc8377
 _dispatch_queue_serial_drain + 907
5   libdispatch.dylib               0x00007fff67fbb1b6
 _dispatch_queue_invoke + 373
6   libdispatch.dylib               0x00007fff67fc8f5d
 _dispatch_root_queue_drain_deferred_wlh + 332
7   libdispatch.dylib               0x00007fff67fccd71
 _dispatch_workloop_worker_thread + 880
8   libsystem_pthread.dylib         0x00007fff68304fd2
 _pthread_wqthread + 980
9   libsystem_pthread.dylib         0x00007fff68304be9
 start_wqthread + 13

Thread 1 crashed with X86 Thread State (64-bit):
  rax: 0xe00007f80bd22039  rbx: 0x00007f80bd2202e0
    rcx: 0x7fffffffffffffff
    rdx: 0x011d800101d66da1
  rdi: 0x00007f80bd21a250  rsi: 0x0000000102c01000
    rbp: 0x0000700007e096c0
    rsp: 0x0000700007e09670
   r8: 0x0000000102c00010   r9: 0x0000000000000001
     r10: 0x0000000102c01000
     r11: 0x00000f80b5300430
  r12: 0x00007f80ba70c670  r13: 0x00007fff673c8e80
    r14: 0x00007f80bd201e00
    r15: 0x00007f80ba70cf30
  rip: 0x00007fff67fc6cbd  rfl: 0x0000000000010202
    cr2: 0x00007fff9b2f11b8

Logical CPU:     3
Error Code:      0x00000004
Trap Number:     14</code></pre>
<p>We clearly have a bad memory issue, since we have a <code>EXC_BAD_ACCESS (SIGSEGV)</code> exception. The Trap Number we see is 14, which from https://github.com/apple/darwin-xnu is a Page Fault.</p>
<p>We can even look up the function that triggered the crash since <code>libdispatch</code> is Apple Open Source. <span class="citation" data-cites="libdispatchtar">(“Libdispatch Open Source” 2018)</span></p>
<p>We see:</p>
<pre><code>#define dx_push(x, y, z) dx_vtable(x)-&gt;do_push(x, y, z)

DISPATCH_NOINLINE
static void
_dispatch_continuation_push(dispatch_queue_t dq,
   dispatch_continuation_t dc)
{
    dx_push(dq, dc, _dispatch_continuation_override_qos(dq,
 dc));
}</code></pre>
<p>We are dereferencing memory from a data structure that has a bad memory location.</p>
<p>We can disassemble the macOS binary, <code>/usr/lib/system/libdispatch.dylib</code> for the problem call site.</p>
<p>Here we use the Hopper tool to do the disassembly:</p>
<pre><code>__dispatch_continuation_push:
0000000000014c69 push       rbx
                             ; CODE XREF=__dispatch_async_f2+112,
                             j___dispatch_continuation_push
0000000000014c6a mov        rax, qword [rdi]
0000000000014c6d mov        r8, qword [rax+0x40]
0000000000014c71 mov        rax, qword [rsi+8]
0000000000014c75 mov        edx, eax
0000000000014c77 shr        edx, 0x8
0000000000014c7a and        edx, 0x3fff
0000000000014c80 mov        ebx, dword [rdi+0x58]
0000000000014c83 movzx      ecx, bh
0000000000014c86 je         loc_14ca3</code></pre>
<p>There seems to be a problem with the <code>rdi</code> register value, address <code>0x00007f80bd21a250</code></p>
<p>We need to take a step back, and understand why we have a memory access problem.</p>
<p>Looking at the stack backtrace we can see that this program uses cross process communication (XPC) to do its work. It has a <code>handleXPCStreamEvent</code> function.</p>
<p>It is a common programming problem that when we receive a data payload, there is a problem unpacking the payload and interpreting the data. We speculate that there is a bug in the deserialization code. That would give us a potentially bad data structure which we dereference causing a crash.</p>
<p>If we were the authors of the <code>fud</code> program we could update it to check the XPC data it gets and ensure best practices are followed for serialization/deserialization of data, such as using interface definition layer generators.</p>
<h3 id="leakagent-crash">LeakAgent crash</h3>
<p>The <code>LeakAgent</code> program is provided by Apple as part of its memory diagnostics tools. It is used in Xcode Instruments.</p>
<p>Here is a Crash Report where it has crashed, truncated for ease of demonstration:</p>
<pre><code>Incident Identifier: 11ED1987-1BC9-4F44-900C-AD07EE6F7E26
CrashReporter Key:   b544a32d592996e0efdd7f5eaafd1f4164a2e13c
Hardware Model:      iPad6,3
Process:             LeakAgent [3434]
Path:                /Developer/Library/PrivateFrameworks/
DVTInstrumentsFoundation.framework/LeakAgent
Identifier:          LeakAgent
Version:             ???
Code Type:           ARM-64 (Native)
Role:                Unspecified
Parent Process:      DTServiceHub [1592]
Coalition:           com.apple.instruments.deviceservice
 [463]


Date/Time:           2018-07-19 14:16:57.6977 +0100
Launch Time:         2018-07-19 14:16:56.7734 +0100
OS Version:          iPhone OS 11.3 (15E216)
Baseband Version:    n/a
Report Version:      104

Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at
 0x0000000000000000
VM Region Info: 0 is not in any region.
  Bytes before following region: 4371873792
      REGION TYPE                      START - END
                   [ VSIZE] PRT/MAX SHRMOD  REGION DETAIL
      UNUSED SPACE AT START
---&gt;  
      __TEXT        0000000104958000-0000000104964000
       [   48K] r-x/r-x SM=COW  ...ork/LeakAgent

Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [0]
Triggered by Thread:  4

Thread 4 name:  Dispatch queue:
DTXChannel serializer queue [x1.c0]
Thread 4 Crashed:
0   libswiftDemangle.dylib          
0x0000000104f871dc 0x104f70000 + 94684
1   libswiftDemangle.dylib          
0x0000000104f8717c 0x104f70000 + 94588
2   libswiftDemangle.dylib          
0x0000000104f86200 0x104f70000 + 90624
3   libswiftDemangle.dylib          
0x0000000104f84948 0x104f70000 + 84296
4   libswiftDemangle.dylib          
0x0000000104f833a4 0x104f70000 + 78756
5   libswiftDemangle.dylib          
0x0000000104f73290 0x104f70000 + 12944
6   CoreSymbolication               
0x000000019241d638 demangle + 112
7   CoreSymbolication               
0x00000001923d16cc
 TRawSymbol&lt;Pointer64&gt;::name+ 54988 () + 72
8   CoreSymbolication               
0x0000000192404ff4
 TRawSymbolOwnerData&lt;Pointer64&gt;::
 symbols_for_name(CSCppSymbolOwner*, char const*,
    void + 266228 (_CSTypeRef) block_pointer) + 156
9   CoreSymbolication               
0x00000001923d9734
 CSSymbolOwnerGetSymbolWithName + 116
10  Symbolication                   
0x000000019bb2e7f4
 -[VMUObjectIdentifier _targetProcessSwiftReflectionVersion]
  + 120
11  Symbolication                   
0x000000019bb2f9d8
 -[VMUObjectIdentifier loadSwiftReflectionLibrary] + 36
12  Symbolication                   
0x000000019bb29ff0
 -[VMUObjectIdentifier initWithTask:symbolicator:scanner:]
  + 436
13  Symbolication                   
0x000000019baede10
 -[VMUTaskMemoryScanner _initWithTask:options:] + 2292
14  Symbolication                   
0x000000019baee304
 -[VMUTaskMemoryScanner initWithTask:options:] + 72
15  LeakAgent                       
0x000000010495b270 0x104958000 + 12912
16  CoreFoundation                  
0x0000000183f82580 __invoking___ + 144
17  CoreFoundation                  0x0000000183e61748
 -[NSInvocation invoke] + 284
18  DTXConnectionServices           
0x000000010499f230 0x104980000 + 127536
19  DTXConnectionServices           
0x00000001049947a4 0x104980000 + 83876
20  libdispatch.dylib               0x000000018386cb24
 _dispatch_call_block_and_release + 24
21  libdispatch.dylib               0x000000018386cae4
 _dispatch_client_callout + 16
22  libdispatch.dylib               0x0000000183876a38
 _dispatch_queue_serial_drain$VARIANT$mp + 608
23  libdispatch.dylib               0x0000000183877380
 _dispatch_queue_invoke$VARIANT$mp + 336
24  libdispatch.dylib               0x0000000183877d4c
 _dispatch_root_queue_drain_deferred_wlh$VARIANT$mp + 340
25  libdispatch.dylib               0x000000018388011c
 _dispatch_workloop_worker_thread$VARIANT$mp + 668
26  libsystem_pthread.dylib         0x0000000183b9fe70
 _pthread_wqthread + 860
27  libsystem_pthread.dylib         
0x0000000183b9fb08 start_wqthread + 4

Thread 4 crashed with ARM Thread State (64-bit):
    x0: 0x0000000000000000   x1: 0x0000000000000000   
    x2: 0xfffffffffffffff6
       x3: 0x0000000000000041
    x4: 0x0000000000000000   x5: 0x0000000104f97950   
    x6: 0x0000000000000006
       x7: 0x00000000ffffffff
    x8: 0x00000001050589d0   x9: 0x0000000104f840d8  
    x10: 0xffffffffffffd544
      x11: 0x0000000000000a74
   x12: 0x0000000000000002  x13: 0x00000000000002aa  
   x14: 0x00000000000002aa
     x15: 0x00000000000003ff
   x16: 0x0000000183b96360  x17: 0x0000000000200000  
   x18: 0x0000000000000000
     x19: 0x000000016b6d1ba0
   x20: 0x00000001050589a0  x21: 0x0000000000000000  
   x22: 0x0000000000000000
     x23: 0x0000000000000001
   x24: 0x00000000ffffffff  x25: 0x0000000000000006  
   x26: 0x0000000104f97950
     x27: 0x0000000000000000
   x28: 0x0000000000000009   fp: 0x000000016b6d19c0   
   lr: 0x0000000104f8717c
    sp: 0x000000016b6d1930   pc: 0x0000000104f871dc
    cpsr: 0x60000000</code></pre>
<p>We can see that the kernel address at fault is <code>0x0000000000000000</code> so it’s a NULL pointer dereference. The call site where we crash is a Swift library that demangles symbols. The Xcode instrument is trying to provide human readable object type definitions from the activity it has seen on the iPad.</p>
<p>If we were the user trying to profile our app, and hit this bug in the <code>LeakAgent</code>, we would need to try and figure out a way to avoid the problem.</p>
<p>Since the problem is due to symbolification, it may be wise to clear our build directory and then do a clean build. Sometimes an Xcode update switches us to a new object file format that is incompatible. It is worthwhile checking profiling with another project, perhaps a trivial test program. There are alternative memory analysis facilities, such as the Diagnostics Tab for the scheme we are running, so memory analysis could be done in a different way. See the later chapter, Memory Diagnostics, for further information.</p>
<h3 id="pointer-authentication-crash">Pointer Authentication crash</h3>
<p>Earlier, in chapter <em>Pointer Authentication</em>, we saw a user space crash with Pointer Authentication switched on. Here we see a crash in system libraries that use Pointer Authentication.</p>
<pre><code>Incident Identifier: 692E5696-6994-4FB3-B42D-C9317D956EE7
CrashReporter Key:   1f2cdb7448d354584634e8576c1e5257634fc0cd
Hardware Model:      iPhone12,1
Process:             get [1737]
Path:               
 /private/var/containers/Bundle/Application/2BF678BB-7CC6-4CAC-BF
49-0298B611F1BA/get.app/get
Identifier:         
 com.soul.merge.cat.cute.simulator.adventure.get
Version:             44 (1.4.4)
AppStoreTools:       11C29
AppVariant:          1:iPhone12,1:13
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:          
 com.soul.merge.cat.cute.simulator.adventure.get [757]

Date/Time:           2019-12-26 09:54:15.6806 +0300
Launch Time:         2019-12-26 09:43:08.8423 +0300
OS Version:          iPhone OS 13.3 (17C54)
Release Type:        User
Baseband Version:    1.03.12
Report Version:      104

Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x41fc821e000001b0 -&gt;
 0xffffff9e000001b0 (possible pointer authentication failure)
VM Region Info: 0xffffff9e000001b0 is not in any region.  Bytes
 after previous region: 18446743641528467889
      REGION TYPE                      START - END             [
 VSIZE] PRT/MAX SHRMOD  REGION DETAIL
      MALLOC_NANO            0000000280000000-00000002a0000000
 [512.0M] rw-/rwx SM=PRV
---&gt;
      UNUSED SPACE AT END

Triggered by Thread:  27

Thread 27 name:
Thread 27 Crashed:
0   libEmbeddedSystemAUs.dylib          0x00000001d0246644
 InterruptionListener(void*, unsigned int, unsigned int, void
 const*) + 352 (AURemoteIO.cpp:257)
1   libEmbeddedSystemAUs.dylib          0x00000001d0246578
 InterruptionListener(void*, unsigned int, unsigned int, void
 const*) + 148 (AURemoteIO.cpp:256)
2   AudioToolbox                        0x00000001bd34e710
 AudioSessionPropertyListeners::CallPropertyListeners(unsigned
 int, unsigned int, void const*) + 596
 (AudioSessionPropertyListeners.cpp:146)
3   AudioToolbox                        0x00000001bd3ab564
 HandleAudioSessionCFTypePropertyChangedMessage(unsigned int,
 unsigned int, void*, unsigned int) + 1104 (AudioSession.cpp:932)
4   AudioToolbox                        0x00000001bd3aac1c
 ProcessDeferredMessage(unsigned int, __CFData const*, unsigned
 int, unsigned int) + 2540 (AudioSession.cpp:1050)
5   AudioToolbox                        0x00000001bd4187e0
 _XAudioSessionPingMessage + 688 (AudioSession.cpp:1161)
6   libAudioToolboxUtility.dylib        0x00000001bd4a76b4
 mshMIGPerform + 268 (MachServerHelper.c:450)
7   CoreFoundation                      0x00000001b1f207c4
 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 60
 (CFRunLoop.c:1937)
8   CoreFoundation                      0x00000001b1f1fe90
 __CFRunLoopDoSource1 + 448 (CFRunLoop.c:2075)
9   CoreFoundation                      0x00000001b1f1aac8
 __CFRunLoopRun + 2144 (CFRunLoop.c:3098)
10  CoreFoundation                      0x00000001b1f19f40
 CFRunLoopRunSpecific + 480 (CFRunLoop.c:3192)
11  AVFAudio                            0x00000001beeb1f70
 GenericRunLoopThread::Entry(void*) + 160
 (GenericRunLoopThread.h:91)
12  AVFAudio                            0x00000001bef031fc
 CAPThread::Entry(CAPThread*) + 208 (CAPThread.cpp:286)
13  libsystem_pthread.dylib             0x00000001b1cad840
 _pthread_start + 168 (pthread.c:896)
14  libsystem_pthread.dylib             0x00000001b1cb59f4
 thread_start + 8

Thread 27 crashed with ARM Thread State (64-bit):
    x0: 0x0000000000000000   x1: 0x0000000000000000   x2:
 0x0000000000000100   x3: 0x0000000000000000
    x4: 0x00000000000020a0   x5: 0x0000000000000020   x6:
 0x0000000000000000   x7: 0x00000000000003da
    x8: 0x41fc821e00000000   x9: 0x0000000000000020  x10:
 0x0000000000000000  x11: 0x0000000000000202
   x12: 0x0000000000000002  x13: 0x0000000000000000  x14:
 0x0000000000000002  x15: 0x0000000000000001
   x16: 0x00000001b1c6b43c  x17: 0x00000001f0430630  x18:
 0x0000000000000000  x19: 0x0000000103823040
   x20: 0x00000001710287fc  x21: 0x00000000696e7472  x22:
 0x0000000108aa3b28  x23: 0x000000010fd10588
   x24: 0x000000010fd105a0  x25: 0x0000000064696564  x26:
 0x00000001fb421000  x27: 0x00000000006c9000
   x28: 0x0000000000000049   fp: 0x0000000171028660   lr:
 0xe970e981d0246578
    sp: 0x0000000171028600   pc: 0x00000001d0246644 cpsr:
 0x80000000
   esr: 0x56000080  Address size fault

Binary Images:
0x10005c000 - 0x102687fff get arm64 
 &lt;bde08a08d8cf3e6b8cee8ab2cf246ccb&gt;
 /var/containers/Bundle/Application/2BF678BB-7CC6-4CAC-BF49-0298B
611F1BA/get.app/get
.
.
0x1d01b7000 - 0x1d02c3fff libEmbeddedSystemAUs.dylib arm64e 
 &lt;48e72efe02243faabf3e1760bb4c2731&gt;
 /System/Library/Frameworks/AudioToolbox.framework/libEmbeddedSys
temAUs.dylib</code></pre>
<p>We see that the faulting address <code>0x41fc821e000001b0</code> has top 24-bits <code>41fc82</code>. This is the <em>Pointer Authentication Code</em> (PAC). We see that the faulting function <code>InterruptionListener</code> takes two pointers as arguments, and that we have register <code>x8</code> with address <code>0x41fc821e00000000</code>. So presumably our failing code is using this address, plus some small offset, <code>0x1b0</code>. It could be that manual pointer arithmetic is being used causing a non-authenticated pointer to be utilised.</p>
<h2 id="bus-error-sigbus-crashes">Bus error (SIGBUS) crashes</h2>
<h3 id="xbmc-crash">xbmc crash</h3>
<p>The <code>xmbc</code> app is a utility app that behaves like a television media player remote control.</p>
<p>During startup the application crashed with the following Crash Report, truncated for ease of demonstration:</p>
<pre><code>Incident Identifier: 396B3641-5F74-4B01-9E62-FE24A2C12E92
CrashReporter Key:   14aa0286b8b087d8b6a1ca75201a3f7d8c52d5bd
Hardware Model:      iPad1,1
Process:         XBMC [5693]
Path:            /var/mobile/Applications/
94088F35-1CDB-47CD-9D3C-328E39C2589F/XBMC.app/XBMC
Identifier:      XBMC
Version:         ??? (???)
Code Type:       ARM (Native)
Parent Process:  launchd [1]

Date/Time:       2011-04-10 11:52:44.575 +0200
OS Version:      iPhone OS 4.3.1 (8G4)
Report Version:  104

Exception Type:  EXC_BAD_ACCESS (SIGBUS)
Exception Codes: 0x00000032, 0x047001b0
Crashed Thread:  4

Thread 4 Crashed:
0   dyld                            0x2fe1c8a0 strcmp + 0
1   dyld                            0x2fe0ce32
 ImageLoaderMachO::parseLoadCmds() + 30
2   dyld                            0x2fe1262c
 ImageLoaderMachOCompressed::instantiateFromFile
 (char const*, int,
    unsigned char const*, unsigned long long,
     unsigned long long,
     stat const&amp;, unsigned int, unsigned int,
      linkedit_data_command const*,
      ImageLoader::LinkContext const&amp;) + 228
3   dyld                            0x2fe0da14
 ImageLoaderMachO::instantiateFromFile
 (char const*, int,
    unsigned char const*, unsigned long long,
     unsigned long long,
     stat const&amp;, ImageLoader::LinkContext const&amp;) + 348
4   dyld                            0x2fe052e8
 dyld::loadPhase6(int, stat const&amp;, char const*,
    dyld::LoadContext const&amp;) + 576
5   dyld                            0x2fe053fe
 dyld::loadPhase5stat(char const*,
    dyld::LoadContext const&amp;, stat*,
    int*, bool*, std::vector&lt;char const*,
    std::allocator&lt;char const*&gt; &gt;*) + 174
6   dyld                            0x2fe055b4
 dyld::loadPhase5(char const*, char const*,
    dyld::LoadContext const&amp;,
    std::vector&lt;char const*,
     std::allocator&lt;char const*&gt; &gt;*) + 232
7   dyld                            0x2fe057fe
 dyld::loadPhase4(char const*, char const*,
   dyld::LoadContext const&amp;,
    std::vector&lt;char const*,
    std::allocator&lt;char const*&gt; &gt;*) + 302
8   dyld                            0x2fe064b2
 dyld::loadPhase3(char const*, char const*,
   dyld::LoadContext const&amp;,
    std::vector&lt;char const*,
    std::allocator&lt;char const*&gt; &gt;*) + 2514
9   dyld                            0x2fe065d0
 dyld::loadPhase1(char const*, char const*,
   dyld::LoadContext const&amp;,
    std::vector&lt;char const*,
    std::allocator&lt;char const*&gt; &gt;*) + 88
10  dyld                            0x2fe06798
 dyld::loadPhase0(char const*, char const*,
   dyld::LoadContext const&amp;,
    std::vector&lt;char const*,
    std::allocator&lt;char const*&gt; &gt;*) + 368
11  dyld                            0x2fe0688e
 dyld::load(char const*, dyld::LoadContext const&amp;) + 178
12  dyld                            0x2fe08916 dlopen + 574
13  libdyld.dylib                   0x3678b4ae dlopen + 30
14  XBMC                            0x002276d4
 SoLoader::Load() (SoLoader.cpp:57)
15  XBMC                            0x0002976c
 DllLoaderContainer::LoadDll(char const*, bool)
  (DllLoaderContainer.cpp:250)
16  XBMC                            0x000299ce
 DllLoaderContainer::FindModule(char const*, char const*,
    bool) (DllLoaderContainer.cpp:147)
17  XBMC                            0x00029cca
 DllLoaderContainer::LoadModule(char const*, char const*,
    bool) (DllLoaderContainer.cpp:115)
18  XBMC                            0x0010c1a4
 CSectionLoader::LoadDLL(CStdStr&lt;char&gt; const&amp;, bool,
    bool) (SectionLoader.cpp:138)
19  XBMC                            0x000e9b10
 DllDynamic::Load() (DynamicDll.cpp:52)
20  XBMC                            0x002096c6
 ADDON::CAddonMgr::Init() (AddonManager.cpp:215)
21  XBMC                            0x004e447a
 CApplication::Create() (Application.cpp:644)
22  XBMC                            0x00510e42
 -[XBMCEAGLView runAnimation:] (XBMCEAGLView.mm:312)
23  Foundation                      0x3505b382
 -[NSThread main] + 38
24  Foundation                      
0x350cd5c6 __NSThread__main__ + 966
25  libsystem_c.dylib               
0x3035530a _pthread_start + 242
26  libsystem_c.dylib               
0x30356bb4 thread_start + 0

Thread 4 crashed with ARM Thread State:
    r0: 0x047001b0    r1: 0x2fe20ef0      r2: 0x01fe5f04
          r3: 0x2fe116d1
    r4: 0x00000001    r5: 0x01a46740      r6: 0x00000000
         r7: 0x01fe5264
    r8: 0x01a3f0fc    r9: 0x00000012     r10: 0x01fe6e60
         r11: 0x00000007
    ip: 0x2fe262f8    sp: 0x01fe5234      lr: 0x2fe0ce39
          pc: 0x2fe1c8a0
  cpsr: 0x00000010

Binary Images:
      0x1000 -   0xd98fff +XBMC armv7
        &lt;d446ccbaefe96d237cfa331a4d8216b9&gt;
         /var/mobile/Applications/
         94088F35-1CDB-47CD-9D3C-328E39C2589F/
         XBMC.app/XBMC
  0x2fe00000 - 0x2fe25fff  dyld armv7
    &lt;8dbdf7bab30e355b81e7b2e333d5459b&gt;
     /usr/lib/dyld</code></pre>
<p>In this crash, we accessed bad memory at location <code>0x047001b0</code> as reported by the second value in the Crash Report Exception Codes section:</p>
<pre><code>Exception Codes: 0x00000032, 0x047001b0</code></pre>
<p>Note, this also appears as the value for register <code>r0</code> (often this is the case)</p>
<p>This is higher than the XBMC app binary image range, and lower than the <code>dyld</code> range according to the binary images section of the Crash Report.</p>
<p>This address must be mapped in, but we do not know what segment it is mapped into from the Crash Report.</p>
<p>We can see this application can dynamically configure. From the backtrace we see:</p>
<pre><code>13  libdyld.dylib                   0x3678b4ae dlopen + 30
14  XBMC                            0x002276d4
 SoLoader::Load() (SoLoader.cpp:57)</code></pre>
<p>It is calling the dynamic loader to load extra code based upon a configuration determined by an “AddOn” manager:</p>
<pre><code>20  XBMC                            0x002096c6
 ADDON::CAddonMgr::Init() (AddonManager.cpp:215)</code></pre>
<p>The easiest way to diagnose such a problem is for the application to log its configuration before attempting to load optional software frameworks at runtime. Possibly, the application bundle is missing the library we desire.</p>
<p>Sometimes we are integrating third party libraries that have dynamic code loading within them. In such cases, we need to use the Xcode diagnostics facilities.</p>
<p>We do not have the source code for the XBMC application. However, there is an open source example demonstrating the use of the dynamic loader. <span class="citation" data-cites="dynamicloadingeg">(“Dynamic Loading Example” 2018)</span></p>
<p>When we run this program, we can see informative messages in its use of the dynamic loader, as coded by the app. For older versions of Xcode, we can switch on <em>Dynamic Linker API Usage</em>  by editing the Scheme settings as follows:</p>
<p><img src="screenshots/dynamic_loading.png" /></p>
<p>For Xcode 12.x, we can switch on equivalent functionality by setting environmental variables. It is worth experimenting with different options, but a good starting point is <code>DYLD_PRINT_LIBRARIES</code>. No particular value needs to be set for the environmental value. It is located in Scheme settings: <code>Product &gt; Scheme &gt; Edit Scheme</code>; <code>Run</code> target, <code>Arguments</code> tab, <code>Environment Variables</code> table. <span class="citation" data-cites="dynamicloadingenvvars">(“Logging Dynamic Loader Events” 2020)</span></p>
<p><img src="screenshots/dynamic_loading_env.png" /></p>
<p>When this program is launched, we can see how it dynamically loads modules. We get system-generated messages in addition to our app messages. The system messages do not have a timestamp prefix, but the app messages do.</p>
<p>Here is a trimmed debug log to show the kind of output we see:</p>
<pre><code>2018-08-18 12:26:51.989237+0100
 ios-dynamic-loading-framework[2962:109722]
 App started
2018-08-18 12:26:51.992187+0100
 ios-dynamic-loading-framework[2962:109722]
 Before referencing CASHello in DynamicFramework1
dlopen(DynamicFramework1.framework/DynamicFramework1, 0x00000001)
2018-08-18 12:26:52.002234+0100
 ios-dynamic-loading-framework[2962:109722]
 Loading CASHello in dynamic-framework-1
  dlopen(DynamicFramework1.framework/DynamicFramework1) ==&gt;
   0x600000157ce0
2018-08-18 12:26:52.002398+0100
 ios-dynamic-loading-framework[2962:109722]
 Loaded CASHello in DynamicFramework1
dlclose(0x600000157ce0)
2018-08-18 12:26:52.002560+0100
 ios-dynamic-loading-framework[2962:109722]
 CASHello from DynamicFramework1 still loaded after dlclose()
2018-08-18 12:26:52.002642+0100
 ios-dynamic-loading-framework[2962:109722]
 Before referencing CASHello in DynamicFramework2
dlopen(DynamicFramework2.framework/DynamicFramework2, 0x00000001)
objc[2962]: Class CASHello is implemented in both
 /Users/faisalm/Library/
Developer/Xcode/DerivedData/
ios-dynamic-loading-framework-ednexaanxalgpudjcqeuejsdmhlq/Build
/Products/Debug-iphonesimulator/
DynamicFramework1.framework/DynamicFramework1 (0x1229cb178)
 and
 /Users/faisalm/Library/Developer/Xcode/DerivedData/
ios-dynamic-loading-framework-ednexaanxalgpudjcqeuejsdmhlq/Build
/Products/Debug-iphonesimulator/DynamicFramework2.framework/
DynamicFramework2
 (0x1229d3178).
 One of the two will be used. Which one is undefined.
2018-08-18 12:26:52.012601+0100
 ios-dynamic-loading-framework[2962:109722]
 Loading CASHello in dynamic-framework-2
  dlopen(DynamicFramework2.framework/DynamicFramework2) ==&gt;
   0x600000157d90
2018-08-18 12:26:52.012792+0100
 ios-dynamic-loading-framework[2962:109722]
 Loaded CASHello in DynamicFramework2
dlclose(0x600000157d90)
2018-08-18 12:26:52.012921+0100
 ios-dynamic-loading-framework[2962:109722]
 CASHello from DynamicFramework2 still loaded after dlclose()</code></pre>
<p>Here is the relevant source code for loading <code>DynamicFramework1</code></p>
<pre><code>-(void)loadCASHelloFromDynamicFramework1
{
    void *framework1Handle = dlopen(
      &quot;DynamicFramework1.framework/DynamicFramework1&quot;,
 RTLD_LAZY);

    if (NSClassFromString(@&quot;CASHello&quot;))
    {
        NSLog(@&quot;Loaded CASHello in DynamicFramework1&quot;);
    }
    else
    {
        NSLog(@&quot;Could not load CASHello in DynamicFramework1&quot;);
    }

    dlclose(framework1Handle);

    if (NSClassFromString(@&quot;CASHello&quot;))
    {
        NSLog(
  @&quot;CASHello from DynamicFramework1 still loaded after dlclose()&quot;
        );
    }
    else
    {
        NSLog(@&quot;Unloaded DynamicFramework1&quot;);
    }
}</code></pre>
<p>Here is the <code>viewDidLoad</code> code that calls it:</p>
<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];

    //Loading the first dynamic library here works fine :)
    NSLog(@&quot;Before referencing CASHello in DynamicFramework1&quot;);
    [self loadCASHelloFromDynamicFramework1];

    /*
     Loading the second framework will give a message in
      the console saying that both classes will be loaded
      and referencing the class will result in undefined
      behavior.
    */

    NSLog(@&quot;Before referencing CASHello in DynamicFramework2&quot;);
    [self loadCASHelloFromDynamicFramework2];
}</code></pre>
<p>In general, if our app crashes before it even has run any code in our app, then it is good to switch on the Dynamic Loader diagnostic flags. There might be a deployment issue (not bundling the correct libraries), or a code signing issue.</p>
<h3 id="jablotron-crash">Jablotron crash</h3>
<p>The <code>Jablotron</code> program is a program that manages alarms and detectors in the home.</p>
<p>Here is a Crash Report where it has crashed, truncated for ease of demonstration:</p>
<pre><code>Incident Identifier: 732438C5-9E5A-48E7-95E2-76C800CDD6D9
CrashReporter Key:   181EC21F-295A-4D13-B14E-8BE1A7DFB5C7
Hardware Model:      iPhone3,1
Process:         MyJablotron_dev [177]
Path:            /var/mobile/Applications/
D3CC3D22-1B0F-4CAF-8F68-71AD3B211CD9/
MyJablotron_dev.app/MyJablotron_dev
Identifier:      net.jablonet.myjablotron.staging
Version:         3.3.0.14 (3.3.0.14)
Code Type:       ARM
Parent Process:  launchd [1]

Date/Time:       2016-05-24T07:59:56Z
Launch Time:     2016-05-24T07:57:08Z
OS Version:      iPhone OS 7.1.2 (11D257)
Report Version:  104

Exception Type:  SIGBUS
Exception Codes: BUS_ADRALN at 0xcd0b1c
Crashed Thread:  0

Thread 0 Crashed:
0   libswiftCore.dylib    0x011aed64 0xfba000 + 2051428
1   MyJablotron_dev       0x004e7c18 0xb2000 + 4414488
2   libswiftCore.dylib    0x011b007f 0xfba000 + 2056319
3   libswiftCore.dylib    0x011aff73 0xfba000 + 2056051
4   libswiftCore.dylib    0x011adf29 0xfba000 + 2047785
5   libswiftCore.dylib    0x011adf73 0xfba000 + 2047859
6   MyJablotron_dev       0x00614a6c
 type metadata accessor for
 MyJablotron.CDFM&lt;MyJablotron.ChartDataPointStructure,
  MyJablotron.ChartDataPointStructureLegend&gt;
   (ChartThermoPlotSpace.swift:0)
7   MyJablotron_dev                      0x00606698
 MyJablotron.ChartThermoPlotSpace.init ()
 MyJablotron.ChartThermoPlotSpace
  (ChartThermoPlotSpace.swift:206)
8   MyJablotron_dev                      
0x00606c60
 MyJablotron.ChartThermoPlotSpace.__allocating_init ()
 MyJablotron.ChartThermoPlotSpace
 (ChartThermoPlotSpace.swift:0)
9   MyJablotron_dev                      
0x0048825c
 MyJablotron.ChartBase.initWithThermometer
  (__ObjC.Thermometer)()
  (ChartBase.swift:139)
10  MyJablotron_dev                      0x00488034
 MyJablotron.ChartBase.initWithSegment (__ObjC.Segment)()
  (ChartBase.swift:123)
11  MyJablotron_dev                      0x0059186c
 MyJablotron.ChartViewController.setupSegment ()()
  (ChartViewController.swift:106)
12  MyJablotron_dev                      0x0058f374
 MyJablotron.ChartViewController.viewDidLoad ()()
  (ChartViewController.swift:39)
13  MyJablotron_dev                      0x0058f5a4
 @objc MyJablotron.ChartViewController.viewDidLoad ()()
  (ChartViewController.swift:0)
14  UIKit                                0x3227d4ab
 -[UIViewController loadViewIfRequired] + 516
15  UIKit                                0x3227d269
 -[UIViewController view] + 22
16  UIKit                                0x3240936b
 -[UINavigationController
 _startCustomTransition:] + 632
17  UIKit                                0x32326d63
 -[UINavigationController
  _startDeferredTransitionIfNeeded:] + 416
18  UIKit                                0x32326b6d
 -[UINavigationController
 __viewWillLayoutSubviews] + 42
19  UIKit                                0x32326b05
 -[UILayoutContainerView layoutSubviews] + 182
20  UIKit                                0x32278d59
 -[UIView(CALayerDelegate)
 layoutSublayersOfLayer:] + 378
21  QuartzCore                           0x31ef662b
 -[CALayer layoutSublayers] + 140
22  QuartzCore                           0x31ef1e3b
 CA::Layer::layout_if_needed(CA::Transaction*) + 348
23  QuartzCore                           0x31ef1ccd
 CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 14
24  QuartzCore                           0x31ef16df
 CA::Context::commit_transaction(CA::Transaction*) + 228
25  QuartzCore                           0x31ef14ef
 CA::Transaction::commit() + 312
26  QuartzCore                           0x31eeb21d
 CA::Transaction::observer_callback(__CFRunLoopObserver*,
    unsigned long, void*) + 54
27  CoreFoundation                       0x2fa27255
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__
 + 18
28  CoreFoundation                       0x2fa24bf9
 __CFRunLoopDoObservers + 282
29  CoreFoundation                       0x2fa24f3b
 __CFRunLoopRun + 728
30  CoreFoundation                       0x2f98febf
 CFRunLoopRunSpecific + 520
31  CoreFoundation                       0x2f98fca3
 CFRunLoopRunInMode + 104
32  GraphicsServices                     0x34895663
 GSEventRunModal + 136
33  UIKit                                0x322dc14d
 UIApplicationMain + 1134
34  MyJablotron_dev                      0x002b0683
 main (main.m:16)
35  libdyld.dylib                        0x3a719ab7
 start + 0</code></pre>
<p>We can see the crash is in the Swift Core runtime library. When we see a crash in common code, from Apple, it usually indicates a misuse of APIs. In those cases, we expect to see a descriptive error.</p>
<p>In this example, we get a bus alignment error. Apple’s library code accessed a memory address improperly for the CPU architecture.</p>
<p>This is a surprise. Sometimes when we use an advanced feature, or set compiler optimization settings, we can trigger errors in special cases or in lesser used code paths.</p>
<p>We see that the problem is during object initialization time:</p>
<pre><code>6   MyJablotron_dev                      0x00614a6c
 type metadata accessor for
 MyJablotron.CDFM&lt;MyJablotron.ChartDataPointStructure,
  MyJablotron.ChartDataPointStructureLegend&gt;
   (ChartThermoPlotSpace.swift:0)
7   MyJablotron_dev                      0x00606698
 MyJablotron.ChartThermoPlotSpace.init ()
 MyJablotron.ChartThermoPlotSpace
  (ChartThermoPlotSpace.swift:206)
8   MyJablotron_dev                      0x00606c60
 MyJablotron.ChartThermoPlotSpace.__allocating_init ()
 MyJablotron.ChartThermoPlotSpace (ChartThermoPlotSpace.swift:0)</code></pre>
<p>The “metadata accessor” phrase is interesting as it implies we are running code that the compiler generates rather than code we have directly written. Perhaps, as a workaround, we could simplify the code to use simpler language features.</p>
<p>Here we should aim to write a simple test case by taking the <code>ChartThermoPlotSpace</code> class and simplifying it until we get the essential code for the crash to occur.</p>
<p>This crash was resolved by Apple updating their compiler to correct a Swift Generics bug.</p>
<h1 id="application-abort-crashes">Application Abort Crashes</h1>
<p>In this chapter, we study application abort crashes.</p>
<p>These crashes are distinguished by reporting Exception Type, <code>EXC_CRASH (SIGABRT)</code> in their Crash Report.</p>
<p>We look at a range of crashes obtained by searching the Internet.</p>
<h2 id="general-principles-1">General principles</h2>
<p>Many Operating System language support modules, and libraries, have code to detect fatal programming errors. In such circumstances, the application requests that the Operating System terminate the app. This gives rise to a <code>SIGABRT</code> crash.</p>
<p>There is not one particular reason for <code>SIGABRT</code>. Instead, we look at a variety of examples so that we can see the kinds of situation where they arise.</p>
<p>Sometimes the particular abort also supplies information in the <code>Application Specific Information</code> area of the Crash Report. If this does not reveal the details we require, it is often possible to locate the module that raised the abort, and reverse engineer the code to understand what specifically was the syndrome.</p>
<h2 id="kindle-create-crash">Kindle Create Crash</h2>
<p>Kindle Create is an application used by authors to create e-books from manuscripts, such as <code>docx</code> files. It makes heavy use of graphics via the QuartzCore library.</p>
<p>When previewing for publication it crashed with the following Crash Report, truncated for ease of demonstration:</p>
<pre><code>Process:               Kindle Create [3010]
Path:                  /Applications/Kindle Create.app/
Contents/MacOS/Kindle Create
Identifier:            com.amazon.kc
Version:               1.10 (1.10)
Code Type:             X86 (Native)
Parent Process:        ??? [1]
Responsible:           Kindle Create [3010]
User ID:               501

Crashed Thread:        16  Dispatch queue:
 com.apple.root.default-qos

Exception Type:        EXC_CRASH (SIGABRT)
Exception Codes:       0x0000000000000000, 0x0000000000000000
Exception Note:        EXC_CORPSE_NOTIFY

Application Specific Information:
abort() called

Application Specific Signatures:
Graphics kernel error: 0xfffffffb

Thread 16 Crashed:: Dispatch queue: com.apple.root.default-qos
0   libsystem_kernel.dylib          0xa73e7ed6
__pthread_kill + 10
1   libsystem_pthread.dylib         0xa75a0427
pthread_kill + 363
2   libsystem_c.dylib               0xa7336956
abort + 133
3   libGPUSupportMercury.dylib      0xa2aa342d
 gpusGenerateCrashLog + 160
4   com.apple.AMDRadeonX4000GLDriver    0x180cbb00
 gpusKillClientExt + 23
5   libGPUSupportMercury.dylib      0xa2aa4857
 gpusSubmitDataBuffers + 157
6   com.apple.AMDRadeonX4000GLDriver    0x180a293c
 glrATI_Hwl_SubmitPacketsWithToken + 143
7   com.apple.AMDRadeonX4000GLDriver    0x180fd9b0
 glrFlushContextToken + 68
8   libGPUSupportMercury.dylib      0xa2aa88c8
 gldFlushContext + 24
9   GLEngine                        0x9b416f5b
 glFlushRender_Exec + 37
10  com.apple.QuartzCore            0x9c1c8412
 CA::(anonymous namespace)::IOSurface::detach() + 166
11  com.apple.QuartzCore            0x9c1c7631
 CAOpenGLLayerDraw(CAOpenGLLayer*, double, CVTimeStamp const*,
    unsigned int) + 1988
12  com.apple.QuartzCore            0x9c1c6c9a
 -[CAOpenGLLayer _display] + 618
13  com.apple.QuartzCore            0x9c179f62
 -[CALayer display] + 158
14  com.apple.AppKit                0x916106ac
 -[NSOpenGLLayer display] + 305
15  com.apple.QuartzCore            0x9c1c9f77
 display_callback(void*, void*) + 59
16  com.apple.QuartzCore            0x9c1c9efa
 CA::DispatchGroup::dispatch(bool) + 88
17  com.apple.QuartzCore            0x9c1c9e9a
 CA::DispatchGroup::callback_0(void*) + 16
18  libdispatch.dylib               0xa72565dd
 _dispatch_client_callout + 50
19  libdispatch.dylib               0xa7263679
 _dispatch_queue_override_invoke + 779
20  libdispatch.dylib               0xa725818b
 _dispatch_root_queue_drain + 660
21  libdispatch.dylib               0xa7257ea5
 _dispatch_worker_thread3 + 100
22  libsystem_pthread.dylib         0xa759cfa5
 _pthread_wqthread + 1356
23  libsystem_pthread.dylib         0xa759ca32
 start_wqthread + 34

Thread 16 crashed with X86 Thread State (32-bit):
  eax: 0x00000000  ebx: 0xb0a79000  ecx: 0xb0a78acc
    edx: 0x00000000
  edi: 0xa75a02ca  esi: 0x0000002d  ebp: 0xb0a78af8
    esp: 0xb0a78acc
   ss: 0x00000023  efl: 0x00000206  eip: 0xa73e7ed6
      cs: 0x0000000b
   ds: 0x00000023   es: 0x00000023   fs: 0x00000023
      gs: 0x0000000f
  cr2: 0xa9847340

Logical CPU:     0
Error Code:      0x00080148
Trap Number:     132

Binary Images:

0x18099000 - 0x1815efff  com.apple.AMDRadeonX4000GLDriver
 (1.68.20 - 1.6.8)
 &lt;DF3BB959-0C0A-3B6C-8E07-11B332128555&gt;
  /System/Library/Extensions/AMDRadeonX4000GLDriver.bundle/
  Contents/MacOS/AMDRadeonX4000GLDriver

0xa2aa2000 - 0xa2aacfff  libGPUSupportMercury.dylib
 (16.7.4)
 &lt;C71E29CF-D4C5-391D-8B7B-739FB0536387&gt;
  /System/Library/PrivateFrameworks/GPUSupport.framework/
  Versions/A/Libraries/libGPUSupportMercury.dylib
</code></pre>
<p>From the stack backtrace we see that the OpenGL pipeline was flushed. This caused <code>com.apple.AMDRadeonX4000GLDriver</code> to detect a problem with the commands and trigger a crash. We see that the code contributes custom information to the Crash Report.</p>
<pre><code>3   libGPUSupportMercury.dylib      0xa2aa342d
 gpusGenerateCrashLog + 160</code></pre>
<p>We can use the Hopper Disassembler and reverse engineering tool here.</p>
<p>By locating the binary on our Mac, we can ask Hopper to not only dissemble the code in question, but to also produce pseudocode. For most developers, keeping an understanding of assembly code fresh in the mind is difficult because assembly code is rarely hand written nowadays. This is why the pseudocode output is most valuable.</p>
<p>We first find the location of the binary from the <code>Binary Images</code> section of the Crash Report.</p>
<pre><code>/System/Library/PrivateFrameworks/GPUSupport.framework/
Versions/A/Libraries/libGPUSupportMercury.dylib</code></pre>
<p>Traversing the file hierarchy can be cumbersome for system binaries as they are deeply nested in the file system.</p>
<p>If Hopper is <strong>already running</strong>, a quick way to select the correct file is to use the command line.</p>
<pre><code>&#39;/Applications/Hopper Disassembler v4.app/Contents/
MacOS/hopper&#39; -e /System/Library/PrivateFrameworks/
GPUSupport.framework/Versions/A/Libraries/
libGPUSupportMercury.dylib</code></pre>
<p>If Hopper is not running, we can launch it. Alongside we can launch the Finder program and select ‘Go To Folder’ to select the folder</p>
<pre><code>/System/Library/PrivateFrameworks/GPUSupport.framework/
Versions/A/Libraries/</code></pre>
<p><img src="screenshots/finder_support_mercury.png" /></p>
<p>Then we can simply drag <code>libGPUSupportMercury.dylib</code> from the Finder into the main panel of the Hopper App and it will start processing the file.</p>
<p><img src="screenshots/drag_file_to_hopper.png" /></p>
<p>We need to select the architecture to disassemble. It must match what we are diagnosing. From the Crash Report, we can see that it is a <code>Code Type</code> <code>X86 (Native)</code>. This means we need to select the 32-bit architecture option in Hopper.</p>
<p><img src="screenshots/hopper_32bit.png" /></p>
<p>Then we click Next, and then OK.</p>
<p>After a moment, the file will be processed. Then we can select <em>Navigate -&gt; Go To Address or Symbol</em> and provide the address <code>_gpusGenerateCrashLog</code> Note, we have a leading underscore. The C compiler puts that in automatically before generating the object file. Historically it was done that way so that hand written assembly code would not conflict with C programming language symbols during linking.</p>
<p>In the default view, Hopper will show the disassembly for the function.</p>
<p><img src="screenshots/hopper_diss.png" /></p>
<p>By selecting the pseudocode button, shown circled in red, we get Hopper to produce a more easily understandable description of the function.</p>
<p><img src="screenshots/hopper_pseudocode.png" /></p>
<p>Here is the output of hopper:</p>
<pre><code>int _gpusGenerateCrashLog(int arg0, int arg1, int arg2) {
 rdi = arg0;
 r14 = arg2;
 rbx = arg1;
 if (*0xc678 != 0x0) {
   rax = *___stack_chk_guard;
   if (rax != *___stack_chk_guard) {
     rax = __stack_chk_fail();
   }  
 }
 else {
   if (rdi != 0x0) {
     IOAccelDeviceGetName(*(rdi + 0x230), 0x0, 0x14);
   }  
   if ((rbx &amp; 0x20000000) == 0x0) {
     rdx =
     &quot;Graphics kernel error: 0x%08x\n&quot;;
   }  
   else {
     rdx =
  &quot;Graphics hardware encountered an error and was reset:
   0x%08x\n&quot;;
   }  
   sprintf_l(var_A0, 0x0, rdx);
   *0xc680 = var_A0;
   rax = abort();
 }
 return rax;
}
</code></pre>
<p>Here we can see two alternatives. Either we just report:</p>
<pre><code>&quot;Graphics kernel error: 0x%08x\n&quot;</code></pre>
<p>or we report:</p>
<pre><code>&quot;Graphics hardware encountered an error and was reset: 0x%08x\n&quot;</code></pre>
<p>In fact, we see the following in the Crash Report:</p>
<pre><code>Application Specific Signatures:
Graphics kernel error: 0xfffffffb</code></pre>
<p>Unfortunately, it is not clear what this error means. We need the author of the app to switch on OpenGL command level logging in order to understand what drawing command was rejected by the graphics driver.</p>
<p>Using a different Mac with a different graphics card would be an interesting experiment to understand if we have a driver-specific issue, or a generic OpenGL problem.</p>
<h2 id="type-confusion">Type confusion</h2>
<p>The compiler does an excellent job of static type checking. When types are inferred dynamically problems can arise. Configuration files are further troublesome in this area. It can be easy to set the wrong type for a configuration parameter.</p>
<p>We use the example code, <code>icdab_nsdata</code>, to illustrate our point. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<h3 id="extracting-nsdata-from-a-configuration-file">Extracting NSData from a configuration file</h3>
<p>Consider the example code:</p>
<pre><code>- (BOOL)application:(UIApplication *)application
 didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    // Override point for customization after application
    // launch.

    NSData *myToken = [[NSData alloc] initWithData:
    [[NSUserDefaults standardUserDefaults]
     objectForKey:@&quot;SomeKey&quot;]];

    NSLog(@&quot;My data is %@ - ok since we can handle a nil&quot;,
     myToken);

    id stringProperty = @&quot;Some string&quot;;
    NSData *problemToken = [[NSData alloc]
     initWithData:stringProperty];

    NSLog(@&quot;My data is %@ - we have probably crashed by now&quot;,
     problemToken);
    return YES;
}</code></pre>
<p>This code tries to do two things. Firstly, it tries to get a data token from its configuration. We assume from a previous run, the user defaults saved an <code>NSData</code> token under the key <code>SomeKey</code></p>
<p>By design, the <code>NSData</code> abstraction can handle whether the supplied data is <code>nil</code>. So if no token has yet been set, we are still ok.</p>
<p>It might be the case that the token data is just a simple hex string like <code>7893883873a705aec69e2942901f20d7b1e28dec</code></p>
<p>The above code has <code>stringProperty</code> that is supposed to model the case where the data token was recorded as a string in the user defaults instead of as <code>NSData</code>. Perhaps it was manually copy-pasted into the <code>plist</code> file of the user defaults. If the <code>initWithData</code> method is passed an <code>NSString</code> it cannot create an <code>NSData</code> object. We get a crash.</p>
<p>If we run the code, we get the following Crash Report, truncated for ease of demonstration:</p>
<h3 id="deserialization-crash-report">Deserialization Crash Report</h3>
<pre><code>Incident Identifier: 83DD2BB9-9C75-4BE5-98E5-FD3FD9CCC604
CrashReporter Key:   d3e622273dd1296e8599964c99f70e07d25c8ddc
Hardware Model:      iPhone12,1
Process:             icdab_nsdata [842]
Path:               
 /private/var/containers/Bundle/Application/93CF6ABD-2876-4DEA-9B
4D-0123C5CD8AE2/icdab_nsdata.app/icdab_nsdata
Identifier:          www.perivalebluebell.icdab-nsdata
Version:             1 (1.0)
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           www.perivalebluebell.icdab-nsdata [1021]

Date/Time:           2020-10-12 14:14:37.8842 +0100
Launch Time:         2020-10-12 14:14:37.7953 +0100
OS Version:          iPhone OS 14.2 (18B5061e)
Release Type:        Beta
Baseband Version:    2.02.00
Report Version:      104

Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Triggered by Thread:  0

Application Specific Information:
abort() called

Last Exception Backtrace:
0   CoreFoundation                      0x1aa7cc904
 __exceptionPreprocess + 220
1   libobjc.A.dylib                     0x1bf1fbc50
 objc_exception_throw + 59
2   CoreFoundation                      0x1aa6d3b0c -[NSObject+
 183052 (NSObject) doesNotRecognizeSelector:] + 143
3   CoreFoundation                      0x1aa7cf4d0
 ___forwarding___ + 1443
4   CoreFoundation                      0x1aa7d17d0
 _CF_forwarding_prep_0 + 95
5   Foundation                          0x1aba6eabc
 -[_NSPlaceholderData initWithData:] + 131
6   icdab_nsdata                        0x10061e61c -[AppDelegate
 application:didFinishLaunchingWithOptions:] + 26140
 (AppDelegate.m:26)
7   UIKitCore                           0x1ad170604
 -[UIApplication
 _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] +
 359
.
.
.</code></pre>
<p>Furthermore, we get the following information in the system log (console log of the app):</p>
<pre><code>2020-10-12 14:29:55.024195+0100 icdab_nsdata[881:101507] 
My data is {length = 0, bytes = 0x} - ok since we can handle a
 nil
2020-10-12 14:29:55.024276+0100 icdab_nsdata[881:101507] 
-[__NSCFConstantString _isDispatchData]: unrecognized selector
 sent to instance 0x1042480a8
2020-10-12 14:29:55.024403+0100 icdab_nsdata[881:101507] 
*** Terminating app due to uncaught exception
 &#39;NSInvalidArgumentException&#39;, reason: &#39;-[__NSCFConstantString
 _isDispatchData]: unrecognized selector sent to instance
 0x1042480a8&#39;
*** First throw call stack:
(0x1aa7cc904 0x1bf1fbc50 0x1aa6d3b0c 0x1aa7cf4d0 0x1aa7d17d0
 0x1aba6eabc 0x10424661c 0x1ad170604 0x1ad17266c 0x1ad1780c8
 0x1ac7d0e28 0x1acd3e0ac 0x1ac7d19c0 0x1ac7d13c8 0x1ac7d17d0
 0x1ac7d100c 0x1ac7d9558 0x1acc4ad90 0x1acd567d4 0x1ac7d9250
 0x1ac600fac 0x1ac5ff920 0x1ac600bd4 0x1ad176268 0x1acc745bc
 0x1b9fa4afc 0x1b9fd0444 0x1b9fb3be0 0x1b9fd0108 0x104559780
 0x10455d0c0 0x1b9ff8990 0x1b9ff8620 0x1b9ff8b74 0x1aa7487f8
 0x1aa7486f4 0x1aa7479ec 0x1aa741b18 0x1aa7412a8 0x1c1ccc784
 0x1ad1742c4 0x1ad179b38 0x1042464b4 0x1aa4016c0)
libc++abi.dylib: terminating with uncaught exception of type
 NSException
*** Terminating app due to uncaught exception
 &#39;NSInvalidArgumentException&#39;, reason: &#39;-[__NSCFConstantString
 _isDispatchData]: unrecognized selector sent to instance
 0x1042480a8&#39;</code></pre>
<p>From here we can see the problem is that <code>__NSCFConstantString</code> is unable to respond to <code>_isDispatchData</code> because <code>NSString</code> is not a data providing object.</p>
<p>The Apple SDKs have private implementation classes to support the public abstractions we consume. Error reports will refer to these private classes. Therefore, their names can be unfamiliar.</p>
<p>An easy way to gather our compass, and figure out what concrete representations map to which abstraction is to search for the class type definition.</p>
<p>Conveniently, other engineers have run a tool over all frameworks to generate the Objective-C class definitions and have stored them on GitHub. They use the <code>class-dump</code> tool. This makes all private framework symbols for Objective-C easily searchable.</p>
<p>We can find the definition of <code>_isDispatchData</code>. <span class="citation" data-cites="dispatchdata">(“NSDispatchData.h in Foundation.framework” 2018)</span></p>
<pre><code>/* Generated by RuntimeBrowser
   Image: /System/Library/Frameworks/Foundation.framework/
   Foundation
 */

@interface _NSDispatchData : NSData

+ (bool)supportsSecureCoding;

- (bool)_allowsDirectEncoding;
- (id)_createDispatchData;
- (bool)_isDispatchData;
- (Class)classForCoder;
- (id)copyWithZone:(struct _NSZone { }*)arg1;
- (void)encodeWithCoder:(id)arg1;
- (void)enumerateByteRangesUsingBlock:(id /* block */)arg1;
- (void)getBytes:(void*)arg1;
- (void)getBytes:(void*)arg1 length:(unsigned long long)arg2;
- (void)getBytes:(void*)arg1 range:(struct _NSRange
   { unsigned long long x1; unsigned long long x2; })arg2;
- (unsigned long long)hash;
- (id)initWithCoder:(id)arg1;
- (id)subdataWithRange:(struct _NSRange
  { unsigned long long x1; unsigned long long x2; })arg1;

@end</code></pre>
<p>Similarly, we can look up <code>__NSCFConstantString</code>. <span class="citation" data-cites="cfconstantstring">(“NSCFConstantString in Corefoundation.framework” 2018)</span></p>
<pre><code>/* Generated by RuntimeBrowser
   Image: /System/Library/Frameworks/CoreFoundation.framework/
   CoreFoundation
 */

@interface __NSCFConstantString : __NSCFString

- (id)autorelease;
- (id)copyWithZone:(struct _NSZone { }*)arg1;
- (bool)isNSCFConstantString__;
- (oneway void)release;
- (id)retain;
- (unsigned long long)retainCount;

@end</code></pre>
<h2 id="not-a-number-errors">‘Not A Number’ Errors</h2>
<p>In this section, we show an abort arising from bad floating point data.</p>
<p>We use an example of the <code>securityAgent</code> crashing on macOS.</p>
<p>The Crash Report we see is as follows, truncated for ease of demonstration:</p>
<pre><code>Process:               SecurityAgent [99429]
Path:                  /System/Library/Frameworks/
Security.framework/Versions/A/MachServices/
SecurityAgent.bundle/Contents/
MacOS/SecurityAgent
Identifier:            com.apple.SecurityAgent
Version:               9.0 (55360.50.13)
Build Info:            SecurityAgent-55360050013000000~642
Code Type:             X86-64 (Native)
Parent Process:        launchd [1]
Responsible:           SecurityAgent [99429]
User ID:               92

Date/Time:             2018-06-18 21:39:08.261 +0100
OS Version:            Mac OS X 10.13.4 (17E202)
Report Version:        12
Anonymous UUID:        00CC683B-425F-ABF0-515A-3ED73BACDDB5

Sleep/Wake UUID:       8D3EF33B-B78C-4C76-BB7B-2F2AC3A11CEB

Time Awake Since Boot: 350000 seconds
Time Since Wake:       42 seconds

System Integrity Protection: enabled

Crashed Thread:        0  Dispatch queue:
 com.apple.main-thread

Exception Type:        EXC_CRASH (SIGABRT)
Exception Codes:       0x0000000000000000, 0x0000000000000000
Exception Note:        EXC_CORPSE_NOTIFY

Application Specific Information:
*** Terminating app due to uncaught exception
&#39;CALayerInvalidGeometry&#39;, reason:
 &#39;CALayer bounds contains NaN: [nan nan; 1424 160]&#39;
terminating with uncaught exception of type NSException
abort() called

Application Specific Backtrace 1:
0   CoreFoundation                      0x00007fff4590132b
 __exceptionPreprocess + 171
1   libobjc.A.dylib                     0x00007fff6cf7bc76
objc_exception_throw + 48
2   CoreFoundation                      0x00007fff45992dcd
+[NSException raise:format:] + 205
3   QuartzCore                          0x00007fff50ba1a72
_ZN2CA5Layer10set_boundsERKNS_4RectEb + 230
4   QuartzCore                          0x00007fff50ba190b
-[CALayer setBounds:] + 251
5   AppKit                              0x00007fff42e5ccad
-[_NSClipViewBackingLayer setBounds:] + 105
6   AppKit                              0x00007fff42e20bf0
 -[NSView(NSInternal) _updateLayerGeometryFromView] + 712
7   AppKit                              0x00007fff42eef7a2
-[NSView translateOriginToPoint:] + 191
8   AppKit                              0x00007fff42eef383
-[NSClipView _immediateScrollToPoint:] + 536
9   AppKit                              0x00007fff432c4de9
-[NSScrollAnimationHelper _doFinalAnimationStep] + 147
10  AppKit                              0x00007fff43226da2
-[NSAnimationHelper _stopRun] + 44
11  AppKit                              0x00007fff42eef089
-[NSClipView scrollToPoint:] + 202
12  AppKit                              0x00007fff42f2ab7f
-[NSScrollView scrollClipView:toPoint:] + 75
13  AppKit                              0x00007fff42ed5929
-[NSClipView _scrollTo:animateScroll:
flashScrollerKnobs:] + 1273
14  AppKit                              0x00007fff434d5750
 -[_NSScrollingConcurrentMainThreadSynchronizer
_scrollToCanonicalOrigin] + 935
15  AppKit                              0x00007fff43071d74
 -[_NSScrollingConcurrentMainThreadSynchronizer
_synchronize:completionHandler:] + 174
16  AppKit                              0x00007fff43071c94
 __80-[_NSScrollingConcurrentMainThreadSynchronizer
initWithSharedData:constantData:]_block_invoke + 145
17  libdispatch.dylib                   0x00007fff6db5be08
_dispatch_client_callout + 8
18  libdispatch.dylib                   0x00007fff6db6eed1
_dispatch_continuation_pop + 472
19  libdispatch.dylib                   0x00007fff6db5e0d1
_dispatch_source_invoke + 620
20  libdispatch.dylib                   0x00007fff6db67271
_dispatch_main_queue_callback_4CF + 776
21  CoreFoundation                      0x00007fff458b9c69
 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9
22  CoreFoundation                      0x00007fff4587be4a
 __CFRunLoopRun + 2586
23  CoreFoundation                      0x00007fff4587b1a3
CFRunLoopRunSpecific + 483
24  HIToolbox                           0x00007fff44b63d96
RunCurrentEventLoopInMode + 286
25  HIToolbox                           0x00007fff44b63b06
ReceiveNextEventCommon + 613
26  HIToolbox                           0x00007fff44b63884
 _BlockUntilNextEventMatchingListInModeWithFilter + 64
27  AppKit                              0x00007fff42e16a73
 _DPSNextEvent + 2085
28  AppKit                              0x00007fff435ace34
 -[NSApplication(NSEvent) _nextEventMatchingEventMask:
 untilDate:inMode:dequeue:] + 3044
29  AppKit                              0x00007fff42e0b885
 -[NSApplication run] + 764
30  AppKit                              0x00007fff42ddaa72
 NSApplicationMain + 804
31  SecurityAgent                       0x00000001007bb8b8
 main + 475
32  libdyld.dylib                       0x00007fff6db95015
 start + 1

Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libsystem_kernel.dylib          0x00007fff6dce5b6e
 __pthread_kill + 10
1   libsystem_pthread.dylib         0x00007fff6deb0080
 pthread_kill + 333
2   libsystem_c.dylib               0x00007fff6dc411ae
 abort + 127
3   libc++abi.dylib                 0x00007fff6bb45f8f
 abort_message + 245
4   libc++abi.dylib                 0x00007fff6bb4612b
default_terminate_handler() + 265
5   libobjc.A.dylib                 0x00007fff6cf7dea3
 _objc_terminate() + 97
6   libc++abi.dylib                 0x00007fff6bb617c9
 std::__terminate(void (*)()) + 8
7   libc++abi.dylib                 0x00007fff6bb61843
 std::terminate() + 51
8   libdispatch.dylib               0x00007fff6db5be1c
_dispatch_client_callout + 28
9   libdispatch.dylib               0x00007fff6db6eed1
 _dispatch_continuation_pop + 472
10  libdispatch.dylib               0x00007fff6db5e0d1
_dispatch_source_invoke + 620
11  libdispatch.dylib               0x00007fff6db67271
_dispatch_main_queue_callback_4CF + 776
12  com.apple.CoreFoundation        0x00007fff458b9c69
 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9
13  com.apple.CoreFoundation        0x00007fff4587be4a
 __CFRunLoopRun + 2586
14  com.apple.CoreFoundation        0x00007fff4587b1a3
CFRunLoopRunSpecific + 483
15  com.apple.HIToolbox             0x00007fff44b63d96
RunCurrentEventLoopInMode + 286
16  com.apple.HIToolbox             0x00007fff44b63b06
ReceiveNextEventCommon + 613
17  com.apple.HIToolbox             0x00007fff44b63884
 _BlockUntilNextEventMatchingListInModeWithFilter + 64
18  com.apple.AppKit                0x00007fff42e16a73
 _DPSNextEvent + 2085
19  com.apple.AppKit                0x00007fff435ace34
 -[NSApplication(NSEvent)
 _nextEventMatchingEventMask:untilDate:inMode:dequeue:]
  + 3044
20  com.apple.AppKit                0x00007fff42e0b885
-[NSApplication run] + 764
21  com.apple.AppKit                0x00007fff42ddaa72
 NSApplicationMain + 804
22  com.apple.SecurityAgent         0x00000001007bb8b8
 main + 475
23  libdyld.dylib                   0x00007fff6db95015
 start + 1</code></pre>
<p>This crash shows an excellent example of placing informative information into the Crash Report. We know immediately we have NAN (Not A Number) floating point values in our layer bounds, and this is the reason for aborting.</p>
<pre><code>&#39;CALayer bounds contains NaN: [nan nan; 1424 160]&#39;</code></pre>
<p>Perhaps a data structure has not been initialized, or a division by zero has occurred. Often geometry code creates ratios of width / height. During startup or corner cases our frames might be zero sized, thus leading to divide by zero errors resulting in NAN values in our data structures.</p>
<p>We notice that some long functions are used by Quartz (the Geometric Drawing Framework). In the stack backtrace we see:</p>
<pre><code>3   QuartzCore                          0x00007fff50ba1a72
_ZN2CA5Layer10set_boundsERKNS_4RectEb + 230</code></pre>
<p>As an academic exercise we can pin point which of the many error handle cases is the one in play here. Our backtrace here is not the leaf call, so the offset is the address where computation will resume after the function call has returned.</p>
<p>Using the Hopper tool, we can search for the symbol</p>
<pre><code>__ZN2CA5Layer10set_boundsERKNS_4RectEb</code></pre>
<p>in the binary</p>
<pre><code>/System/Library/Frameworks/QuartzCore.framework/
Versions/A/QuartzCore</code></pre>
<p>Note how we introduce an additional leading underscore to the function name when searching for it. This is due to the C Language Compiler.</p>
<p>We see:</p>
<pre><code>__ZN2CA5Layer10set_boundsERKNS_4RectEb:        
// CA::Layer::set_bounds(CA::Rect const&amp;, bool)
0000000000008e36 push       rbp
                    ; CODE XREF=-[CALayer setBounds:]+246,
                    __ZN2CA5Layer10set_boundsERKNS_4RectEb+750
0000000000008e37 mov        rbp, rsp
0000000000008e3a push       r15</code></pre>
<p>From hex address 8e36, if we add decimal 230, we get 0x8f1c. Looking at the disassembly:</p>
<pre><code>0000000000008edd  mov   rdi, qword [objc_cls_ref_NSException]
       ; argument &quot;instance&quot; for method _objc_msgSend
0000000000008ee4  movsd xmm0, qword [r12]
0000000000008eea  movsd xmm1, qword [r12+8]
0000000000008ef1  movsd xmm2, qword [r12+0x10]
0000000000008ef8  movsd xmm3, qword [r12+0x18]
0000000000008eff  mov   rsi, qword [0x27a338]
      ; @selector(raise:format:),
                       argument &quot;selector&quot;
                       for method _objc_msgSend
0000000000008f06  lea   rdx, qword
[cfstring_CALayerInvalidGeometry]
      ; @&quot;CALayerInvalidGeometry&quot;
0000000000008f0d  lea   rcx, qword
 [cfstring_CALayer_bounds_contains_NaN____g__g___g__g_]
      ; @&quot;CALayer bounds contains NaN: [%g %g; %g %g]&quot;
0000000000008f14  mov   al, 0x4
0000000000008f16  call  qword [_objc_msgSend_24d4f8]
      ; _objc_msgSend

                     loc_8f1c:
0000000000008f1c  call  __ZN2CA11Transaction13ensure_compatEv
       ; CA::Transaction::ensure_compat(),
        CODE XREF=__ZN2CA5Layer10set_boundsERKNS_4RectEb+61,
         __ZN2CA5Layer10set_boundsERKNS_4RectEb+70,
          __ZN2CA5Layer10set_boundsERKNS_4RectEb+137,
           __ZN2CA5Layer10set_boundsERKNS_4RectEb+147</code></pre>
<p>We can see that 8f1c is the next function call (after returning). The problem function call was done at address 8f16. We can also see the text of the string supplied to the Crash Report. <code>"CALayer bounds contains NaN: [%g %g; %g %g]"</code></p>
<h1 id="resource-crashes">Resource Crashes</h1>
<p>In this chapter, we look at resource related crashes. These are crashes induced by the Operating System due to incorrect or excessive resource usage. Resource crashes are indicated by the <code>Exception Type</code> <code>EXC_RESOURCE</code></p>
<h2 id="cpu-usage-crash">CPU Usage Crash</h2>
<p>The iOS platform can update itself. Here is an example where it has used up too much CPU time in performing the update.</p>
<p>The following Crash Report, truncated for ease of demonstration, shows the <code>UpdateBrainService</code> being terminated:</p>
<pre><code>Incident Identifier: 92F40C53-6BB8-4E13-A4C2-CF2F1C85E8DF
CrashReporter Key:   69face25f1299fdcbbe337b89e6a9f649818ba13
Hardware Model:      iPad4,4
Process:             
com.apple.MobileSoftwareUpdate.UpdateBrainService
 [147]
Path:                /private/var/run/
com.apple.xpcproxy.RoleAccount.staging/
com.apple.MobileSoftwareUpdate.
UpdateBrainService.16777219.47335.xpc/
com.apple.MobileSoftwareUpdate.UpdateBrainService
Identifier:          
com.apple.MobileSoftwareUpdate.UpdateBrainService
Version:             1 (1.0)
Code Type:           ARM-64 (Native)
Parent Process:      launchd [1]

Date/Time:           2015-02-03 20:14:05.504 -0800
Launch Time:         2015-02-03 20:11:35.306 -0800
OS Version:          iOS 8.1.2 (12B440)
Report Version:      105

Exception Type:  EXC_RESOURCE
Exception Subtype: CPU
Exception Message: (Limit 50%) Observed 60% over 180 secs
Triggered by Thread:  2

Thread 2 name:  Dispatch queue:
com.apple.root.default-qos
Thread 2 Attributed:
0   libsystem_kernel.dylib          
0x0000000196b9b1ec 0x196b98000 + 12780
1   ...reUpdate.UpdateBrainService
0x000000010008ac70 0x100080000 + 44144
2   ...reUpdate.UpdateBrainService
0x0000000100083678 0x100080000 + 13944
3   ...reUpdate.UpdateBrainService
0x000000010008b8e0 0x100080000 + 47328
4   ...reUpdate.UpdateBrainService
0x00000001000831e8 0x100080000 + 12776
5   ...reUpdate.UpdateBrainService
0x0000000100093478 0x100080000 + 78968
6   ...reUpdate.UpdateBrainService
0x000000010008e368 0x100080000 + 58216
7   ...reUpdate.UpdateBrainService
0x0000000100094548 0x100080000 + 83272
8   ...reUpdate.UpdateBrainService
0x000000010008ebb0 0x100080000 + 60336
9   libdispatch.dylib               
0x0000000196a713a8 0x196a70000 + 5032
10  libdispatch.dylib               
0x0000000196a71368 0x196a70000 + 4968
11  libdispatch.dylib               
0x0000000196a7d408 0x196a70000 + 54280
12  libdispatch.dylib               
0x0000000196a7e758 0x196a70000 + 59224
13  libsystem_pthread.dylib         
0x0000000196c4d2e0 0x196c4c000 + 4832
14  libsystem_pthread.dylib         
0x0000000196c4cfa4 0x196c4c000 + 4004

Thread 2 crashed with ARM Thread State (64-bit):
    x0: 0x0000000000000000   x1: 0x0000000000000000   
    x2: 0xffffffffffffffe8
       x3: 0x00000001004991c8
    x4: 0x0000000000000007   x5: 0x0000000000000018   
    x6: 0x0000000000000000
       x7: 0x0000000000000000
    x8: 0x2f6a6f72706c2e73   x9: 0x6166654448435354  
    x10: 0x5361746144746c75
      x11: 0x614264656b636174
   x12: 0x6166654448435354  x13: 0x5361746144746c75  
   x14: 0x614264656b636174
     x15: 0x007473696c702e72
   x16: 0x0000000000000154  x17: 0x00000001000cd2b1  
   x18: 0x0000000000000000
     x19: 0x000000010049963c
   x20: 0x0000000100499630  x21: 0x0000000000000000  
   x22: 0x000000014f001280
     x23: 0x0000000100499640
   x24: 0x000000014f001330  x25: 0x00000001004991a7  
   x26: 0x0000000100498c70
     x27: 0x000000019a75d0a8
   x28: 0x000000014f001330  fp: 0x0000000100499600   
   lr: 0x000000010008ac74
    sp: 0x0000000100498c50   pc: 0x0000000196b9b1ec
    cpsr: 0x80000000

Bad magic 0x86857EF8
Microstackshots: 1
(from 1969-12-31 20:33:03
   -0800 to 1969-12-31 20:33:03 -0800)
  1 ??? [0x16fd7fab0]
    1 CoreFoundation 0x1858ec000 + 37028
    [0x1858f50a4]
      1 ??? [0x16fd7f970]
        1 CoreFoundation 0x1858ec000 + 900644
        [0x1859c7e24]
          1 ??? [0x16fd7ec60]
            1 CoreFoundation 0x1858ec000 + 909008
            [0x1859c9ed0]
              1 ??? [0x16fd7ec00]
                1 libsystem_kernel.dylib 0x196b98000 + 3320
                 [0x196b98cf8]
                  1 ??? [0x16fd7ebb0]
                    1 libsystem_kernel.dylib 0x196b98000 + 3708
                     [0x196b98e7c]
                     *1 ??? [0xffffff8002012f08]</code></pre>
<p>Here it is quite clear that too much CPU resource was taken up by the <code>UpdateBrainService</code> program.</p>
<pre><code>Exception Type:  EXC_RESOURCE
Exception Subtype: CPU
Exception Message: (Limit 50%) Observed 60% over 180 secs</code></pre>
<p>The <code>Microstackshots</code> section of the report presumably tells us a sample of the stack at the time of termination. It seems that the <code>Bad magic</code> value reported varies but generally seems to be present with <code>EXC_RESOURCE</code> crashes.</p>
<h2 id="wake-up-crash">Wake Up Crash</h2>
<p>The iOS platform limits the number of Wake Ups. When a CPU interrupt occurs, the CPU wakes up to service some task. Typically it is when there is some IO to process, such as inbound networking data. If the platform wakes up too frequently, it can drain the battery. Therefore, the rate of wake ups is limited by the Operating System.</p>
<p>The following Crash Report, truncated for ease of demonstration, shows the <code>Snapchat</code> app being terminated:</p>
<pre><code>Incident Identifier: 79C39D6B-E4CA-4047-B96D-7EEED2B57B46
CrashReporter Key:   52be47ab0a43fb240756d6f5a1e1bcf4aa53c568
Hardware Model:      iPhone7,2
Process:             Snapchat [3151]
Path:                /private/var/mobile/Containers/
Bundle/Application/3E13B779-FFA3-491C-A018-F39E620553D4/
Snapchat.app/Snapchat
Identifier:          com.toyopagroup.picaboo
Version:             9.11.0.1 (9.11.0)
Code Type:           ARM-64 (Native)
Parent Process:      launchd [1]
Date/Time:           2015-07-05 20:00:52.228 +0200
Launch Time:         2015-07-05 19:42:01.054 +0200
OS Version:          iOS 8.3 (12F70)
Report Version:      105
Exception Type:      EXC_RESOURCE
Exception Subtype:   WAKEUPS
Exception Message:   
(Limit 150/sec) Observed 195/sec over 300 secs
Triggered by Thread: 21

Thread 21 name:  Dispatch queue:
 com.apple.avfoundation.videodataoutput.bufferqueue
Thread 21:
0       libsystem_kernel.dylib          0x193c9ce0c
 0x193c9c000 + 0xe0c
    // mach_msg_trap + 0x8
1       libsystem_kernel.dylib          0x193c9cc84
 0x193c9c000 + 0xc84
    // mach_msg + 0x44
2       IOKit                           0x182efdec0
 0x182ea8000 + 0x55ec0
    // io_connect_method + 0x168
3       IOKit                           0x182eadfd8
 0x182ea8000 + 0x5fd8
    // IOConnectCallMethod + 0xe4
4       IOSurface                       0x18bae515c
 0x18bae4000 + 0x115c
    // IOSurfaceClientLookup + 0xcc
5       IOSurface                       0x18bae90ec
 0x18bae4000 + 0x50ec
    // IOSurfaceLookup + 0x10
6       CoreMedia                       0x18252d9c8
 0x1824dc000 + 0x519c8
    // rqReceiverDequeue + 0x64
7       CoreMedia                       0x18252dd38
 0x1824dc000 + 0x51d38
    // __FigRemoteQueueReceiverSetHandler_block_invoke2 +
 0xa0
8       libdispatch.dylib               0x193b71950
 0x193b70000 + 0x1950
    // _dispatch_client_callout + 0xc
9       libdispatch.dylib               0x193b8800c
 0x193b70000 + 0x1800c
    // _dispatch_source_latch_and_call + 0x800
10      libdispatch.dylib               0x193b73ab8
 0x193b70000 + 0x3ab8
    // _dispatch_source_invoke + 0x11c
11      libdispatch.dylib               0x193b7c2d0
 0x193b70000 + 0xc2d0
    // _dispatch_queue_drain + 0x7d4
12      libdispatch.dylib               0x193b74a58
 0x193b70000 + 0x4a58
    // _dispatch_queue_invoke + 0x80
13      libdispatch.dylib               0x193b7e314
 0x193b70000 + 0xe314
    // _dispatch_root_queue_drain + 0x2cc
14      libdispatch.dylib               0x193b7fc48
 0x193b70000 + 0xfc48
    // _dispatch_worker_thread3 + 0x68
15      libsystem_pthread.dylib         0x193d51228
 0x193d50000 + 0x1228
    // _pthread_wqthread + 0x32c
16      libsystem_pthread.dylib         0x193d50eec
 0x193d50000 + 0xeec
    // start_wqthread + 0x0

Thread 21 crashed with ARM Thread State (64-bit):
    x0: 0x0000000000000000   x1: 0x0000000000000003   
    x2: 0x000000000000005c
       x3: 0x00000000000010bc
    x4: 0x0000000000017c37   x5: 0x0000000000000000   
    x6: 0x0000000000000000
       x7: 0x0000000000000000
    x8: 0x00000000fffffbbf   x9: 0x0000000000000b31  
    x10: 0x000000010f67fba0
      x11: 0x0000000000000000
   x12: 0x0000000000000000  x13: 0x0000000000000001  
   x14: 0x0000000000000001
     x15: 0x0000000000000000
   x16: 0xffffffffffffffe1  x17: 0x0000000000000000  
   x18: 0x0000000000000000
     x19: 0x0000000000000000
   x20: 0x0000000000000000  x21: 0x0000000000017c37  
   x22: 0x00000000000010bc
     x23: 0x000000010f67ea20
   x24: 0x0000000000000003  x25: 0x000000000000005c  
   x26: 0x0000000000000003
     x27: 0x000000010f67fbac
   x28: 0x0000000000000000  fp: 0x000000010f67e9f0   
   lr: 0x0000000193c9cc88
    sp: 0x000000010f67e9a0   pc: 0x0000000193c9ce0c
    cpsr: 0x80000000
Bad magic 0x8B3F36FC
Microstackshots: 1
(from 1970-01-01 01:03:20 +0100 to 1970-01-01 01:03:20 +0100)
  1 ??? [0x16fddb870]
    1 CoreFoundation 0x181bd4000 + 906872
    [0x181cb1678]
      1 ??? [0x16fddab60]
        1 CoreFoundation 0x181bd4000 + 915236
        [0x181cb3724]
          1 ??? [0x16fddab00]
            1 libsystem_kernel.dylib 0x193c9c000 + 3208
            [0x193c9cc88]
              1 ??? [0x16fddaab0]
                1 libsystem_kernel.dylib 0x193c9c000 + 3596
                 [0x193c9ce0c]
                 *1 ??? [0xffffff80020144a4]</code></pre>
<p>Similar to a CPU resource limit crash, we get an indication of the limit reached:</p>
<pre><code>Exception Type:      EXC_RESOURCE
Exception Subtype:   WAKEUPS
Exception Message:   (Limit 150/sec) Observed 195/sec over
 300 secs</code></pre>
<p>We also get a <code>Bad magic</code> value in the Crash Report followed by a snapshot of what was running at the point of termination.</p>
<p>We can see many threads running, related to Networking, Audio, and Video. We can guess that this application does its own heavy lifting in terms of presenting a video feed and this system level type code is either faulty or has a performance problem.</p>
<h2 id="wake-up-crash-exception">Wake Up crash exception</h2>
<p>The iOS platform can classify a wake up crash in some cases with an <code>Exception Code</code>.</p>
<p>For example faulty networking code gave rise to the following crash, truncated for ease of demonstration:</p>
<pre><code>Exception Type:  00000020
Exception Codes: 0xbad22222
Highlighted Thread:  3

Application Specific Information:
SBUnsuspendLimit ooVoo[360] exceeded 15 wakes in 300 sec

Thread 3 name:  com.apple.NSURLConnectionLoader
Thread 3:
0   libsystem_kernel.dylib          0x307fc010
 mach_msg_trap + 20
1   libsystem_kernel.dylib          0x307fc206
 mach_msg + 50
2   CoreFoundation                  0x3569b41c
__CFRunLoopServiceMachPort + 120
3   CoreFoundation                  0x3569a154
 __CFRunLoopRun + 876
4   CoreFoundation                  0x3561d4d6
 CFRunLoopRunSpecific + 294
5   CoreFoundation                  0x3561d39e
 CFRunLoopRunInMode + 98
6   Foundation                      0x3167abc2
+[NSURLConnection(Loader) _resourceLoadLoop:] + 302
7   Foundation                      0x3167aa8a
 -[NSThread main] + 66
8   Foundation                      0x3170e59a
 __NSThread__main__ + 1042
9   libsystem_c.dylib               0x30b68c16
 _pthread_start + 314
10  libsystem_c.dylib               0x30b68ad0
 thread_start + 0</code></pre>
<p>The code <code>0xbad22222</code> is read “Bad too many times” using “too” as a pun on “2”.</p>
<p>The ooVoo app makes heavy use of networking because it is a video chat platform.</p>
<p>This type of crash can be due to improper use of networking APIs. <span class="citation" data-cites="impropersockets">(“Improper Use of Bsd Sockets” 2018)</span></p>
<h2 id="temperature-crash">Temperature Crash</h2>
<p>The iOS platform can crash an app if the temperature gets too high. It is classified using an <code>Exception Code</code> <code>0xc00010ff</code></p>
<p>For example the iTrainAlarm app was terminated with the following Crash Report, truncated for ease of demonstration:</p>
<pre><code>Exception Type:  00000020
Exception Codes: 0xc00010ff
Highlighted Thread:  0

Application Specific Information:
Topmost application

Thermal Level:       16
Thermal Sensors:     11336 29078 5149 3419 3437

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0:
0   libsystem_kernel.dylib          0x35782010
 mach_msg_trap + 20
1   libsystem_kernel.dylib          0x35782206
 mach_msg + 50
2   AppSupport                      0x360d68c4
 CPDMTwoWayMessage + 140
3   AppSupport                      0x360d52f0
-[CPDistributedMessagingCenter _sendMessage:userInfoData:
oolKey:oolData:makeServer:receiveReply:nonBlocking:error:] + 408
4   AppSupport                      0x360d59a6
-[CPDistributedMessagingCenter _sendMessage:userInfo:
receiveReply:error:toTarget:selector:context:nonBlocking:] + 870
5   AppSupport                      0x360d3cfc
 -[CPDistributedMessagingCenter _sendMessage:userInfo:
 receiveReply:error:toTarget:selector:context:] + 56
6   AppSupport                      0x360d3b8a
 -[CPDistributedMessagingCenter
  sendMessageAndReceiveReplyName:userInfo:] + 42
7   libstatusbar.dylib              0x01997c1c
 0x1995000 + 11292
8   libstatusbar.dylib              0x01997da8
 0x1995000 + 11688
9   libstatusbar.dylib              0x01997d88
 0x1995000 + 11656
10  CoreFoundation                  0x33c337f8
__CFNotificationCenterAddObserver_block_invoke_0 + 116
11  CoreFoundation                  0x33c33904
____CFXNotificationPostToken_block_invoke_0 + 124
12  CoreFoundation                  0x33c3bb2a
__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 6
13  CoreFoundation                  0x33c3b158
 __CFRunLoopDoBlocks + 152
14  CoreFoundation                  0x33c3a37a
 __CFRunLoopRun + 1426
15  CoreFoundation                  0x33bbd4d6
 CFRunLoopRunSpecific + 294
16  CoreFoundation                  0x33bbd39e
 CFRunLoopRunInMode + 98
17  GraphicsServices                0x3832ffc6
 GSEventRunModal + 150
18  UIKit                           0x3162073c
 UIApplicationMain + 1084
19  iTrainAlarm                     0x000ffffc
 main (main.m:16)
20  iTrainAlarm                     0x000fffa0
 start + 32

Unknown thread crashed with unknown flavor: 5, state_count: 1</code></pre>
<p>From the <code>Exception Codes:</code> we see the code <code>0xc00010ff</code>. This is read as “Cool Off”.</p>
<p>The Crash Report, shown here, is clearly to do with temperature. It is not clear whether the problem is specific to the app currently running, the health of the hardware, or the environment the device was in at the time of the problem. None of the code running is known to generate large amounts of heat. To fix this issue, Analytic Troubleshooting is appropriate. For example, if this crash happens to other apps on the same device even when it is cold, we can suspect a hardware sensor failure. We need a complete picture of where the problem is seen versus not present to make progress with a good hypothesis.</p>
<p>Finally, the Crash Report notes:</p>
<pre><code>Unknown thread crashed with unknown flavor: 5, state_count: 1</code></pre>
<p>This can been seen for cases where the system terminates the app for resource related reasons.</p>
<p>From looking up the thread flavor in the Darwin XNU code, we see:</p>
<pre><code>#define THREAD_STATE_NONE       5</code></pre>
<p><span class="citation" data-cites="threadstatus">(“Thread Status Values in Mach” 2018)</span></p>
<p>So it just means that this is not something of concern. The Crash Report tool could do with improvement to identify this thread flavor, and report it.</p>
<h1 id="application-termination-crashes">Application Termination Crashes</h1>
<p>In this chapter, we study application termination crashes.</p>
<p>These crashes are distinguished by reporting Exception Type, <code>EXC_CRASH (SIGKILL)</code> in their Crash Report.</p>
<p>An application can be designed to catch signals sent to it. Typically in UNIX systems, server processes, called daemons, are designed to catch the SIGHUP signal. When it is received, the process would re-read its configuration file.</p>
<p>However, some signals, by design, cannot be caught. These are the SIGSTOP and SIGKILL signals.</p>
<h2 id="deadlock-crash">Deadlock Crash</h2>
<p>If a SQLite file is locked before an app suspends, the app is crashed. A Deadlock Termination Reason is supplied in the Crash Report.</p>
<p>As an example we show the OneMessenger app crash with the following Crash Report, truncated for ease of demonstration:</p>
<pre><code>Incident Identifier: A176CFB8-6BB7-4515-A4A2-82D2B962E097
CrashReporter Key:   f02957b828fe4090389c1282ca8e38393b4e133d
Hardware Model:      iPhone9,4
Process:             OneMessenger [10627]
Path:                /private/var/containers/Bundle/Application/
03E067E9-E2C1-43F4-AC53-4E4F58131FF3/
OneMessenger.app/OneMessenger
Identifier:          com.onem.adhoc
Version:             158 (1.0.4)
Code Type:           ARM-64 (Native)
Role:                Non UI
Parent Process:      launchd [1]
Coalition:           com.onem.adhoc [3747]


Date/Time:           2017-05-10 17:37:48.6201 -0700
Launch Time:         2017-05-10 17:37:46.7161 -0700
OS Version:          iPhone OS 10.3.1 (14E304)
Report Version:      104

Exception Type:  EXC_CRASH (SIGKILL)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Termination Reason: Namespace SPRINGBOARD, Code 0xdead10cc
Triggered by Thread:  0

Thread 0 name:
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x000000018a337224
 mach_msg_trap + 8
1   libsystem_kernel.dylib          0x000000018a33709c
 mach_msg + 72 (mach_msg.c:103)
2   CoreFoundation                  0x000000018b308e88
 __CFRunLoopServiceMachPort + 192 (CFRunLoop.c:2527)
3   CoreFoundation                  0x000000018b306adc
 __CFRunLoopRun + 1060 (CFRunLoop.c:2870)
4   CoreFoundation                  0x000000018b236d94
 CFRunLoopRunSpecific + 424 (CFRunLoop.c:3113)
5   GraphicsServices                0x000000018cca0074
GSEventRunModal + 100 (GSEvent.c:2245)
6   UIKit                           0x00000001914ef130
 UIApplicationMain + 208 (UIApplication.m:4089)
7   OneMessenger                    0x00000001004ff1b0
 main + 88 (main.m:16)
8   libdyld.dylib                   0x000000018a24559c
 start + 4

Thread 16 name:
Thread 16:
0   libsystem_kernel.dylib          0x000000018a3394dc
 fsync + 8
1   libsqlite3.dylib                0x000000018b8b704c
unixSync + 220 (sqlite3.c:33772)
2   libsqlite3.dylib                0x000000018b8b6a5c
sqlite3PagerCommitPhaseOne + 1428 (sqlite3.c:18932)
3   libsqlite3.dylib                0x000000018b8a35a0
sqlite3BtreeCommitPhaseOne + 180 (sqlite3.c:66409)
4   libsqlite3.dylib                0x000000018b872d68
sqlite3VdbeHalt + 2508 (sqlite3.c:77161)
5   libsqlite3.dylib                0x000000018b89cb7c
sqlite3VdbeExec + 56292 (sqlite3.c:82886)
6   libsqlite3.dylib                0x000000018b88e0e0
sqlite3_step + 528 (sqlite3.c:80263)
7   OneMessenger                    0x00000001003fc2bc
__25+[DataBase executeQuery:]_block_invoke + 72 (DataBase.m:1072)
8   libdispatch.dylib               0x000000018a2129e0
_dispatch_call_block_and_release + 24 (init.c:963)
9   libdispatch.dylib               0x000000018a2129a0
_dispatch_client_callout + 16 (object.m:473)
10  libdispatch.dylib               0x000000018a220ad4
_dispatch_queue_serial_drain + 928 (inline_internal.h:2431)
11  libdispatch.dylib               0x000000018a2162cc
_dispatch_queue_invoke + 884 (queue.c:4853)
12  libdispatch.dylib               0x000000018a220fa8
_dispatch_queue_override_invoke + 344 (queue.c:4890)
13  libdispatch.dylib               0x000000018a222a50
_dispatch_root_queue_drain + 540 (inline_internal.h:2468)
14  libdispatch.dylib               0x000000018a2227d0
_dispatch_worker_thread3 + 124 (queue.c:5550)
15  libsystem_pthread.dylib         0x000000018a41b1d0
_pthread_wqthread + 1096 (pthread.c:2196)
16  libsystem_pthread.dylib         0x000000018a41ad7c
 start_wqthread + 4</code></pre>
<p>Here we can see, in Thread 16, the app clearly uses SQLite. We see the termination reason:</p>
<pre><code>Termination Reason: Namespace SPRINGBOARD, Code 0xdead10cc</code></pre>
<p>Note how the word Deadlock is written as hexspeak 0xdead10cc.</p>
<h2 id="insecure-drawing-crash">Insecure Drawing Crash</h2>
<p>We can get an insecure drawing crash if our app tried to write to the screen when it was not allowed because, for example, the Lock Screen was being shown.</p>
<p>As an example we show the MobileSMS app crash with the following Crash Report, truncated for ease of demonstration:</p>
<pre><code>Incident Identifier: B076D47C-165E-4515-8E24-2C00CD307E2E
CrashReporter Key:   475d4ae82bdeca1824ec71225197c429060bb0e3
Hardware Model:      iPhone9,3
Process:             MobileSMS [3093]
Path:                /Applications/MobileSMS.app/MobileSMS
Identifier:          com.apple.MobileSMS
Version:             1.0 (5.0)
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           com.apple.MobileSMS [799]


Date/Time:           2018-05-06 10:26:42.2201 +0300
Launch Time:         2018-05-06 10:25:13.9579 +0300
OS Version:          iPhone OS 11.1.2 (15B202)
Baseband Version:    2.01.03
Report Version:      104

Exception Type:  EXC_CRASH (SIGKILL)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Termination Reason: Namespace SPRINGBOARD, Code 0x2bad45ec
Termination Description:
 SPRINGBOARD,
  Process detected doing insecure drawing while in secure mode
Triggered by Thread:  0

Filtered syslog:
None found

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0       CoreUI                          0x189699354
 0x189622000 + 0x77354
    // -[CUICatalog
   _resolvedRenditionKeyFromThemeRef:withBaseKey:scaleFactor:
  deviceIdiom:deviceSubtype:displayGamut:layoutDirection:
  sizeClassHorizontal:
  sizeClassVertical:memoryClass:graphicsClass:
  graphicsFallBackOrder:iconSizeIndex:] + 0x824
1       CoreUI                          0x1896993c0
 0x189622000 + 0x773c0
    // -[CUICatalog
   _resolvedRenditionKeyFromThemeRef:withBaseKey:scaleFactor:
  deviceIdiom:deviceSubtype:displayGamut:layoutDirection:
  sizeClassHorizontal:
  sizeClassVertical:memoryClass:graphicsClass:
  graphicsFallBackOrder:
  iconSizeIndex:] + 0x890
2       CoreUI                          0x189698b2c
 0x189622000 + 0x76b2c
    // -[CUICatalog
  _resolvedRenditionKeyForName:scaleFactor:
  deviceIdiom:deviceSubtype:displayGamut:layoutDirection:
  sizeClassHorizontal:
  sizeClassVertical:memoryClass:graphicsClass:
  graphicsFallBackOrder:
  withBaseKeySelector:] + 0x134

.
.
.


55      UIKit                           0x18b6982e8
 0x18b625000 + 0x732e8
    // UIApplicationMain + 0xd0
56      MobileSMS (*)                   0x10004cdd8
 0x10002c000 + 0x20dd8
    // 0x00020d58 + 0x80
57      libdyld.dylib                   0x181be656c
 0x181be5000 + 0x156c
    // start + 0x4

Binary Images (dpkg):
0x1000a8000 - 0x1000affff + TweakInject.dylib arm64
  &lt;5e43b90a0c4336c38fe56ac76a7ec1d9&gt;
   /usr/lib/TweakInject.dylib
   {&quot;install_date&quot;:&quot;2018-04-23 09:31:57 +0300&quot;,
   &quot;name&quot;:&quot;Tweak Injector&quot;,
   &quot;identifier&quot;:&quot;org.coolstar.tweakinject&quot;,
   &quot;version&quot;:&quot;1.0.6&quot;}
0x100224000 - 0x100237fff + libcolorpicker.dylib arm64
  &lt;62b3bd5a87e03646a7feda66fc69a70c&gt;
  /usr/lib/libcolorpicker.dylib
   {&quot;install_date&quot;:&quot;2018-04-25 23:17:08 +0300&quot;,
   &quot;name&quot;:&quot;libcolorpicker&quot;,
   &quot;identifier&quot;:&quot;org.thebigboss.libcolorpicker&quot;,
   &quot;version&quot;:&quot;1.6-1&quot;}
0x100244000 - 0x10024bfff + CydiaSubstrate arm64
  &lt;766a34171a3c362cae719390c6a8d715&gt;
  /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate
   {&quot;install_date&quot;:&quot;2018-04-23 09:31:57 +0300&quot;,
   &quot;name&quot;:
   &quot;Substrate Compatibility Layer&quot;,
   &quot;identifier&quot;:&quot;mobilesubstrate&quot;,
   &quot;version&quot;:&quot;99.0&quot;}
0x100254000 - 0x100267fff + libsubstitute.0.dylib arm64
  &lt;4aa77c47f1ec362dab77d70748383ef3&gt;
   /usr/lib/libsubstitute.0.dylib
   {&quot;install_date&quot;:&quot;2018-04-23 09:31:57 +0300&quot;,
   &quot;name&quot;:&quot;Substitute&quot;,
   &quot;identifier&quot;:&quot;com.ex.libsubstitute&quot;,
   &quot;version&quot;:&quot;0.0.6-coolstar&quot;}
0x1002c0000 - 0x1002c7fff + librocketbootstrap.dylib arm64
  &lt;937a654a197136fda4826d3943045632&gt;
  /usr/lib/librocketbootstrap.dylib
   {&quot;install_date&quot;:&quot;2018-04-23 09:31:57 +0300&quot;,
   &quot;name&quot;:&quot;RocketBootstrap&quot;,
   &quot;identifier&quot;:&quot;com.rpetrich.rocketbootstrap&quot;,
   &quot;version&quot;:&quot;1.0.6&quot;}

Binary Images (App Store):

Binary Images (Other):
0x10002c000 - 0x10007bfff   MobileSMS arm64
  &lt;38a8f6a396ce3d5f99600cacce041555&gt;
   /Applications/MobileSMS.app/MobileSMS
0x100104000 - 0x100143fff   dyld arm64  
&lt;92368d6f78863cc88239f2e3ec79bba8&gt; /usr/lib/dyld</code></pre>
<p>Clearly we can see the Termination Code <code>0x2bad45ec</code> (spoken as “Too Bad For Security”) and the <code>Termination Description</code></p>
<pre><code>SPRINGBOARD,
Process detected doing insecure drawing while in secure mode</code></pre>
<p>We would not expect an Apple provided app, MobileSMS, to crash. Looking carefully at the <code>Binary Images</code> section we can see that the Operating System has been “tweaked”. This phone has been jailbroken due to the reference to <code>CydiaSubstrate</code>. We cannot safely rely on any of the apps as having their original design integrity. Perhaps on this phone the MobileSMS app was tweaked to add extra functionality but has introduced a drawing related bug.</p>
<h1 id="failed-crashes">Failed Crashes</h1>
<p>In this chapter we discuss <em>Failed</em> Crashes. That is those crashes which did not end up with a proper crash report returned to us. Sometimes this happens due to the third party crash reporting framework that is faulty. In this chapter we focus on first party reasons for failed crashes, and explain some scenarios that can be the cause.</p>
<h2 id="signal-handling-failures">Signal handling failures</h2>
<p>When a program is being debugged, it is conceptually in a similar state to when it is crashed. That is because we want to go into the process and inspect its state (or potentially change the program by inserting breakpoints). In iOS 13.5 (fixed in iOS 14.x), there is a glitch where if an application tells the Operating System it is expecting to be debugged, then when the system wants to kill it off as a result of a crash it finds that it cannot kill the app. Instead, the entire platform jams up and needs a reset.</p>
<p>If we have an application we has some anti-reverse engineering, or anti-debugging functionality, perhaps through framework, we might end up in this situation because making an app pretend it is already being debugged is a common technique to preventing a debugger attaching.</p>
<p>The application <code>icdab_pt</code> demonstrates the problem. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span>. <span class="citation" data-cites="jitios">(“Jailed Just in Time Compilation on iOS” 2020)</span>.</p>
<pre><code>#define SIZE 4096
#define SHM_NAME &quot;map-jit-memory&quot;

#define PT_TRACE_ME 0
int ptrace(int, pid_t, caddr_t, int); // private method

+ (void)crashThenStallCrashReporting:(BOOL)stall {
    int fd = open(SHM_NAME, O_RDWR | O_CREAT, 0666);
    int result = ftruncate(fd, SIZE);
    
    // we are not privileged so this will not be successful
    void *buf1 = mmap(0,
                      SIZE,
                      PROT_READ | PROT_WRITE,
                      MAP_JIT,
                      fd,
                      0);
    
    if (stall) {
        ptrace(PT_TRACE_ME, 0, NULL, 0);
    }
    
    // trigger crash by accessing a bad buffer
    strcpy(buf1, &quot;Modified buffer&quot;);
    
    result = munmap(buf1, SIZE);
    result = shm_unlink(SHM_NAME);
}</code></pre>
<p>The above code causes the same disruption to crash reporting on a simulator as it does on target hardware. For the sake of convenience, we focus on the simulator target as it is easy to reset, and to compare different OS versions.</p>
<p>When we run on iOS 13.5 we find that the system hangs when passed in <code>YES</code>, but crashes properly when passed <code>NO</code>. On iOS 14.x we immediately get a crash in both circumstances.</p>
<h2 id="symbolification-failure">Symbolification Failure</h2>
<p>The crash reporting program, <code>ReportCrash</code>, can itself fail. Fortunately, there is a fail safe mechanism that allows <code>ReportCrash</code> failures to be reported by <code>ReportCrash</code>.</p>
<p>In our example, we see that the Symbolification phase failed.</p>
<pre><code>Incident Identifier: FD5D3125-4CD2-4A42-8C4C-86022EDED6B7
CrashReporter Key:   28184df1e2804fabaabb19f3a67639f76eb8f299
Hardware Model:      iPhone11,8
Process:             ReportCrash [2437]
Path:                /System/Library/CoreServices/ReportCrash
Identifier:          ReportCrash
Version:             ???
Code Type:           ARM-64 (Native)
Role:                Unspecified
Parent Process:      launchd [1]
Coalition:           com.apple.ReportCrash [570]</code></pre>
<pre><code>Exception Type:  EXC_BAD_ACCESS (SIGBUS)
Exception Subtype: UNKNOWN_0x32 at 0x000000017e012290
VM Region Info: 0x17e012290 is in 0x16f180000-0x17f180000;  bytes
 after start: 250159760  bytes before end: 18275695
      REGION TYPE                      START - END             [
 VSIZE] PRT/MAX SHRMOD  REGION DETAIL
      Stack                  000000016f0f8000-000000016f180000 [ 
 544K] rw-/rwx SM=COW  thread 5
---&gt;  mapped file            000000016f180000-000000017f180000
 [256.0M] r-x/r-x SM=COW  ...t_id=555409f3
      GAP OF 0x2cdbc000 BYTES
      unused shlib __TEXT    00000001abf3c000-00000001abf78000 [ 
 240K] r-x/r-x SM=COW  ... this process

Termination Signal: Bus error: 10
Termination Reason: Namespace SIGNAL, Code 0xa
Terminating Process: exc handler [2437]
Triggered by Thread:  1</code></pre>
<pre><code>0   CoreSymbolication                   0x00000001c63b9138
 0x1c6357000 + 401720
1   CoreSymbolication                   0x00000001c63b8e50
 0x1c6357000 + 400976
2   CoreSymbolication                   0x00000001c63b8e50
 0x1c6357000 + 400976
3   CoreSymbolication                   0x00000001c63b3884
 0x1c6357000 + 379012
4   libdyld.dylib                       0x00000001ac19c374
 0x1ac194000 + 33652
5   CoreSymbolication                   0x00000001c63b3620
 0x1c6357000 + 378400
6   CoreSymbolication                   0x00000001c63b83b0
 0x1c6357000 + 398256
7   CoreSymbolication                   0x00000001c63b9f88
 0x1c6357000 + 405384
8   Symbolication                       0x00000001ccac7598
 0x1cca9d000 + 173464
9   Symbolication                       0x00000001ccac8220
 0x1cca9d000 + 176672
10  ReportCrash                         0x0000000100f417e0
 0x100f3c000 + 22496
11  ReportCrash                         0x0000000100f3e6c8
 0x100f3c000 + 9928
12  ReportCrash                         0x0000000100f3fb70
 0x100f3c000 + 15216
13  ReportCrash                         0x0000000100f4a3e0
 0x100f3c000 + 58336
14  ReportCrash                         0x0000000100f4d6f0
 0x100f3c000 + 71408
15  ReportCrash                         0x0000000100f4d78c
 0x100f3c000 + 71564
16  libsystem_kernel.dylib              0x00000001ac16867c
 0x1ac165000 + 13948
17  ReportCrash                         0x0000000100f49a8c
 0x100f3c000 + 55948
18  libsystem_pthread.dylib             0x00000001ac0a9d50
 0x1ac0a8000 + 7504
19  libsystem_pthread.dylib             0x00000001ac0b1c88
 0x1ac0a8000 + 40072</code></pre>
<pre><code>Thread 1 crashed with ARM Thread State (64-bit):
    x0: 0x000000014df61b80   x1: 0x00000000000387bf   x2:
 0x0000000000000080   x3: 0x0000000000036df0
    x4: 0x0000000000000000   x5: 0x0000000000000000   x6:
 0x0000000000000080   x7: 0x000000017e012290
    x8: 0x00000001489f8000   x9: 0x0000000148a2edf0  x10:
 0x0000000000000080  x11: 0x000000017e014000
   x12: 0x0000000010000000  x13: 0x00000001b0000000  x14:
 0x0000000000000000  x15: 0x000000014f0852e0
   x16: 0x00000001a0000000  x17: 0xffffffffffffffff  x18:
 0x0000000000000000  x19: 0x000000014df61b80
   x20: 0x000000014df61b80  x21: 0x00000001aee92290  x22:
 0x0000000000000080  x23: 0x000000017e012290
   x24: 0x0000000000000001  x25: 0x00000000005cf000  x26:
 0x0000000138f54000  x27: 0x000000016ef48e68
   x28: 0x0000000000036df0   fp: 0x000000016ef486b0   lr:
 0x843bf481c63b8e50
    sp: 0x000000016ef486a0   pc: 0x00000001c63b9138 cpsr:
 0x20000000
   esr: 0x92000006 (Data Abort) byte read Translation fault

Binary Images:
0x100f3c000 - 0x100f53fff ReportCrash arm64e 
 &lt;280941d3f7a93468982d7b115aa1f8a1&gt;
 /System/Library/CoreServices/ReportCrash
.
.
0x1c6357000 - 0x1c63dcfff CoreSymbolication arm64e 
 &lt;19219f5e25623142895af16a024bf332&gt;
 /System/Library/PrivateFrameworks/CoreSymbolication.framework/Co
reSymbolication
.
.
0x1cca9d000 - 0x1ccb1bfff Symbolication arm64e 
 &lt;f8f62c98901f34fb82c75a0d61044452&gt;
 /System/Library/PrivateFrameworks/Symbolication.framework/Symbol
ication</code></pre>
<p>We can find the <code>CoreSymbolification</code> binary at:</p>
<pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.pla
tform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simru
ntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFramew
orks/CoreSymbolication.framework</code></pre>
<p>From the <code>pc</code>, looking at <code>CoreSymbolification</code> with Hopper, as we have done before, by relocating our binary to <code>0x1c6357000</code> and inspecting <code>0x00000001c63b9138</code> we find that the crash is due to a C++ routine manipulating memory:</p>
<pre><code>  std::__1::__split_buffer&lt;TRawRegion&lt;Pointer64&gt;,
 std::__1::allocator&lt;TRawRegion&lt;Pointer64&gt;
 &gt;&amp;&gt;::__split_buffer(&amp;var_38, r1, r2);</code></pre>
<p>from the Apple Open Source C++ library, <code>libcpp</code>. <span class="citation" data-cites="libcpp">(“Libcpp Apple Open Source” 2020)</span></p>
<p>Historically, Symbolification has been a source of failures, and it is a major sub-system that crash reporting relies upon.</p>
<h1 id="memory-diagnostics">Memory Diagnostics</h1>
<p>In this chapter, we look at different diagnostic options for resolving memory problems.</p>
<h2 id="basics-of-memory-allocation">Basics of memory allocation</h2>
<p>The iOS platform allocates memory for our app either on the stack or from the heap.</p>
<p>Memory is allocated on the stack whenever we create locally scoped variables within functions. Memory is allocated from the heap whenever we call <code>malloc</code> (or its variants).</p>
<p>The minimum granularity of allocation on the heap is 16 bytes (an implementation detail we are not to rely upon). This means a small overshoot can sometimes go undetected when we are accidentally overwriting past the number of bytes we have allocated.</p>
<p>When memory is allocated, it is placed into a Virtual Memory region. There are virtual memory regions for allocations of approximately the same size. For example, we have regions <code>MALLOC_LARGE</code>, <code>MALLOC_SMALL</code>, and <code>MALLOC_TINY</code>. This strategy tends to reduce the amount of fragmentation of memory. Furthermore, there is a region for storing the bytes of an image, the “CG image” region. This allows the system to optimize the performance of the system.</p>
<p>The hard part about memory allocation errors is that the symptoms can be confusing because adjacent memory might be used for different purposes, so one logical area of the system can interfere with an unrelated area of the system. Furthermore, there can be a delay (or latency) so the problem is discovered much later than when the problem was introduced.</p>
<h2 id="address-sanitizer">Address Sanitizer</h2>
<p>A very powerful tool can assist with memory diagnostics, called the Address Sanitizer. (See <span class="citation" data-cites="asanchecker">Serebryany et al. (2012)</span>)</p>
<p>It requires us to recompile our code with the Scheme setting for Address Sanitizer set:</p>
<p><img src="screenshots/diagnostic_santizer_setting.png" /></p>
<p>Address sanitizer does memory accounting (called Shadow Memory). It knows which memory locations are “poisoned”. That is, memory which has not been allocated (or was allocated, and then freed).</p>
<p><span class="citation" data-cites="wwdc2015_413">(“Advanced Debugging with Address Sanitizer” 2015)</span></p>
<p>Address sanitizer directly makes use of the compiler so that when code is compiled, any access to memory entails a check against the Shadow Memory to see if the memory location is poisoned. If so, an error report is generated.</p>
<p>This is a very powerful tool because it tackles the two most important classes of memory error:</p>
<ol type="1">
<li>Heap Buffer Overflow</li>
<li>Heap Use After Free</li>
</ol>
<p><em>Heap Buffer Overflow</em> bugs are where we used more bytes than we were allocated. <em>Heap Use After Free</em> bugs are where we used memory after it had been freed.</p>
<p>Address Sanitizer goes much further to address other classes of memory error but those are less often encountered: stack buffer overflow, global variable overflow, overflows in C++ containers, and use after return bugs.</p>
<p>The cost of this convenience is that our program can be x2 to x5 slower. It is something worth switching on in our continuous integration systems to shake out problems.</p>
<h2 id="memory-overshoot-example">Memory overshoot example</h2>
<p>Consider the following code in the <code>icdab_edge</code> example program. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<pre><code>- (void)overshootAllocated
{
    uint8_t *memory = malloc(16);
    for (int i = 0; i &lt; 16 + 1; i++) {
        *(memory + i) = 0xff;
    }
}</code></pre>
<p>This code allocates the minimum amount of memory, 16 bytes. Then it writes to 17 consecutive memory locations. We get a heap overflow bug.</p>
<p>This problem, itself, does not make our app crash immediately. If we rotate the device, the latent fault is triggered and we get a crash. By enabling the address sanitizer, we immediately get a crash. This is a huge benefit. Otherwise, we might have wasted a lot of time in debugging screen rotation related code.</p>
<p>The error report from Address Sanitizer is extensive. We only show selected portions of the report for ease of demonstration.</p>
<p>The error report begins with:</p>
<pre><code>==21803==ERROR: AddressSanitizer:
 heap-buffer-overflow on address
 0x60200003a5e0 at
  pc 0x00010394461b bp 0x7ffeec2b8f00 sp 0x7ffeec2b8ef8
WRITE of size 1 at 0x60200003a5e0 thread T0
#0 0x10394461a in -[Crash overshootAllocated] Crash.m:48</code></pre>
<p>This is enough context to be able to switch to the code, and start understanding the problem.</p>
<p>Further details are supplied showing we overshot the end of a 16-byte allocation:</p>
<pre><code>0x60200003a5e0 is located 0 bytes to the right of
 16-byte region [0x60200003a5d0,0x60200003a5e0)
allocated by thread T0 here:
#0 0x103bcdaa3 in wrap_malloc
(libclang_rt.asan_iossim_dynamic.dylib:x86_64+0x54aa3)
#1 0x1039445ae in -[Crash overshootAllocated] Crash.m:46</code></pre>
<p>Note the use of a “half-open” number range number notation, where <code>[</code> includes the lower range index, and <code>)</code> excludes the upper range index. So our access to <code>0x60200003a5e0</code> is outside the allocated range <code>[0x60200003a5d0,0x60200003a5e0)</code></p>
<p>We also get a “map” of the memory around the problem, truncating <code>0x1c0400007460</code> to <code>....7460</code> for ease of demonstration:</p>
<pre><code>SUMMARY: AddressSanitizer: heap-buffer-overflow Crash.m:48 in
 -[Crash overshootAllocated]
Shadow bytes around the buggy address:
....7460: fa fa 00 00 fa fa fd fd fa fa fd fa fa fa fd fa
....7470: fa fa 00 00 fa fa fd fa fa fa 00 00 fa fa fd fd
....7480: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa
....7490: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fa
....74a0: fa fa 00 fa fa fa 00 00 fa fa fd fd fa fa 00 00
=&gt;....74b0: fa fa 00 00 fa fa 00 00 fa fa 00 00[fa]fa fa fa
....74c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
....74d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
....74e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
....74f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
....7500: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend
(one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa</code></pre>
<p>From <code>[fa]</code> we see we hit the first byte of the “redzone” (poisoned memory).</p>
<h2 id="use-after-free-example">Use after free example</h2>
<p>Consider the following code in the <code>icdab_edge</code> example program. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<pre><code>- (void)useAfterFree
{
    uint8_t *memory = malloc(16);         // line 54
    for (int i = 0; i &lt; 16; i++) {
        *(memory + i) = 0xff;
    }
    free(memory);                         // line 58
    for (int i = 0; i &lt; 16; i++) {
        *(memory + i) = 0xee;             // line 60
    }
}</code></pre>
<p>This code allocates the minimum amount of memory, 16 bytes, writes to it, frees it and then tries a second time to write to the same memory.</p>
<p>Address Sanitizer reports where we accessed memory that has already been freed:</p>
<pre><code>35711==ERROR: AddressSanitizer:
 heap-use-after-free on address
0x602000037270 at
 pc 0x000106d34381 bp 0x7ffee8ec9ef0 sp 0x7ffee8ec9ee8
WRITE of size 1 at 0x602000037270 thread T0
    #0 0x106d34380 in -[Crash useAfterFree] Crash.m:60</code></pre>
<p>It tells us where the free was done:</p>
<pre><code>0x602000037270 is located 0 bytes inside of 16-byte region
 [0x602000037270,0x602000037280)
freed by thread T0 here:
    #0 0x106fbdc6d in wrap_free
    (libclang_rt.asan_iossim_dynamic.dylib:x86_64+0x54c6d)
    #1 0x106d34318 in -[Crash useAfterFree] Crash.m:58</code></pre>
<p>It tells us where the memory was originally allocated:</p>
<pre><code>previously allocated by thread T0 here:
    #0 0x106fbdaa3 in wrap_malloc
    (libclang_rt.asan_iossim_dynamic.dylib:x86_64+0x54aa3)
    #1 0x106d3428e in -[Crash useAfterFree] Crash.m:54
    SUMMARY: AddressSanitizer: heap-use-after-free Crash.m:60 in
     -[Crash useAfterFree]</code></pre>
<p>Finally, it shows us a picture of memory around the faulty address, truncating <code>0x1c0400006df0</code> to <code>....6df0</code> for ease of demonstration:</p>
<pre><code>    Shadow bytes around the buggy address:
  ....6df0: fa fa fd fd fa fa 00 00 fa fa fd fd fa fa fd fa
  ....6e00: fa fa fd fa fa fa 00 00 fa fa fd fa fa fa 00 00
  ....6e10: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fa
  ....6e20: fa fa fd fa fa fa fd fd fa fa fd fd fa fa fd fa
  ....6e30: fa fa fd fa fa fa 00 fa fa fa 00 00 fa fa fd fd
=&gt;....6e40: fa fa 00 00 fa fa 00 00 fa fa 00 00 fa fa[fd]fd
  ....6e50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  ....6e60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  ....6e70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  ....6e80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  ....6e90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
    Shadow byte legend
    (one shadow byte represents 8 application bytes):
      Addressable:           00
      Partially addressable: 01 02 03 04 05 06 07
      Heap left redzone:       fa
      Freed heap region:       fd</code></pre>
<p>We see the entry, <code>[fd]</code> indicating a write to memory that has been freed already.</p>
<h2 id="memory-management-tools">Memory Management tools</h2>
<p>There is a collection of tools complementary to the Address Sanitizer tool. These are to be used when Address Sanitizer is off. They catch certain causes of failure that Address Sanitizer would miss.</p>
<p>In contrast to the Address Sanitizer, the memory management tools do not require a re-compilation of the project.</p>
<h3 id="guard-malloc-tool">Guard Malloc Tool</h3>
<p>This tool is only available on simulator targets, a major disadvantage. Every allocation is placed into its own memory page with guard pages before and after. This tool is largely superseded by Address Sanitizer.</p>
<h3 id="malloc-scribble">Malloc Scribble</h3>
<p>The purpose of Malloc Scribble is to make the symptoms of memory errors predictable by having <code>malloc</code>-ed or <code>free</code>-ed memory assigned to fixed known values. Allocated memory is given <code>0xAA</code> and deallocated memory is given <code>0x55</code>. It does not affect the behavior of data allocated on the stack. It is not compatible with Address Sanitizer.</p>
<p>If we have an app that keeps crashing different ways each time it is run, then Malloc Scribble is a good option. It will help make the crash predictable and repeatable.</p>
<p>Consider the following code in the <code>icdab_edge</code> example program. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<pre><code>- (void)uninitializedMemory
{
    uint8_t *source = malloc(16);
    uint8_t target[16] = {0};
    for (int i = 0; i &lt; 16; i++) {
       target[i] = *(source + i);
    }
}</code></pre>
<p>First, <code>source</code> is given freshly allocated memory. Since this memory has not yet been initialized, it is set to 0xAA when Malloc Scribble has been set (and address sanitizer reset) in the Scheme settings.</p>
<p>Then, <code>target</code> is setup. It is a buffer on the stack (not heap memory). Using the code, <code>= {0}</code>, we make the app set <code>0</code> in all memory locations of this buffer. Otherwise, it would be random memory values.</p>
<p>Then we enter a loop. By breakpointing in the debugger, say at the second iteration, we can print off the memory contents and see the following:</p>
<p><img src="screenshots/scribble.png" /></p>
<p>We see that the <code>target</code> buffer is zeros apart from the first two index positions where it is <code>0xAA</code>. We see that the <code>source</code> memory is always <code>0xAA</code></p>
<p>If we had not set Malloc Scribble, the target buffer would have been filled with random values. In a complex program, such data could be fed to other subsystems affecting the behavior of the program.</p>
<h3 id="zombie-objects">Zombie Objects</h3>
<p>The purpose of Zombie Objects is to detect use-after-free bugs in the context of Objective-C <code>NSObject</code>s. Particularly if we have a legacy code base that uses Manual Reference Counting, it can be easy to over release an object. This means that messaging through the, now dangling, pointer can have unpredictable effects.</p>
<p>This setting must only be made on debug builds because the code will no longer release objects. Its performance profile is equivalent to leaking every object that should have been deallocated.</p>
<p>This setting will make deallocated objects to instead become <code>NSZombie</code> objects. Any message sent to an <code>NSZombie</code> object results in an immediate crash. Therefore, whenever an over-released object is messaged, we are guaranteed a crash.</p>
<p>Consider the following code in the <code>icdab_edge</code> example program. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<pre><code>- (void)overReleasedObject
{
    id vc = [[UIViewController alloc] init];
    // Build Phases -&gt; Compile Sources
    // -&gt; Crash.m has Compiler Flags setting
    // -fno-objc-arc to allow the following line to be called
    [vc release];
    NSLog(@&quot;%@&quot;, [vc description]);
}</code></pre>
<p>When the above code is called we get a crash, and the following is logged:</p>
<pre><code>2018-09-12 12:09:10.236058+0100 icdab_edge[92796:13650378]
 *** -[UIViewController description]: message sent to deallocated
  instance 0x7fba1ff071c0</code></pre>
<p>Looking at the debugger, we see:</p>
<p><img src="screenshots/zombie.png" /></p>
<p>Note how the type of the object instance <code>vc</code> is <code>_NSZombie_UIViewController *</code>.</p>
<p>The type will be whatever the original type of the over released object was, but prefixed with <code>_NSZombie_</code>. This is most helpful, and we should look out for this when studying the program state in the debugger.</p>
<h3 id="malloc-stack">Malloc Stack</h3>
<p>Sometimes the past dynamic behavior of our app needs to be understood in order to resolve why the application crashed. For example, we may have leaked memory, and then we were terminated by the system for using too much memory. We might have a data structure and wonder which part of the code was responsible for allocating it.</p>
<p>The purpose of the <code>Malloc Stack</code> option is to provide the historical data we require. Memory analysis has been enhanced by Apple by providing complementary visual tools. Malloc Stack has a sub-option, “All Allocation and Free History” or “Live Allocations Only”</p>
<p>We recommend the “All Allocation” option, unless there is just too much overhead experienced with it. That may be due to having an app which makes heavy use of memory allocation. The “Live Allocations Only” option is sufficient to catch memory leaks as well as being low overhead, so it is the default option in the User Interface.</p>
<p>The steps to follow are:</p>
<ol type="1">
<li>Set the <code>Malloc Stack</code> option in the Diagnostics settings tab.</li>
<li>Launch the app.</li>
<li>Press the Debug Memgraph Button</li>
<li>For command line based analysis, <em>File -&gt; Export Memory Graph…</em></li>
</ol>
<p>The Memgraph visual tool within Xcode is comprehensive but can feel daunting. There is a helpful WWDC video to show the basics. <span class="citation" data-cites="wwdc2018_416">(“IOS Memory Deep Dive” 2018)</span></p>
<p>There is normally too much low-level detail to review. The best way to use the graphical tool is when we have some hypothesis on why the app is incorrectly using memory.</p>
<h4 id="malloc-stack-memgraph-example-detecting-retain-cycles">Malloc Stack Memgraph example: detecting retain cycles</h4>
<p>A quick win is to see if we have any leaks. These are memory locations no longer reachable to be able to free up.</p>
<p>We use the tvOS example app <code>icdab_cycle</code> to show a retain cycle found by Memgraph. <span class="citation" data-cites="icdabgithub">(“IOS Crash Dump Analysis Book Github Resources” 2018)</span></p>
<p>Having set the Scheme settings for Malloc Stack, we then launch the app and then press the Memgraph Button, shown below:</p>
<p><img src="screenshots/memgraphbutton.png" /></p>
<p>By pressing the exclamation mark filter button we can filter to only showing leaks:</p>
<p><img src="screenshots/retaincycle.png" /></p>
<p>If we had done <em>File -&gt; Export Memory Graph…</em>, to export the memgraph to <code>icdab_cycle.memgraph</code>, we could see the equivalent information from the Mac Terminal app with the command line:</p>
<pre><code>leaks icdab_cycle.memgraph
Process:         icdab_cycle [52119]
Path:           
 /Users/faisalm/Library/Developer/CoreSimulator/Devices/3BC2C1DF-
EBBA-41D3-A42F-87E6D86EF26D/data/Containers/Bundle/Application/A2
7B3F5B-5703-40D4-AA6C-D054F1289BDD/icdab_cycle.app/icdab_cycle
Load Address:    0x10918a000
Identifier:      icdab_cycle
Version:         ???
Code Type:       X86-64
Platform:        tvOS Simulator
Parent Process:  debugserver [52123]

Date/Time:       2020-10-01 13:16:58.832 +0100
Launch Time:     2020-10-01 13:16:36.315 +0100
OS Version:      Apple TVOS 14.2 (18K5027e)
Report Version:  7
Analysis Tool:  
 /Volumes/SAMSUNG/Applications/Xcode12_2-beta.app/Contents/Develo
per/Platforms/AppleTVOS.platform/Library/Developer/CoreSimulator/
Profiles/Runtimes/tvOS.simruntime/Contents/Resources/RuntimeRoot/
Developer/Library/PrivateFrameworks/DVTInstrumentsFoundation.fram
ework/LeakAgent
Analysis Tool Version:  iOS Simulator 14.2 (18K5027e)
----

leaks Report Version: 4.0, multi-line stacks
Process 52119: 28212 nodes malloced for 3421 KB
Process 52119: 3 leaks for 144 total leaked bytes.

STACK OF 1 INSTANCE OF &#39;ROOT CYCLE: &lt;Album&gt;&#39;:
50  libdyld.dylib                      0x7fff201c2435 start + 1
49  com.perivalebluebell.icdab-cycle        0x109190d2b main + 75
  AppDelegate.swift:12 ....</code></pre>
<p>The code that causes this leak is:</p>
<pre><code>var mediaLibrary: Album?

func createRetainCycleLeak() {
    let salsa = Album()
    let carnaval = Song(album: salsa,
     artist: &quot;Salsa Latin 100%&quot;,
     title: &quot;La Vida Es un Carnaval&quot;)
    salsa.songs.append(carnaval)
}

func buildMediaLibrary() {
    let kylie = Album()
    let secret = Song(album: kylie,
     artist: &quot;Kylie Minogue&quot;,
     title: &quot;It&#39;s No Secret&quot;)
    kylie.songs.append(secret)
    mediaLibrary = kylie
    createRetainCycleLeak()
}</code></pre>
<p>The problem is that <code>createRetainCycleLeak()</code> <code>carnaval</code> <code>Song</code> makes a strong reference to <code>salsa</code> <code>Album</code>, <code>salsa</code> makes a strong reference to <code>carnaval</code> <code>Song</code>, and when we return from this method, there is no reference to either object from another object. The two objects become disconnected from the rest of the object graph, and they cannot be automatically released due to their mutual strong references (known as a retain cycle). A very similar object relationship for <code>kylie</code> <code>Album</code> does not trigger a leak because that is referenced by a top level graph object <code>mediaLibrary</code></p>
<h3 id="dynamic-linker-api-usage">Dynamic Linker API Usage</h3>
<p>Sometimes programs dynamically adapt or are extensible. For such programs, the dynamic linker API is used to programmatically load up extra code modules. When the configuration or deployment of the app is faulty, this can result in crashes.</p>
<p>To debug such problems, set the <code>Dynamic Linker API Usage</code> flag. This can generate many messages so may cause problems on slower platforms with limited start up times such as a 1st generation Apple Watch.</p>
<p>An example app using the dynamic linker is available on GitHub. <span class="citation" data-cites="dynamicloadingeg">(“Dynamic Loading Example” 2018)</span></p>
<p>The kind of output when it is enabled is:</p>
<pre><code>_dyld_get_image_slide(0x105545000)
_dyld_register_func_for_add_image(0x10a21264c)
_dyld_get_image_slide(0x105545000)
_dyld_get_image_slide(0x105545000)
_dyld_register_func_for_add_image(0x10a5caf39)
dyld_image_path_containing_address(0x1055d2000)
.
.
.

dlopen(DynamicFramework2.framework/DynamicFramework2)
 ==&gt; 0x60c0001460f0
.
.
.</code></pre>
<p>A huge amount of logging is generated. It is best to start by searching for the <code>dlopen</code> command, and then looking to see what other functions in the <code>dlopen</code> family are called.</p>
<h3 id="dynamic-library-loads">Dynamic Library Loads</h3>
<p>Sometimes we have an early stage app crash during the initialization phase where the dynamic loader is loading the app binary and its dependent frameworks. If we are confident that it is not custom code using the dynamic linker API, but instead it is the assembly of frameworks into the loaded binary we care about, then switching on the <code>Dynamic Library Loads</code> flag is appropriate. We get much shorter logs than enabling the <code>Dynamic Linker API Usage</code> flag.</p>
<p>Older versions of Xcode allowed setting of the <code>Dynamic Library Loads</code> via the Scheme settings. For the more recent Xcode 12.x, such an option is no longer present in the User Interface. However, the same options can be switched on via Scheme Environment Variables settings. <span class="citation" data-cites="dynamicloadingenvvars">(“Logging Dynamic Loader Events” 2020)</span></p>
<p><img src="screenshots/dynamic_loading_env.png" /></p>
<p>Upon launch, we get a list of binaries loaded:</p>
<pre><code>dyld: loaded: /Users/faisalm/Library/Developer/
CoreSimulator/Devices/
99DB717F-9161-461A-B11F-210C389ABA12/
data/Containers/Bundle/Application/
D916AC0F-6434-46A3-B18E-5EC65D194454/
icdab_edge.app/icdab_edge

dyld: loaded: /Applications/Xcode.app/Contents/Developer/
Platforms/iPhoneOS.platform/Contents/Resources/RuntimeRoot/
usr/lib/libBacktraceRecording.dylib
.
.
.</code></pre>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-macbookproT2">
<p>“2018 Macbook Pros Bridge Os Error.” 2018. <a href="https://forums.macrumors.com/threads/2018-macbook-pros-crashing-with-bridge-os-error.2128976/">https://forums.macrumors.com/threads/2018-macbook-pros-crashing-with-bridge-os-error.2128976/</a>.</p>
</div>
<div id="ref-rosetta">
<p>“About the Rosetta Translation Environment.” 2020. <a href="https://developer.apple.com/documentation/apple_silicon/about_the_rosetta_translation_environment#3616845">https://developer.apple.com/documentation/apple_silicon/about_the_rosetta_translation_environment#3616845</a>.</p>
</div>
<div id="ref-wwdc2015_413">
<p>“Advanced Debugging with Address Sanitizer.” 2015. <a href="https://developer.apple.com/videos/play/wwdc2015/413/">https://developer.apple.com/videos/play/wwdc2015/413/</a>.</p>
</div>
<div id="ref-kepnertregoe">
<p>“Analytic Troubleshooting.” 2018. <a href="https://www.kepner-tregoe.com">https://www.kepner-tregoe.com</a>.</p>
</div>
<div id="ref-tn2151">
<p>“Apple Crash Dump Technote 2151.” 2018. <a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html">https://developer.apple.com/library/archive/technotes/tn2151/_index.html</a>.</p>
</div>
<div id="ref-appleinsiderimacpro">
<p>“Apple’s T2 Chip May Be Behind iMac Pro, Macbook Pro Crashes.” 2018. <a href="https://appleinsider.com/articles/18/07/26/apples-t2-chip-could-be-behind-small-number-of-crashes-in-imac-pro-new-macbook-pro">https://appleinsider.com/articles/18/07/26/apples-t2-chip-could-be-behind-small-number-of-crashes-in-imac-pro-new-macbook-pro</a>.</p>
</div>
<div id="ref-ARM_BRK">
<p>“ARM Breakpoint Instruction.” 2020. <a href="https://developer.arm.com/documentation/100076/0100/a64-instruction-set-reference/a64-general-instructions/brk">https://developer.arm.com/documentation/100076/0100/a64-instruction-set-reference/a64-general-instructions/brk</a>.</p>
</div>
<div id="ref-tn2123">
<p>“CrashReport Technote 2123.” 2004. <a href="https://developer.apple.com/library/archive/technotes/tn2004/tn2123.html">https://developer.apple.com/library/archive/technotes/tn2004/tn2123.html</a>.</p>
</div>
<div id="ref-intelrob">
<p>“Debugging Processor Reorder Buffer Timeout: Guide.” 2018. <a href="https://www.intel.co.uk/content/www/uk/en/embedded/training/rob-timeout-debug-guide-paper.html?wapkw=caterr">https://www.intel.co.uk/content/www/uk/en/embedded/training/rob-timeout-debug-guide-paper.html?wapkw=caterr</a>.</p>
</div>
<div id="ref-apple-sysdiag">
<p>“Diagnostic Profiles and Logs.” 2018. <a href="https://developer.apple.com/bug-reporting/profiles-and-logs/">https://developer.apple.com/bug-reporting/profiles-and-logs/</a>.</p>
</div>
<div id="ref-dynamicloadingeg">
<p>“Dynamic Loading Example.” 2018. <a href="https://github.com/patriknyblad/ios-runtime-loading-dynamic-framework.git">https://github.com/patriknyblad/ios-runtime-loading-dynamic-framework.git</a>.</p>
</div>
<div id="ref-iospac">
<p>“Examining Pointer Authentication on the iPhone Xs.” 2019. <a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html</a>.</p>
</div>
<div id="ref-ARMv8_ESR">
<p>“Exception Syndrome Register.” 2020. <a href="https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/esr_el1">https://developer.arm.com/docs/ddi0595/h/aarch64-system-registers/esr_el1</a>.</p>
</div>
<div id="ref-transitive">
<p>“Heroes of Software Engineering - the Men and Women at Transitive.” 2020. <a href="https://www.software.ac.uk/blog/2016-09-30-heroes-software-engineering-men-and-women-transitive">https://www.software.ac.uk/blog/2016-09-30-heroes-software-engineering-men-and-women-transitive</a>.</p>
</div>
<div id="ref-jetsamreport">
<p>“Identifying High-Memory Use with Jetsam Event Reports.” 2020. <a href="https://developer.apple.com/documentation/xcode/diagnosing_issues_using_crash_reports_and_device_logs/identifying_high-memory_use_with_jetsam_event_reports">https://developer.apple.com/documentation/xcode/diagnosing_issues_using_crash_reports_and_device_logs/identifying_high-memory_use_with_jetsam_event_reports</a>.</p>
</div>
<div id="ref-impropersockets">
<p>“Improper Use of Bsd Sockets.” 2018. <a href="https://stackoverflow.com/a/13790353/2715565">https://stackoverflow.com/a/13790353/2715565</a>.</p>
</div>
<div id="ref-icdabgithub">
<p>“IOS Crash Dump Analysis Book Github Resources.” 2018. <a href="https://github.com/faisalmemon/ios-crash-dump-analysis-book">https://github.com/faisalmemon/ios-crash-dump-analysis-book</a>.</p>
</div>
<div id="ref-3rdpartycrashtools">
<p>“IOS Crash Reporting Tools.” 2017. <a href="https://rollout.io/blog/ios-crash-reporting-tools-2017-update/">https://rollout.io/blog/ios-crash-reporting-tools-2017-update/</a>.</p>
</div>
<div id="ref-wwdc2018_416">
<p>“IOS Memory Deep Dive.” 2018. <a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf?dl=1">https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf?dl=1</a>.</p>
</div>
<div id="ref-ios-versions">
<p>“IOS Version History.” 2018. <a href="https://en.wikipedia.org/wiki/IOS_version_history">https://en.wikipedia.org/wiki/IOS_version_history</a>.</p>
</div>
<div id="ref-jitios">
<p>“Jailed Just in Time Compilation on iOS.” 2020. <a href="https://saagarjha.com/blog/2020/02/23/jailed-just-in-time-compilation-on-ios/">https://saagarjha.com/blog/2020/02/23/jailed-just-in-time-compilation-on-ios/</a>.</p>
</div>
<div id="ref-libcpp">
<p>“Libcpp Apple Open Source.” 2020. <a href="https://opensource.apple.com/source/libcpp/libcpp-19/include/__split_buffer.auto.html">https://opensource.apple.com/source/libcpp/libcpp-19/include/__split_buffer.auto.html</a>.</p>
</div>
<div id="ref-libdispatchtar">
<p>“Libdispatch Open Source.” 2018. <a href="https://opensource.apple.com/tarballs/libdispatch/">https://opensource.apple.com/tarballs/libdispatch/</a>.</p>
</div>
<div id="ref-ios-devices">
<p>“List of iOS Devices.” 2018. <a href="https://en.wikipedia.org/wiki/List_of_iOS_devices">https://en.wikipedia.org/wiki/List_of_iOS_devices</a>.</p>
</div>
<div id="ref-dynamicloadingenvvars">
<p>“Logging Dynamic Loader Events.” 2020. <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/LoggingDynamicLoaderEvents.html">https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/LoggingDynamicLoaderEvents.html</a>.</p>
</div>
<div id="ref-exception-types">
<p>“Mach Exception Types.” 2018. <a href="https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/osfmk/mach/exception_types.h#L68">https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/osfmk/mach/exception_types.h#L68</a>.</p>
</div>
<div id="ref-macherror">
<p>“Making Sense of I/O Kit Error Codes.” 2018. <a href="https://developer.apple.com/library/archive/qa/qa1075/_index.html">https://developer.apple.com/library/archive/qa/qa1075/_index.html</a>.</p>
</div>
<div id="ref-cfconstantstring">
<p>“NSCFConstantString in Corefoundation.framework.” 2018. <a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/CoreFoundation.framework/__NSCFConstantString.h">https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/CoreFoundation.framework/__NSCFConstantString.h</a>.</p>
</div>
<div id="ref-dispatchdata">
<p>“NSDispatchData.h in Foundation.framework.” 2018. <a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/Foundation.framework/_NSDispatchData.h%0A">https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/Foundation.framework/_NSDispatchData.h%0A</a>.</p>
</div>
<div id="ref-class-dump-tool">
<p>Nygard, Steve. 2018. “Class Dump Tool.” <a href="http://stevenygard.com/projects/class-dump/">http://stevenygard.com/projects/class-dump/</a>.</p>
</div>
<div id="ref-panicbook">
<p><em>Panic! Unix System Crash Dump Analysis</em>. 1995. 1st ed. Vol. 1. 0-13-149386-8. Prentice Hall.</p>
</div>
<div id="ref-plcrashreporter">
<p>“Plausible Labs Crash Reporter.” 2018. <a href="https://github.com/plausiblelabs/plcrashreporter">https://github.com/plausiblelabs/plcrashreporter</a>.</p>
</div>
<div id="ref-rosettaPortingGuide">
<p>“Porting Your macOS Apps to Apple Silicon.” 2020. <a href="https://developer.apple.com/documentation/xcode/porting_your_macos_apps_to_apple_silicon">https://developer.apple.com/documentation/xcode/porting_your_macos_apps_to_apple_silicon</a>.</p>
</div>
<div id="ref-resource-management">
<p>“Resource Management.” 2015. <a href="http://newosxbook.com/files/MSAse2015.pdf">http://newosxbook.com/files/MSAse2015.pdf</a>.</p>
</div>
<div id="ref-iosOnMac">
<p>“Running Your iOS Apps on macOS.” 2020. <a href="https://developer.apple.com/documentation/apple_silicon/running_your_ios_apps_on_macos">https://developer.apple.com/documentation/apple_silicon/running_your_ios_apps_on_macos</a>.</p>
</div>
<div id="ref-asanchecker">
<p>Serebryany, Konstantin, Derek Bruening, Alexander Potapenko, and Dmitry Vyukov. 2012. “AddressSanitizer: A Fast Address Sanity Checker.” In <em>USENIX Atc 2012</em>. <a href="https://www.usenix.org/conference/usenixfederatedconferencesweek/addresssanitizer-fast-address-sanity-checker">https://www.usenix.org/conference/usenixfederatedconferencesweek/addresssanitizer-fast-address-sanity-checker</a>.</p>
</div>
<div id="ref-rosetta_news">
<p>“The Brains Behind Apple’s Rosetta: Transitive.” 2020. <a href="https://www.cnet.com/news/the-brains-behind-apples-rosetta-transitive/">https://www.cnet.com/news/the-brains-behind-apples-rosetta-transitive/</a>.</p>
</div>
<div id="ref-threadstatus">
<p>“Thread Status Values in Mach.” 2018. <a href="https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/osfmk/mach/arm/thread_status.h">https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/osfmk/mach/arm/thread_status.h</a>.</p>
</div>
</div>
</body>
</html>
